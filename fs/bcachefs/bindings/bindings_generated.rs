/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const BTREE_ITER_INITIAL: u32 = 64;
pub const BTREE_ITER_MAX: u32 = 1024;
pub type __s8 = core::ffi::c_schar;
pub type __u8 = core::ffi::c_uchar;
pub type __s16 = core::ffi::c_short;
pub type __u16 = core::ffi::c_ushort;
pub type __s32 = core::ffi::c_int;
pub type __u32 = core::ffi::c_uint;
pub type __s64 = core::ffi::c_longlong;
pub type __u64 = core::ffi::c_ulonglong;
pub type s8 = __s8;
pub type u8_ = __u8;
pub type s16 = __s16;
pub type u16_ = __u16;
pub type s32 = __s32;
pub type u32_ = __u32;
pub type s64 = __s64;
pub type u64_ = __u64;
pub type __kernel_ulong_t = core::ffi::c_ulong;
pub type __kernel_uid32_t = core::ffi::c_uint;
pub type __kernel_gid32_t = core::ffi::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_loff_t = core::ffi::c_longlong;
pub type __kernel_clockid_t = core::ffi::c_int;
pub type __le16 = __u16;
pub type __le32 = __u32;
pub type __le64 = __u64;
pub type __poll_t = core::ffi::c_uint;
pub type __kernel_dev_t = u32_;
pub type dev_t = __kernel_dev_t;
pub type umode_t = core::ffi::c_ushort;
pub type clockid_t = __kernel_clockid_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type loff_t = __kernel_loff_t;
pub type ktime_t = s64;
#[doc = " The type used for indexing onto a disc or disc partition.\n\n Linux always considers sectors to be 512 bytes long independently\n of the devices real block size.\n\n blkcnt_t is the type of the inode's block count."]
pub type sector_t = u64_;
pub type blkcnt_t = u64_;
pub type gfp_t = core::ffi::c_uint;
pub type fmode_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct atomic_t {
    pub counter: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct atomic64_t {
    pub counter: s64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
impl Default for list_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
impl Default for hlist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
impl Default for hlist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct callback_head - callback structure for use with RCU and task_work\n @next: next update requests in a list\n @func: actual update function to call after the grace period.\n\n The struct is aligned to size of pointer. On most architectures it happens\n naturally due ABI requirements, but some architectures (like CRIS) have\n weird ABI and we need to ask it explicitly.\n\n The alignment is required to guarantee that bit 0 of @next will be\n clear under normal conditions -- as long as we use call_rcu() or\n call_srcu() to queue the callback.\n\n This guarantee is important for few reasons:\n  - future call_rcu_lazy() will make use of lower bits in the pointer;\n  - the structure shares storage space in struct page with @compound_head,\n    which encode PageTail() in bit 0. The guarantee is needed to avoid\n    false-positive PageTail()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
}
impl Default for callback_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lock_class_key {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lockdep_map {}
pub type va_list = __builtin_va_list;
pub type ctor_fn_t = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_system_type {
    pub name: *const core::ffi::c_char,
    pub fs_flags: core::ffi::c_int,
    pub init_fs_context:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> core::ffi::c_int>,
    pub parameters: *const fs_parameter_spec,
    pub mount: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_system_type,
            arg2: core::ffi::c_int,
            arg3: *const core::ffi::c_char,
            arg4: *mut core::ffi::c_void,
        ) -> *mut dentry,
    >,
    pub kill_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub owner: *mut module,
    pub next: *mut file_system_type,
    pub fs_supers: hlist_head,
    pub s_lock_key: lock_class_key,
    pub s_umount_key: lock_class_key,
    pub s_vfs_rename_key: lock_class_key,
    pub s_writers_key: [lock_class_key; 3usize],
    pub i_lock_key: lock_class_key,
    pub i_mutex_key: lock_class_key,
    pub invalidate_lock_key: lock_class_key,
    pub i_mutex_dir_key: lock_class_key,
}
impl Default for file_system_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct module {
    pub state: module_state,
    pub list: list_head,
    pub name: [core::ffi::c_char; 56usize],
    pub build_id: [core::ffi::c_uchar; 20usize],
    pub mkobj: module_kobject,
    pub modinfo_attrs: *mut module_attribute,
    pub version: *const core::ffi::c_char,
    pub srcversion: *const core::ffi::c_char,
    pub holders_dir: *mut kobject,
    pub syms: *mut kernel_symbol,
    pub crcs: *const s32,
    pub num_syms: core::ffi::c_uint,
    pub param_lock: mutex,
    pub kp: *mut kernel_param,
    pub num_kp: core::ffi::c_uint,
    pub num_gpl_syms: core::ffi::c_uint,
    pub gpl_syms: *const kernel_symbol,
    pub gpl_crcs: *const s32,
    pub using_gplonly_symbols: bool_,
    pub sig_ok: bool_,
    pub async_probe_requested: bool_,
    pub num_exentries: core::ffi::c_uint,
    pub extable: *mut exception_table_entry,
    pub init: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub __bindgen_padding_0: [u64; 5usize],
    pub mem: [module_memory; 7usize],
    pub arch: mod_arch_specific,
    pub taints: core::ffi::c_ulong,
    pub num_bugs: core::ffi::c_uint,
    pub bug_list: list_head,
    pub bug_table: *mut bug_entry,
    pub kallsyms: *mut mod_kallsyms,
    pub core_kallsyms: mod_kallsyms,
    pub sect_attrs: *mut module_sect_attrs,
    pub notes_attrs: *mut module_notes_attrs,
    pub args: *mut core::ffi::c_char,
    pub percpu: *mut core::ffi::c_void,
    pub percpu_size: core::ffi::c_uint,
    pub noinstr_text_start: *mut core::ffi::c_void,
    pub noinstr_text_size: core::ffi::c_uint,
    pub num_tracepoints: core::ffi::c_uint,
    pub tracepoints_ptrs: *const core::ffi::c_int,
    pub num_srcu_structs: core::ffi::c_uint,
    pub srcu_struct_ptrs: *mut *mut srcu_struct,
    pub num_bpf_raw_events: core::ffi::c_uint,
    pub bpf_raw_events: *mut bpf_raw_event_map,
    pub jump_entries: *mut jump_entry,
    pub num_jump_entries: core::ffi::c_uint,
    pub num_trace_bprintk_fmt: core::ffi::c_uint,
    pub trace_bprintk_fmt_start: *mut *const core::ffi::c_char,
    pub trace_events: *mut *mut trace_event_call,
    pub num_trace_events: core::ffi::c_uint,
    pub trace_evals: *mut *mut trace_eval_map,
    pub num_trace_evals: core::ffi::c_uint,
    pub num_ftrace_callsites: core::ffi::c_uint,
    pub ftrace_callsites: *mut core::ffi::c_ulong,
    pub kprobes_text_start: *mut core::ffi::c_void,
    pub kprobes_text_size: core::ffi::c_uint,
    pub kprobe_blacklist: *mut core::ffi::c_ulong,
    pub num_kprobe_blacklist: core::ffi::c_uint,
    pub num_static_call_sites: core::ffi::c_int,
    pub static_call_sites: *mut static_call_site,
    pub printk_index_size: core::ffi::c_uint,
    pub printk_index_start: *mut *mut pi_entry,
    pub source_list: list_head,
    pub target_list: list_head,
    pub exit: ::core::option::Option<unsafe extern "C" fn()>,
    pub refcnt: atomic_t,
    pub ctors: *mut ctor_fn_t,
    pub num_ctors: core::ffi::c_uint,
    pub ei_funcs: *mut error_injection_entry,
    pub num_ei_funcs: core::ffi::c_uint,
    pub dyndbg_info: _ddebug_info,
}
impl Default for module {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8_,
    pub pending: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16_,
    pub tail: u16_,
}
impl Default for qspinlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qspinlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8_,
    pub __lstate: [u8_; 3usize],
}
impl Default for qrwlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qrwlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arch_rwlock_t = qrwlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
impl Default for raw_spinlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ratelimit_state {
    pub lock: raw_spinlock_t,
    pub interval: core::ffi::c_int,
    pub burst: core::ffi::c_int,
    pub printed: core::ffi::c_int,
    pub missed: core::ffi::c_int,
    pub begin: core::ffi::c_ulong,
    pub flags: core::ffi::c_ulong,
}
impl Default for ratelimit_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct pi_entry {
    pub fmt: *const core::ffi::c_char,
    pub func: *const core::ffi::c_char,
    pub file: *const core::ffi::c_char,
    pub line: core::ffi::c_uint,
    pub level: *const core::ffi::c_char,
    pub subsys_fmt_prefix: *const core::ffi::c_char,
}
impl Default for pi_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key {
    pub enabled: atomic_t,
    pub __bindgen_anon_1: static_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_key__bindgen_ty_1 {
    pub type_: core::ffi::c_ulong,
    pub entries: *mut jump_entry,
    pub next: *mut static_key_mod,
}
impl Default for static_key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for static_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct jump_entry {
    pub code: s32,
    pub target: s32,
    pub key: core::ffi::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_true {
    pub key: static_key,
}
impl Default for static_key_true {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_false {
    pub key: static_key,
}
impl Default for static_key_false {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ddebug {
    pub modname: *const core::ffi::c_char,
    pub function: *const core::ffi::c_char,
    pub filename: *const core::ffi::c_char,
    pub format: *const core::ffi::c_char,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub key: _ddebug__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ddebug__bindgen_ty_1 {
    pub dd_key_true: static_key_true,
    pub dd_key_false: static_key_false,
}
impl Default for _ddebug__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ddebug {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _ddebug {
    #[inline]
    pub fn lineno(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_lineno(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn class_id(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_class_id(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lineno: core::ffi::c_uint,
        class_id: core::ffi::c_uint,
        flags: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let lineno: u32 = unsafe { ::core::mem::transmute(lineno) };
            lineno as u64
        });
        __bindgen_bitfield_unit.set(18usize, 6u8, {
            let class_id: u32 = unsafe { ::core::mem::transmute(class_id) };
            class_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum class_map_type {
    DD_CLASS_TYPE_DISJOINT_BITS = 0,
    #[doc = " DD_CLASS_TYPE_DISJOINT_BITS: classes are independent, one per bit.\n expecting hex input. Built for drm.debug, basis for other types."]
    DD_CLASS_TYPE_LEVEL_NUM = 1,
    #[doc = " DD_CLASS_TYPE_LEVEL_NUM: input is numeric level, 0-N.\n N turns on just bits N-1 .. 0, so N=0 turns all bits off."]
    DD_CLASS_TYPE_DISJOINT_NAMES = 2,
    #[doc = " DD_CLASS_TYPE_DISJOINT_NAMES: input is a CSV of [+-]CLASS_NAMES,\n classes are independent, like _DISJOINT_BITS."]
    DD_CLASS_TYPE_LEVEL_NAMES = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ddebug_class_map {
    pub link: list_head,
    pub mod_: *mut module,
    pub mod_name: *const core::ffi::c_char,
    pub class_names: *mut *const core::ffi::c_char,
    pub length: core::ffi::c_int,
    pub base: core::ffi::c_int,
    pub map_type: class_map_type,
}
impl Default for ddebug_class_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ddebug_info {
    pub descs: *mut _ddebug,
    pub classes: *mut ddebug_class_map,
    pub num_descs: core::ffi::c_uint,
    pub num_classes: core::ffi::c_uint,
}
impl Default for _ddebug_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_param_ops {
    pub flags: core::ffi::c_uint,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            val: *const core::ffi::c_char,
            kp: *const kernel_param,
        ) -> core::ffi::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            buffer: *mut core::ffi::c_char,
            kp: *const kernel_param,
        ) -> core::ffi::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg: *mut core::ffi::c_void)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_operations {
    pub owner: *mut module,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: core::ffi::c_int) -> loff_t,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut core::ffi::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const core::ffi::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub read_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub write_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub iopoll: ::core::option::Option<
        unsafe extern "C" fn(
            kiocb: *mut kiocb,
            arg1: *mut io_comp_batch,
            flags: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub iterate_shared: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> core::ffi::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub unlocked_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_uint,
            arg3: core::ffi::c_ulong,
        ) -> core::ffi::c_long,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_uint,
            arg3: core::ffi::c_ulong,
        ) -> core::ffi::c_long,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> core::ffi::c_int,
    >,
    pub mmap_supported_flags: core::ffi::c_ulong,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int,
    >,
    pub flush: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, id: fl_owner_t) -> core::ffi::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int,
    >,
    pub fsync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            datasync: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub fasync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: core::ffi::c_int,
            arg2: *mut file,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub lock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_int,
            arg3: *mut file_lock,
        ) -> core::ffi::c_int,
    >,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_ulong,
            arg3: core::ffi::c_ulong,
            arg4: core::ffi::c_ulong,
            arg5: core::ffi::c_ulong,
        ) -> core::ffi::c_ulong,
    >,
    pub check_flags:
        ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int) -> core::ffi::c_int>,
    pub flock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_int,
            arg3: *mut file_lock,
        ) -> core::ffi::c_int,
    >,
    pub splice_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: usize,
            arg5: core::ffi::c_uint,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: usize,
            arg5: core::ffi::c_uint,
        ) -> isize,
    >,
    pub splice_eof: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
    pub setlease: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_int,
            arg3: *mut *mut file_lock,
            arg4: *mut *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub fallocate: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            mode: core::ffi::c_int,
            offset: loff_t,
            len: loff_t,
        ) -> core::ffi::c_long,
    >,
    pub show_fdinfo: ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, f: *mut file)>,
    pub copy_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: usize,
            arg6: core::ffi::c_uint,
        ) -> isize,
    >,
    pub remap_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            file_in: *mut file,
            pos_in: loff_t,
            file_out: *mut file,
            pos_out: loff_t,
            len: loff_t,
            remap_flags: core::ffi::c_uint,
        ) -> loff_t,
    >,
    pub fadvise: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub uring_cmd: ::core::option::Option<
        unsafe extern "C" fn(
            ioucmd: *mut io_uring_cmd,
            issue_flags: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub uring_cmd_iopoll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut io_uring_cmd,
            arg2: *mut io_comp_batch,
            poll_flags: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
}
impl Default for file_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct static_call_site {
    pub addr: s32,
    pub key: s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_call_key {
    pub func: *mut core::ffi::c_void,
    pub __bindgen_anon_1: static_call_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_call_key__bindgen_ty_1 {
    pub type_: core::ffi::c_ulong,
    pub mods: *mut static_call_mod,
    pub sites: *mut static_call_site,
}
impl Default for static_call_key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for static_call_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: core::ffi::c_int,
    pub file_disp: core::ffi::c_int,
    pub line: core::ffi::c_ushort,
    pub flags: core::ffi::c_ushort,
}
pub type atomic_long_t = atomic64_t;
#[doc = " struct attribute_group - data structure used to declare an attribute group.\n @name:\tOptional: Attribute group name\n\t\tIf specified, the attribute group will be created in\n\t\ta new subdirectory with this name.\n @is_visible:\tOptional: Function to return permissions associated with an\n\t\tattribute of the group. Will be called repeatedly for each\n\t\tnon-binary attribute in the group. Only read/write\n\t\tpermissions as well as SYSFS_PREALLOC are accepted. Must\n\t\treturn 0 if an attribute is not visible. The returned value\n\t\twill replace static permissions defined in struct attribute.\n @is_bin_visible:\n\t\tOptional: Function to return permissions associated with a\n\t\tbinary attribute of the group. Will be called repeatedly\n\t\tfor each binary attribute in the group. Only read/write\n\t\tpermissions as well as SYSFS_PREALLOC are accepted. Must\n\t\treturn 0 if a binary attribute is not visible. The returned\n\t\tvalue will replace static permissions defined in\n\t\tstruct bin_attribute.\n @attrs:\tPointer to NULL terminated list of attributes.\n @bin_attrs:\tPointer to NULL terminated list of binary attributes.\n\t\tEither attrs or bin_attrs or both must be provided."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct attribute_group {
    pub name: *const core::ffi::c_char,
    pub is_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: core::ffi::c_int,
        ) -> umode_t,
    >,
    pub is_bin_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut bin_attribute,
            arg3: core::ffi::c_int,
        ) -> umode_t,
    >,
    pub attrs: *mut *mut attribute,
    pub bin_attrs: *mut *mut bin_attribute,
}
impl Default for attribute_group {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llist_head {
    pub first: *mut llist_node,
}
impl Default for llist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
impl Default for llist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct range {
    pub start: u64_,
    pub end: u64_,
}
pub type pteval_t = core::ffi::c_ulong;
pub type pmdval_t = core::ffi::c_ulong;
pub type pudval_t = core::ffi::c_ulong;
pub type pgdval_t = core::ffi::c_ulong;
pub type pgprotval_t = core::ffi::c_ulong;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pte_t {
    pub pte: pteval_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pmd_t {
    pub pmd: pmdval_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pgprot {
    pub pgprot: pgprotval_t,
}
pub type pgprot_t = pgprot;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pgd_t {
    pub pgd: pgdval_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pud_t {
    pub pud: pudval_t,
}
pub type pgtable_t = *mut page;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct orc_entry {
    pub sp_offset: s16,
    pub bp_offset: s16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl orc_entry {
    #[inline]
    pub fn sp_reg(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sp_reg(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bp_reg(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bp_reg(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn signal(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_signal(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sp_reg: core::ffi::c_uint,
        bp_reg: core::ffi::c_uint,
        type_: core::ffi::c_uint,
        signal: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sp_reg: u32 = unsafe { ::core::mem::transmute(sp_reg) };
            sp_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let bp_reg: u32 = unsafe { ::core::mem::transmute(bp_reg) };
            bp_reg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let signal: u32 = unsafe { ::core::mem::transmute(signal) };
            signal as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint_func {
    pub func: *mut core::ffi::c_void,
    pub data: *mut core::ffi::c_void,
    pub prio: core::ffi::c_int,
}
impl Default for tracepoint_func {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint {
    pub name: *const core::ffi::c_char,
    pub key: static_key,
    pub static_call_key: *mut static_call_key,
    pub static_call_tramp: *mut core::ffi::c_void,
    pub iterator: *mut core::ffi::c_void,
    pub probestub: *mut core::ffi::c_void,
    pub regfunc: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub unregfunc: ::core::option::Option<unsafe extern "C" fn()>,
    pub funcs: *mut tracepoint_func,
}
impl Default for tracepoint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct bpf_raw_event_map {
    pub tp: *mut tracepoint,
    pub bpf_func: *mut core::ffi::c_void,
    pub num_args: u32_,
    pub writable_size: u32_,
}
impl Default for bpf_raw_event_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
}
impl Default for spinlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for spinlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
impl Default for rwlock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_head {
    pub lock: spinlock_t,
    pub head: list_head,
}
impl Default for wait_queue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type wait_queue_head_t = wait_queue_head;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: raw_spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
}
impl Default for mutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount {
    pub sequence: core::ffi::c_uint,
}
pub type seqcount_t = seqcount;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_raw_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_raw_spinlock_t = seqcount_raw_spinlock;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_spinlock_t = seqcount_spinlock;
#[doc = " typedef refcount_t - variant of atomic_t specialized for reference counts\n @refs: atomic_t counter field\n\n The counter saturates at REFCOUNT_SATURATED and will not move once\n there. This avoids wrapping the counter and causing 'spurious'\n use-after-free bugs."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
#[doc = " typedef refcount_t - variant of atomic_t specialized for reference counts\n @refs: atomic_t counter field\n\n The counter saturates at REFCOUNT_SATURATED and will not move once\n there. This avoids wrapping the counter and causing 'spurious'\n use-after-free bugs."]
pub type refcount_t = refcount_struct;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kref {
    pub refcount: refcount_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: core::ffi::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
impl Default for rb_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
impl Default for rb_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
impl Default for rb_root_cached {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lockdep_map_p {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_tree {
    pub __bindgen_anon_1: maple_tree__bindgen_ty_1,
    pub ma_flags: core::ffi::c_uint,
    pub ma_root: *mut core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_tree__bindgen_ty_1 {
    pub ma_lock: spinlock_t,
    pub ma_external_lock: lockdep_map_p,
}
impl Default for maple_tree__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for maple_tree {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rw_semaphore {
    pub count: atomic_long_t,
    pub owner: atomic_long_t,
    pub osq: optimistic_spin_queue,
    pub wait_lock: raw_spinlock_t,
    pub wait_list: list_head,
}
impl Default for rw_semaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swait_queue_head {
    pub lock: raw_spinlock_t,
    pub task_list: list_head,
}
impl Default for swait_queue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct completion {
    pub done: core::ffi::c_uint,
    pub wait: swait_queue_head,
}
impl Default for completion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type time64_t = __s64;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: time64_t,
    pub tv_nsec: core::ffi::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timer_list {
    pub entry: hlist_node,
    pub expires: core::ffi::c_ulong,
    pub function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub flags: u32_,
}
impl Default for timer_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct workqueue_struct {
    _unused: [u8; 0],
}
pub type work_func_t = ::core::option::Option<unsafe extern "C" fn(work: *mut work_struct)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
impl Default for work_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct delayed_work {
    pub work: work_struct,
    pub timer: timer_list,
    pub wq: *mut workqueue_struct,
    pub cpu: core::ffi::c_int,
}
impl Default for delayed_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_segcblist {
    pub head: *mut callback_head,
    pub tails: [*mut *mut callback_head; 4usize],
    pub gp_seq: [core::ffi::c_ulong; 4usize],
    pub len: atomic_long_t,
    pub seglen: [core::ffi::c_long; 4usize],
    pub flags: u8_,
}
impl Default for rcu_segcblist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct srcu_data {
    pub srcu_lock_count: [atomic_long_t; 2usize],
    pub srcu_unlock_count: [atomic_long_t; 2usize],
    pub srcu_nmi_safety: core::ffi::c_int,
    pub __bindgen_padding_0: [u32; 7usize],
    pub lock: spinlock_t,
    pub srcu_cblist: rcu_segcblist,
    pub srcu_gp_seq_needed: core::ffi::c_ulong,
    pub srcu_gp_seq_needed_exp: core::ffi::c_ulong,
    pub srcu_cblist_invoking: bool_,
    pub delay_work: timer_list,
    pub work: work_struct,
    pub srcu_barrier_head: callback_head,
    pub mynode: *mut srcu_node,
    pub grpmask: core::ffi::c_ulong,
    pub cpu: core::ffi::c_int,
    pub ssp: *mut srcu_struct,
}
impl Default for srcu_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_node {
    pub lock: spinlock_t,
    pub srcu_have_cbs: [core::ffi::c_ulong; 4usize],
    pub srcu_data_have_cbs: [core::ffi::c_ulong; 4usize],
    pub srcu_gp_seq_needed_exp: core::ffi::c_ulong,
    pub srcu_parent: *mut srcu_node,
    pub grplo: core::ffi::c_int,
    pub grphi: core::ffi::c_int,
}
impl Default for srcu_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_usage {
    pub node: *mut srcu_node,
    pub level: [*mut srcu_node; 3usize],
    pub srcu_size_state: core::ffi::c_int,
    pub srcu_cb_mutex: mutex,
    pub lock: spinlock_t,
    pub srcu_gp_mutex: mutex,
    pub srcu_gp_seq: core::ffi::c_ulong,
    pub srcu_gp_seq_needed: core::ffi::c_ulong,
    pub srcu_gp_seq_needed_exp: core::ffi::c_ulong,
    pub srcu_gp_start: core::ffi::c_ulong,
    pub srcu_last_gp_end: core::ffi::c_ulong,
    pub srcu_size_jiffies: core::ffi::c_ulong,
    pub srcu_n_lock_retries: core::ffi::c_ulong,
    pub srcu_n_exp_nodelay: core::ffi::c_ulong,
    pub sda_is_static: bool_,
    pub srcu_barrier_seq: core::ffi::c_ulong,
    pub srcu_barrier_mutex: mutex,
    pub srcu_barrier_completion: completion,
    pub srcu_barrier_cpu_cnt: atomic_t,
    pub reschedule_jiffies: core::ffi::c_ulong,
    pub reschedule_count: core::ffi::c_ulong,
    pub work: delayed_work,
    pub srcu_ssp: *mut srcu_struct,
}
impl Default for srcu_usage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_struct {
    pub srcu_idx: core::ffi::c_uint,
    pub sda: *mut srcu_data,
    pub dep_map: lockdep_map,
    pub srcu_sup: *mut srcu_usage,
}
impl Default for srcu_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xol_area {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobes_state {
    pub xol_area: *mut xol_area,
}
impl Default for uprobes_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_counter {
    pub lock: raw_spinlock_t,
    pub count: s64,
    pub list: list_head,
    pub counters: *mut s32,
}
impl Default for percpu_counter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_context_t {
    pub ctx_id: u64_,
    pub tlb_gen: atomic64_t,
    pub ldt_usr_sem: rw_semaphore,
    pub ldt: *mut ldt_struct,
    pub flags: core::ffi::c_ulong,
    pub lam_cr3_mask: core::ffi::c_ulong,
    pub untag_mask: u64_,
    pub lock: mutex,
    pub vdso: *mut core::ffi::c_void,
    pub vdso_image: *const vdso_image,
    pub perf_rdpmc_allowed: atomic_t,
    pub pkey_allocation_map: u16_,
    pub execute_only_pkey: s16,
}
impl Default for mm_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct page {
    pub flags: core::ffi::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_2,
    pub _refcount: atomic_t,
    pub memcg_data: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: page__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: page__bindgen_ty_1__bindgen_ty_4,
    #[doc = " @rcu_head: You can use this to free a page by RCU."]
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    #[doc = " @private: Mapping-private opaque data.\n Usually used for buffer_heads if PagePrivate.\n Used for swp_entry_t if PageSwapCache.\n Indicates order in the buddy system if PageBuddy."]
    pub private: core::ffi::c_ulong,
}
#[doc = " @lru: Pageout list, eg. active_list protected by\n lruvec->lru_lock.  Sometimes used as a generic list\n by the page owner."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub buddy_list: list_head,
    pub pcp_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut core::ffi::c_void,
    pub mlock_count: core::ffi::c_uint,
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub index: core::ffi::c_ulong,
    pub share: core::ffi::c_ulong,
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " @pp_magic: magic value to avoid recycling non\n page_pool allocated pages."]
    pub pp_magic: core::ffi::c_ulong,
    pub pp: *mut page_pool,
    pub _pp_mapping_pad: core::ffi::c_ulong,
    pub dma_addr: core::ffi::c_ulong,
    pub pp_ref_count: atomic_long_t,
}
impl Default for page__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3 {
    pub compound_head: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_4 {
    #[doc = " @pgmap: Points to the hosting device page map."]
    pub pgmap: *mut dev_pagemap,
    pub zone_device_data: *mut core::ffi::c_void,
}
impl Default for page__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_2 {
    pub _mapcount: atomic_t,
    pub page_type: core::ffi::c_uint,
}
impl Default for page__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct swp_entry_t {
    pub val: core::ffi::c_ulong,
}
#[doc = " struct folio - Represents a contiguous set of bytes.\n @flags: Identical to the page flags.\n @lru: Least Recently Used list; tracks how recently this folio was used.\n @mlock_count: Number of times this folio has been pinned by mlock().\n @mapping: The file this page belongs to, or refers to the anon_vma for\n    anonymous memory.\n @index: Offset within the file, in units of pages.  For anonymous memory,\n    this is the index from the beginning of the mmap.\n @private: Filesystem per-folio data (see folio_attach_private()).\n @swap: Used for swp_entry_t if folio_test_swapcache().\n @_mapcount: Do not access this member directly.  Use folio_mapcount() to\n    find out how many times this folio is mapped by userspace.\n @_refcount: Do not access this member directly.  Use folio_ref_count()\n    to find how many references there are to this folio.\n @memcg_data: Memory Control Group data.\n @virtual: Virtual address in the kernel direct map.\n @_last_cpupid: IDs of last CPU and last process that accessed the folio.\n @_entire_mapcount: Do not use directly, call folio_entire_mapcount().\n @_nr_pages_mapped: Do not use directly, call folio_mapcount().\n @_pincount: Do not use directly, call folio_maybe_dma_pinned().\n @_folio_nr_pages: Do not use directly, call folio_nr_pages().\n @_hugetlb_subpool: Do not use directly, use accessor in hugetlb.h.\n @_hugetlb_cgroup: Do not use directly, use accessor in hugetlb_cgroup.h.\n @_hugetlb_cgroup_rsvd: Do not use directly, use accessor in hugetlb_cgroup.h.\n @_hugetlb_hwpoison: Do not use directly, call raw_hwp_list_head().\n @_deferred_list: Folios to be split under memory pressure.\n\n A folio is a physically, virtually and logically contiguous set\n of bytes.  It is a power-of-two in size, and it is aligned to that\n same power-of-two.  It is at least as large as %PAGE_SIZE.  If it is\n in the page cache, it is at a file offset which is a multiple of that\n power-of-two.  It may be mapped into userspace at an address which is\n at an arbitrary page offset, but its kernel virtual address is aligned\n to its size."]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct folio {
    pub __bindgen_anon_1: folio__bindgen_ty_1,
    pub __bindgen_anon_2: folio__bindgen_ty_2,
    pub __bindgen_anon_3: folio__bindgen_ty_3,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1 {
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1,
    pub page: page,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1 {
    pub flags: core::ffi::c_ulong,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub index: core::ffi::c_ulong,
    pub __bindgen_anon_2: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub _mapcount: atomic_t,
    pub _refcount: atomic_t,
    pub memcg_data: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut core::ffi::c_void,
    pub mlock_count: core::ffi::c_uint,
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub private: *mut core::ffi::c_void,
    pub swap: swp_entry_t,
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_2 {
    pub __bindgen_anon_1: folio__bindgen_ty_2__bindgen_ty_1,
    pub __page_1: page,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct folio__bindgen_ty_2__bindgen_ty_1 {
    pub _flags_1: core::ffi::c_ulong,
    pub _head_1: core::ffi::c_ulong,
    pub _folio_avail: core::ffi::c_ulong,
    pub _entire_mapcount: atomic_t,
    pub _nr_pages_mapped: atomic_t,
    pub _pincount: atomic_t,
    pub _folio_nr_pages: core::ffi::c_uint,
}
impl Default for folio__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_3 {
    pub __bindgen_anon_1: folio__bindgen_ty_3__bindgen_ty_1,
    pub __bindgen_anon_2: folio__bindgen_ty_3__bindgen_ty_2,
    pub __page_2: page,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_3__bindgen_ty_1 {
    pub _flags_2: core::ffi::c_ulong,
    pub _head_2: core::ffi::c_ulong,
    pub _hugetlb_subpool: *mut core::ffi::c_void,
    pub _hugetlb_cgroup: *mut core::ffi::c_void,
    pub _hugetlb_cgroup_rsvd: *mut core::ffi::c_void,
    pub _hugetlb_hwpoison: *mut core::ffi::c_void,
}
impl Default for folio__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_3__bindgen_ty_2 {
    pub _flags_2a: core::ffi::c_ulong,
    pub _head_2a: core::ffi::c_ulong,
    pub _deferred_list: list_head,
}
impl Default for folio__bindgen_ty_3__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vm_flags_t = core::ffi::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_userfaultfd_ctx {
    pub ctx: *mut userfaultfd_ctx,
}
impl Default for vm_userfaultfd_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct anon_vma_name {
    pub kref: kref,
    pub name: __IncompleteArrayField<core::ffi::c_char>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vma_lock {
    pub lock: rw_semaphore,
}
impl Default for vma_lock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vma_numab_state {
    pub next_scan: core::ffi::c_ulong,
    pub pids_active_reset: core::ffi::c_ulong,
    pub pids_active: [core::ffi::c_ulong; 2usize],
    pub start_scan_seq: core::ffi::c_int,
    pub prev_scan_seq: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_area_struct {
    pub __bindgen_anon_1: vm_area_struct__bindgen_ty_1,
    pub vm_mm: *mut mm_struct,
    pub vm_page_prot: pgprot_t,
    pub __bindgen_anon_2: vm_area_struct__bindgen_ty_2,
    pub vm_lock_seq: core::ffi::c_int,
    pub vm_lock: *mut vma_lock,
    pub detached: bool_,
    pub shared: vm_area_struct__bindgen_ty_3,
    pub anon_vma_chain: list_head,
    pub anon_vma: *mut anon_vma,
    pub vm_ops: *const vm_operations_struct,
    pub vm_pgoff: core::ffi::c_ulong,
    pub vm_file: *mut file,
    pub vm_private_data: *mut core::ffi::c_void,
    pub anon_name: *mut anon_vma_name,
    pub swap_readahead_info: atomic_long_t,
    pub vm_policy: *mut mempolicy,
    pub numab_state: *mut vma_numab_state,
    pub vm_userfaultfd_ctx: vm_userfaultfd_ctx,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_area_struct__bindgen_ty_1 {
    pub __bindgen_anon_1: vm_area_struct__bindgen_ty_1__bindgen_ty_1,
    pub vm_rcu: callback_head,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_1__bindgen_ty_1 {
    pub vm_start: core::ffi::c_ulong,
    pub vm_end: core::ffi::c_ulong,
}
impl Default for vm_area_struct__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_area_struct__bindgen_ty_2 {
    pub vm_flags: vm_flags_t,
    pub __vm_flags: vm_flags_t,
}
impl Default for vm_area_struct__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_3 {
    pub rb: rb_node,
    pub rb_subtree_last: core::ffi::c_ulong,
}
impl Default for vm_area_struct__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vm_area_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mm_cid {
    pub time: u64_,
    pub cid: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_mm_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
pub struct mm_struct {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1,
    pub cpu_bitmap: __IncompleteArrayField<core::ffi::c_ulong>,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1 {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1__bindgen_ty_1,
    pub mm_mt: maple_tree,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            filp: *mut file,
            addr: core::ffi::c_ulong,
            len: core::ffi::c_ulong,
            pgoff: core::ffi::c_ulong,
            flags: core::ffi::c_ulong,
        ) -> core::ffi::c_ulong,
    >,
    pub mmap_base: core::ffi::c_ulong,
    pub mmap_legacy_base: core::ffi::c_ulong,
    pub mmap_compat_base: core::ffi::c_ulong,
    pub mmap_compat_legacy_base: core::ffi::c_ulong,
    pub task_size: core::ffi::c_ulong,
    pub pgd: *mut pgd_t,
    #[doc = " @membarrier_state: Flags controlling membarrier behavior.\n\n This field is close to @pgd to hopefully fit in the same\n cache-line, which needs to be touched by switch_mm()."]
    pub membarrier_state: atomic_t,
    #[doc = " @mm_users: The number of users including userspace.\n\n Use mmget()/mmget_not_zero()/mmput() to modify. When this\n drops to 0 (i.e. when the task exits and there are no other\n temporary reference holders), we also release a reference on\n @mm_count (which may then free the &struct mm_struct if\n @mm_count also drops to 0)."]
    pub mm_users: atomic_t,
    #[doc = " @pcpu_cid: Per-cpu current cid.\n\n Keep track of the currently allocated mm_cid for each cpu.\n The per-cpu mm_cid values are serialized by their respective\n runqueue locks."]
    pub pcpu_cid: *mut mm_cid,
    pub mm_cid_next_scan: core::ffi::c_ulong,
    pub pgtables_bytes: atomic_long_t,
    pub map_count: core::ffi::c_int,
    pub page_table_lock: spinlock_t,
    pub mmap_lock: rw_semaphore,
    pub mmlist: list_head,
    pub mm_lock_seq: core::ffi::c_int,
    pub hiwater_rss: core::ffi::c_ulong,
    pub hiwater_vm: core::ffi::c_ulong,
    pub total_vm: core::ffi::c_ulong,
    pub locked_vm: core::ffi::c_ulong,
    pub pinned_vm: atomic64_t,
    pub data_vm: core::ffi::c_ulong,
    pub exec_vm: core::ffi::c_ulong,
    pub stack_vm: core::ffi::c_ulong,
    pub def_flags: core::ffi::c_ulong,
    #[doc = " @write_protect_seq: Locked when any thread is write\n protecting pages mapped by this mm to enforce a later COW,\n for instance during page table copying for fork()."]
    pub write_protect_seq: seqcount_t,
    pub arg_lock: spinlock_t,
    pub start_code: core::ffi::c_ulong,
    pub end_code: core::ffi::c_ulong,
    pub start_data: core::ffi::c_ulong,
    pub end_data: core::ffi::c_ulong,
    pub start_brk: core::ffi::c_ulong,
    pub brk: core::ffi::c_ulong,
    pub start_stack: core::ffi::c_ulong,
    pub arg_start: core::ffi::c_ulong,
    pub arg_end: core::ffi::c_ulong,
    pub env_start: core::ffi::c_ulong,
    pub env_end: core::ffi::c_ulong,
    pub saved_auxv: [core::ffi::c_ulong; 52usize],
    pub rss_stat: [percpu_counter; 4usize],
    pub binfmt: *mut linux_binfmt,
    pub context: mm_context_t,
    pub flags: core::ffi::c_ulong,
    pub ioctx_lock: spinlock_t,
    pub ioctx_table: *mut kioctx_table,
    pub owner: *mut task_struct,
    pub user_ns: *mut user_namespace,
    pub exe_file: *mut file,
    pub notifier_subscriptions: *mut mmu_notifier_subscriptions,
    pub numa_next_scan: core::ffi::c_ulong,
    pub numa_scan_offset: core::ffi::c_ulong,
    pub numa_scan_seq: core::ffi::c_int,
    pub tlb_flush_pending: atomic_t,
    pub tlb_flush_batched: atomic_t,
    pub uprobes_state: uprobes_state,
    pub hugetlb_usage: atomic_long_t,
    pub async_put_work: work_struct,
    pub iommu_mm: *mut iommu_mm_data,
    pub ksm_merging_pages: core::ffi::c_ulong,
    pub ksm_rmap_items: core::ffi::c_ulong,
    pub ksm_zero_pages: core::ffi::c_ulong,
    pub lru_gen: mm_struct__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " @mm_count: The number of references to &struct\n mm_struct (@mm_users count as 1).\n\n Use mmgrab()/mmdrop() to modify. When this drops to\n 0, the &struct mm_struct is freed."]
    pub mm_count: atomic_t,
}
impl Default for mm_struct__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1__bindgen_ty_2 {
    pub list: list_head,
    pub bitmap: core::ffi::c_ulong,
    pub memcg: *mut mem_cgroup,
}
impl Default for mm_struct__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mm_struct__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mm_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " typedef vm_fault_t - Return type for page fault handlers.\n\n Page fault handlers return a bitmask of %VM_FAULT values."]
pub type vm_fault_t = core::ffi::c_uint;
#[repr(u32)]
#[doc = " enum fault_flag - Fault flag definitions.\n @FAULT_FLAG_WRITE: Fault was a write fault.\n @FAULT_FLAG_MKWRITE: Fault was mkwrite of existing PTE.\n @FAULT_FLAG_ALLOW_RETRY: Allow to retry the fault if blocked.\n @FAULT_FLAG_RETRY_NOWAIT: Don't drop mmap_lock and wait when retrying.\n @FAULT_FLAG_KILLABLE: The fault task is in SIGKILL killable region.\n @FAULT_FLAG_TRIED: The fault has been tried once.\n @FAULT_FLAG_USER: The fault originated in userspace.\n @FAULT_FLAG_REMOTE: The fault is not for current task/mm.\n @FAULT_FLAG_INSTRUCTION: The fault was during an instruction fetch.\n @FAULT_FLAG_INTERRUPTIBLE: The fault can be interrupted by non-fatal signals.\n @FAULT_FLAG_UNSHARE: The fault is an unsharing request to break COW in a\n                      COW mapping, making sure that an exclusive anon page is\n                      mapped after the fault.\n @FAULT_FLAG_ORIG_PTE_VALID: whether the fault has vmf->orig_pte cached.\n                        We should only access orig_pte if this flag set.\n @FAULT_FLAG_VMA_LOCK: The fault is handled under VMA lock.\n\n About @FAULT_FLAG_ALLOW_RETRY and @FAULT_FLAG_TRIED: we can specify\n whether we would allow page faults to retry by specifying these two\n fault flags correctly.  Currently there can be three legal combinations:\n\n (a) ALLOW_RETRY and !TRIED:  this means the page fault allows retry, and\n                              this is the first try\n\n (b) ALLOW_RETRY and TRIED:   this means the page fault allows retry, and\n                              we've already tried at least once\n\n (c) !ALLOW_RETRY and !TRIED: this means the page fault does not allow retry\n\n The unlisted combination (!ALLOW_RETRY && TRIED) is illegal and should never\n be used.  Note that page faults can be allowed to retry for multiple times,\n in which case we'll have an initial fault with flags (a) then later on\n continuous faults with flags (b).  We should always try to detect pending\n signals before a retry to make sure the continuous page faults can still be\n interrupted if necessary.\n\n The combination FAULT_FLAG_WRITE|FAULT_FLAG_UNSHARE is illegal.\n FAULT_FLAG_UNSHARE is ignored and treated like an ordinary read fault when\n applied to mappings that are not COW mappings."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum fault_flag {
    FAULT_FLAG_WRITE = 1,
    FAULT_FLAG_MKWRITE = 2,
    FAULT_FLAG_ALLOW_RETRY = 4,
    FAULT_FLAG_RETRY_NOWAIT = 8,
    FAULT_FLAG_KILLABLE = 16,
    FAULT_FLAG_TRIED = 32,
    FAULT_FLAG_USER = 64,
    FAULT_FLAG_REMOTE = 128,
    FAULT_FLAG_INSTRUCTION = 256,
    FAULT_FLAG_INTERRUPTIBLE = 512,
    FAULT_FLAG_UNSHARE = 1024,
    FAULT_FLAG_ORIG_PTE_VALID = 2048,
    FAULT_FLAG_VMA_LOCK = 4096,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_domain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mempolicy {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_TGID = 1,
    PIDTYPE_PGID = 2,
    PIDTYPE_SID = 3,
    PIDTYPE_MAX = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pid_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
impl Default for timerqueue_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timerqueue_head {
    pub rb_root: rb_root_cached,
}
impl Default for timerqueue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1,
}
#[doc = " struct hrtimer - the basic hrtimer structure\n @node:\ttimerqueue node, which also manages node.expires,\n\t\tthe absolute expiry time in the hrtimers internal\n\t\trepresentation. The time is related to the clock on\n\t\twhich the timer is based. Is setup by adding\n\t\tslack to the _softexpires value. For non range timers\n\t\tidentical to _softexpires.\n @_softexpires: the absolute earliest expiry time of the hrtimer.\n\t\tThe time which was given as expiry time when the timer\n\t\twas armed.\n @function:\ttimer expiry callback function\n @base:\tpointer to the timer base (per cpu and per clock)\n @state:\tstate information (See bit values above)\n @is_rel:\tSet if the timer was armed relative\n @is_soft:\tSet if hrtimer will be expired in soft interrupt context.\n @is_hard:\tSet if hrtimer will be expired in hard interrupt context\n\t\teven on RT.\n\n The hrtimer structure must be initialized by hrtimer_init()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8_,
    pub is_rel: u8_,
    pub is_soft: u8_,
    pub is_hard: u8_,
}
impl Default for hrtimer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ucounts {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kgid_t {
    pub val: gid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pipe_inode_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
pub struct task_struct {
    pub _bindgen_opaque_blob: [u8; 11584usize],
}
impl Default for task_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xarray {
    pub xa_lock: spinlock_t,
    pub xa_flags: gfp_t,
    pub xa_head: *mut core::ffi::c_void,
}
impl Default for xarray {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type percpu_ref_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut percpu_ref)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_ref_data {
    pub count: atomic_long_t,
    pub release: percpu_ref_func_t,
    pub confirm_switch: percpu_ref_func_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rcu: callback_head,
    pub ref_: *mut percpu_ref,
}
impl Default for percpu_ref_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl percpu_ref_data {
    #[inline]
    pub fn force_atomic(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_atomic(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_reinit(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_reinit(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_atomic: bool_,
        allow_reinit: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_atomic: u8 = unsafe { ::core::mem::transmute(force_atomic) };
            force_atomic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let allow_reinit: u8 = unsafe { ::core::mem::transmute(allow_reinit) };
            allow_reinit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_ref {
    pub percpu_count_ptr: core::ffi::c_ulong,
    pub data: *mut percpu_ref_data,
}
impl Default for percpu_ref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_local_percpu {
    pub events: percpu_counter,
    pub period: core::ffi::c_uint,
    pub lock: raw_spinlock_t,
}
impl Default for fprop_local_percpu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum wb_reason {
    WB_REASON_BACKGROUND = 0,
    WB_REASON_VMSCAN = 1,
    WB_REASON_SYNC = 2,
    WB_REASON_PERIODIC = 3,
    WB_REASON_LAPTOP_TIMER = 4,
    WB_REASON_FS_FREE_SPACE = 5,
    WB_REASON_FORKER_THREAD = 6,
    WB_REASON_FOREIGN_FLUSH = 7,
    WB_REASON_MAX = 8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bdi_writeback {
    pub bdi: *mut backing_dev_info,
    pub state: core::ffi::c_ulong,
    pub last_old_flush: core::ffi::c_ulong,
    pub b_dirty: list_head,
    pub b_io: list_head,
    pub b_more_io: list_head,
    pub b_dirty_time: list_head,
    pub list_lock: spinlock_t,
    pub writeback_inodes: atomic_t,
    pub stat: [percpu_counter; 4usize],
    pub bw_time_stamp: core::ffi::c_ulong,
    pub dirtied_stamp: core::ffi::c_ulong,
    pub written_stamp: core::ffi::c_ulong,
    pub write_bandwidth: core::ffi::c_ulong,
    pub avg_write_bandwidth: core::ffi::c_ulong,
    pub dirty_ratelimit: core::ffi::c_ulong,
    pub balanced_dirty_ratelimit: core::ffi::c_ulong,
    pub completions: fprop_local_percpu,
    pub dirty_exceeded: core::ffi::c_int,
    pub start_all_reason: wb_reason,
    pub work_lock: spinlock_t,
    pub work_list: list_head,
    pub dwork: delayed_work,
    pub bw_dwork: delayed_work,
    pub dirty_sleep: core::ffi::c_ulong,
    pub bdi_node: list_head,
    pub refcnt: percpu_ref,
    pub memcg_completions: fprop_local_percpu,
    pub memcg_css: *mut cgroup_subsys_state,
    pub blkcg_css: *mut cgroup_subsys_state,
    pub memcg_node: list_head,
    pub blkcg_node: list_head,
    pub b_attached: list_head,
    pub offline_node: list_head,
    pub __bindgen_anon_1: bdi_writeback__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bdi_writeback__bindgen_ty_1 {
    pub release_work: work_struct,
    pub rcu: callback_head,
}
impl Default for bdi_writeback__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bdi_writeback {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct backing_dev_info {
    pub id: u64_,
    pub rb_node: rb_node,
    pub bdi_list: list_head,
    pub ra_pages: core::ffi::c_ulong,
    pub io_pages: core::ffi::c_ulong,
    pub refcnt: kref,
    pub capabilities: core::ffi::c_uint,
    pub min_ratio: core::ffi::c_uint,
    pub max_ratio: core::ffi::c_uint,
    pub max_prop_frac: core::ffi::c_uint,
    pub tot_write_bandwidth: atomic_long_t,
    pub wb: bdi_writeback,
    pub wb_list: list_head,
    pub cgwb_tree: xarray,
    pub cgwb_release_mutex: mutex,
    pub wb_switch_rwsem: rw_semaphore,
    pub wb_waitq: wait_queue_head_t,
    pub dev: *mut device,
    pub dev_name: [core::ffi::c_char; 64usize],
    pub owner: *mut device,
    pub laptop_mode_wb_timer: timer_list,
    pub debug_dir: *mut dentry,
}
impl Default for backing_dev_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmem_cache {
    _unused: [u8; 0],
}
pub type mempool_alloc_t = ::core::option::Option<
    unsafe extern "C" fn(
        gfp_mask: gfp_t,
        pool_data: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void,
>;
pub type mempool_free_t = ::core::option::Option<
    unsafe extern "C" fn(element: *mut core::ffi::c_void, pool_data: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mempool_s {
    pub lock: spinlock_t,
    pub min_nr: core::ffi::c_int,
    pub curr_nr: core::ffi::c_int,
    pub elements: *mut *mut core::ffi::c_void,
    pub pool_data: *mut core::ffi::c_void,
    pub alloc: mempool_alloc_t,
    pub free: mempool_free_t,
    pub wait: wait_queue_head_t,
}
impl Default for mempool_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mempool_t = mempool_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_bl_head {
    pub first: *mut hlist_bl_node,
}
impl Default for hlist_bl_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_bl_node {
    pub next: *mut hlist_bl_node,
    pub pprev: *mut *mut hlist_bl_node,
}
impl Default for hlist_bl_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref {
    pub __bindgen_anon_1: lockref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lockref__bindgen_ty_1 {
    pub lock_count: __u64,
    pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub count: core::ffi::c_int,
}
impl Default for lockref__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for lockref__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for lockref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qstr {
    pub __bindgen_anon_1: qstr__bindgen_ty_1,
    pub name: *const core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qstr__bindgen_ty_1 {
    pub __bindgen_anon_1: qstr__bindgen_ty_1__bindgen_ty_1,
    pub hash_len: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qstr__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u32_,
    pub len: u32_,
}
impl Default for qstr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qstr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dentry {
    pub d_flags: core::ffi::c_uint,
    pub d_seq: seqcount_spinlock_t,
    pub d_hash: hlist_bl_node,
    pub d_parent: *mut dentry,
    pub d_name: qstr,
    pub d_inode: *mut inode,
    pub d_iname: [core::ffi::c_uchar; 40usize],
    pub d_lockref: lockref,
    pub d_op: *const dentry_operations,
    pub d_sb: *mut super_block,
    pub d_time: core::ffi::c_ulong,
    pub d_fsdata: *mut core::ffi::c_void,
    pub __bindgen_anon_1: dentry__bindgen_ty_1,
    pub d_sib: hlist_node,
    pub d_children: hlist_head,
    pub d_u: dentry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_1 {
    pub d_lru: list_head,
    pub d_wait: *mut wait_queue_head_t,
}
impl Default for dentry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_2 {
    pub d_alias: hlist_node,
    pub d_in_lookup_hash: hlist_bl_node,
    pub d_rcu: callback_head,
}
impl Default for dentry__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for dentry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct dentry_operations {
    pub d_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub d_weak_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub d_hash: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> core::ffi::c_int,
    >,
    pub d_compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const dentry,
            arg2: core::ffi::c_uint,
            arg3: *const core::ffi::c_char,
            arg4: *const qstr,
        ) -> core::ffi::c_int,
    >,
    pub d_delete:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> core::ffi::c_int>,
    pub d_init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> core::ffi::c_int>,
    pub d_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_prune: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_iput: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>,
    pub d_dname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut core::ffi::c_char,
            arg3: core::ffi::c_int,
        ) -> *mut core::ffi::c_char,
    >,
    pub d_automount: ::core::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>,
    pub d_manage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> core::ffi::c_int,
    >,
    pub d_real: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *const inode) -> *mut dentry,
    >,
}
impl Default for dentry_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct path {
    pub mnt: *mut vfsmount,
    pub dentry: *mut dentry,
}
impl Default for path {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kstat {
    pub result_mask: u32_,
    pub mode: umode_t,
    pub nlink: core::ffi::c_uint,
    pub blksize: u32,
    pub attributes: u64_,
    pub attributes_mask: u64_,
    pub ino: u64_,
    pub dev: dev_t,
    pub rdev: dev_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub atime: timespec64,
    pub mtime: timespec64,
    pub ctime: timespec64,
    pub btime: timespec64,
    pub blocks: u64_,
    pub mnt_id: u64_,
    pub dio_mem_align: u32_,
    pub dio_offset_align: u32_,
    pub change_cookie: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shrink_control {
    pub gfp_mask: gfp_t,
    pub nid: core::ffi::c_int,
    pub nr_to_scan: core::ffi::c_ulong,
    pub nr_scanned: core::ffi::c_ulong,
    pub memcg: *mut mem_cgroup,
}
impl Default for shrink_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shrinker {
    pub count_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> core::ffi::c_ulong,
    >,
    pub scan_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> core::ffi::c_ulong,
    >,
    pub batch: core::ffi::c_long,
    pub seeks: core::ffi::c_int,
    pub flags: core::ffi::c_uint,
    pub refcount: refcount_t,
    pub done: completion,
    pub rcu: callback_head,
    pub private_data: *mut core::ffi::c_void,
    pub list: list_head,
    pub id: core::ffi::c_int,
    pub debugfs_id: core::ffi::c_int,
    pub name: *const core::ffi::c_char,
    pub debugfs_entry: *mut dentry,
    pub nr_deferred: *mut atomic_long_t,
}
impl Default for shrinker {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_lru_one {
    pub list: list_head,
    pub nr_items: core::ffi::c_long,
}
impl Default for list_lru_one {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct list_lru_node {
    pub lock: spinlock_t,
    pub lru: list_lru_one,
    pub nr_items: core::ffi::c_long,
}
impl Default for list_lru_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_lru {
    pub node: *mut list_lru_node,
    pub list: list_head,
    pub shrinker_id: core::ffi::c_int,
    pub memcg_aware: bool_,
    pub xa: xarray,
}
impl Default for list_lru {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct upid {
    pub nr: core::ffi::c_int,
    pub ns: *mut pid_namespace,
}
impl Default for upid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct pid {
    pub count: refcount_t,
    pub level: core::ffi::c_uint,
    pub lock: spinlock_t,
    pub tasks: [hlist_head; 4usize],
    pub inodes: hlist_head,
    pub wait_pidfd: wait_queue_head_t,
    pub rcu: callback_head,
    pub numbers: __IncompleteArrayField<upid>,
}
impl Default for pid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_cap_t {
    pub val: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mnt_idmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct semaphore {
    pub lock: raw_spinlock_t,
    pub count: core::ffi::c_uint,
    pub wait_list: list_head,
}
impl Default for semaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2,
    MIGRATE_SYNC_NO_COPY = 3,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct exception_table_entry {
    pub insn: core::ffi::c_int,
    pub fixup: core::ffi::c_int,
    pub data: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_notifier_subscriptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct assoc_array {
    pub root: *mut assoc_array_ptr,
    pub nr_leaves_on_tree: core::ffi::c_ulong,
}
impl Default for assoc_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type key_serial_t = i32;
pub type key_perm_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_tag {
    pub rcu: callback_head,
    pub usage: refcount_t,
    pub removed: bool_,
}
impl Default for key_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_index_key {
    pub hash: core::ffi::c_ulong,
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *const core::ffi::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union keyring_index_key__bindgen_ty_1 {
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1__bindgen_ty_1,
    pub x: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct keyring_index_key__bindgen_ty_1__bindgen_ty_1 {
    pub desc_len: u16_,
    pub desc: [core::ffi::c_char; 6usize],
}
impl Default for keyring_index_key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for keyring_index_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key_payload {
    pub rcu_data0: *mut core::ffi::c_void,
    pub data: [*mut core::ffi::c_void; 4usize],
}
impl Default for key_payload {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type key_restrict_link_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        dest_keyring: *mut key,
        type_: *const key_type,
        payload: *const key_payload,
        restriction_key: *mut key,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_restriction {
    pub check: key_restrict_link_func_t,
    pub key: *mut key,
    pub keytype: *mut key_type,
}
impl Default for key_restriction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key {
    pub usage: refcount_t,
    pub serial: key_serial_t,
    pub __bindgen_anon_1: key__bindgen_ty_1,
    pub watchers: *mut watch_list,
    pub sem: rw_semaphore,
    pub user: *mut key_user,
    pub security: *mut core::ffi::c_void,
    pub __bindgen_anon_2: key__bindgen_ty_2,
    pub last_used_at: time64_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub perm: key_perm_t,
    pub quotalen: core::ffi::c_ushort,
    pub datalen: core::ffi::c_ushort,
    pub state: core::ffi::c_short,
    pub flags: core::ffi::c_ulong,
    pub __bindgen_anon_3: key__bindgen_ty_3,
    pub __bindgen_anon_4: key__bindgen_ty_4,
    pub restrict_link: *mut key_restriction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_1 {
    pub graveyard_link: list_head,
    pub serial_node: rb_node,
}
impl Default for key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_2 {
    pub expiry: time64_t,
    pub revoked_at: time64_t,
}
impl Default for key__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_3 {
    pub index_key: keyring_index_key,
    pub __bindgen_anon_1: key__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key__bindgen_ty_3__bindgen_ty_1 {
    pub hash: core::ffi::c_ulong,
    pub len_desc: core::ffi::c_ulong,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *mut core::ffi::c_char,
}
impl Default for key__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for key__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_4 {
    pub payload: key_payload,
    pub __bindgen_anon_1: key__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key__bindgen_ty_4__bindgen_ty_1 {
    pub name_link: list_head,
    pub keys: assoc_array,
}
impl Default for key__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for key__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_struct {
    pub __count: refcount_t,
    pub epoll_watches: percpu_counter,
    pub unix_inflight: core::ffi::c_ulong,
    pub pipe_bufs: atomic_long_t,
    pub uidhash_node: hlist_node,
    pub uid: kuid_t,
    pub locked_vm: atomic_long_t,
    pub nr_watches: atomic_t,
    pub ratelimit: ratelimit_state,
}
impl Default for user_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct group_info {
    pub usage: refcount_t,
    pub ngroups: core::ffi::c_int,
    pub gid: __IncompleteArrayField<kgid_t>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cred {
    pub usage: atomic_long_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub suid: kuid_t,
    pub sgid: kgid_t,
    pub euid: kuid_t,
    pub egid: kgid_t,
    pub fsuid: kuid_t,
    pub fsgid: kgid_t,
    pub securebits: core::ffi::c_uint,
    pub cap_inheritable: kernel_cap_t,
    pub cap_permitted: kernel_cap_t,
    pub cap_effective: kernel_cap_t,
    pub cap_bset: kernel_cap_t,
    pub cap_ambient: kernel_cap_t,
    pub jit_keyring: core::ffi::c_uchar,
    pub session_keyring: *mut key,
    pub process_keyring: *mut key,
    pub thread_keyring: *mut key,
    pub request_key_auth: *mut key,
    pub security: *mut core::ffi::c_void,
    pub user: *mut user_struct,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub group_info: *mut group_info,
    pub __bindgen_anon_1: cred__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cred__bindgen_ty_1 {
    pub non_rcu: core::ffi::c_int,
    pub rcu: callback_head,
}
impl Default for cred__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cred {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct hrtimer_clock_base - the timer base for a specific clock\n @cpu_base:\t\tper cpu clock base\n @index:\t\tclock type index for per_cpu support when moving a\n\t\t\ttimer to a base on another cpu.\n @clockid:\t\tclock id for per_cpu support\n @seq:\t\tseqcount around __run_hrtimer\n @running:\t\tpointer to the currently running hrtimer\n @active:\t\tred black tree root node for the active timers\n @get_time:\t\tfunction to retrieve the current time of the clock\n @offset:\t\toffset of this clock to the monotonic base"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: core::ffi::c_uint,
    pub clockid: clockid_t,
    pub seq: seqcount_raw_spinlock_t,
    pub running: *mut hrtimer,
    pub active: timerqueue_head,
    pub get_time: ::core::option::Option<unsafe extern "C" fn() -> ktime_t>,
    pub offset: ktime_t,
}
impl Default for hrtimer_clock_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct hrtimer_cpu_base - the per cpu clock bases\n @lock:\t\tlock protecting the base and associated clock bases\n\t\t\tand timers\n @cpu:\t\tcpu number\n @active_bases:\tBitfield to mark bases with active timers\n @clock_was_set_seq:\tSequence counter of clock was set events\n @hres_active:\tState of high resolution mode\n @in_hrtirq:\t\thrtimer_interrupt() is currently executing\n @hang_detected:\tThe last hrtimer interrupt detected a hang\n @softirq_activated:\tdisplays, if the softirq is raised - update of softirq\n\t\t\trelated settings is not required then.\n @nr_events:\t\tTotal number of hrtimer interrupt events\n @nr_retries:\t\tTotal number of hrtimer interrupt retries\n @nr_hangs:\t\tTotal number of hrtimer interrupt hangs\n @max_hang_time:\tMaximum time spent in hrtimer_interrupt\n @softirq_expiry_lock: Lock which is taken while softirq based hrtimer are\n\t\t\t expired\n @timer_waiters:\tA hrtimer_cancel() invocation waits for the timer\n\t\t\tcallback to finish.\n @expires_next:\tabsolute time of the next event, is required for remote\n\t\t\thrtimer enqueue; it is the total first expiry time (hard\n\t\t\tand soft hrtimer are taken into account)\n @next_timer:\t\tPointer to the first expiring timer\n @softirq_expires_next: Time to check, if soft queues needs also to be expired\n @softirq_next_timer: Pointer to the first expiring softirq based timer\n @clock_base:\t\tarray of clock bases for this cpu\n\n Note: next_timer is just an optimization for __remove_hrtimer().\n\t Do not dereference the pointer because it is not reliable on\n\t cross cpu removals."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub cpu: core::ffi::c_uint,
    pub active_bases: core::ffi::c_uint,
    pub clock_was_set_seq: core::ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub nr_events: core::ffi::c_uint,
    pub nr_retries: core::ffi::c_ushort,
    pub nr_hangs: core::ffi::c_ushort,
    pub max_hang_time: core::ffi::c_uint,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub softirq_expires_next: ktime_t,
    pub softirq_next_timer: *mut hrtimer,
    pub clock_base: [hrtimer_clock_base; 8usize],
}
impl Default for hrtimer_cpu_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn hres_active(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_hrtirq(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn softirq_activated(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_softirq_activated(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hres_active: core::ffi::c_uint,
        in_hrtirq: core::ffi::c_uint,
        hang_detected: core::ffi::c_uint,
        softirq_activated: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hres_active: u32 = unsafe { ::core::mem::transmute(hres_active) };
            hres_active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_hrtirq: u32 = unsafe { ::core::mem::transmute(in_hrtirq) };
            in_hrtirq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hang_detected: u32 = unsafe { ::core::mem::transmute(hang_detected) };
            hang_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let softirq_activated: u32 = unsafe { ::core::mem::transmute(softirq_activated) };
            softirq_activated as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcuwait {
    pub task: *mut task_struct,
}
impl Default for rcuwait {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_sync {
    pub gp_state: core::ffi::c_int,
    pub gp_count: core::ffi::c_int,
    pub gp_wait: wait_queue_head_t,
    pub cb_head: callback_head,
}
impl Default for rcu_sync {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_rw_semaphore {
    pub rss: rcu_sync,
    pub read_count: *mut core::ffi::c_uint,
    pub writer: rcuwait,
    pub waiters: wait_queue_head_t,
    pub block: atomic_t,
}
impl Default for percpu_rw_semaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct delayed_call {
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
    pub arg: *mut core::ffi::c_void,
}
impl Default for delayed_call {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uuid_t {
    pub b: [__u8; 16usize],
}
pub type errseq_t = u32_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfsmount {
    pub mnt_root: *mut dentry,
    pub mnt_sb: *mut super_block,
    pub mnt_flags: core::ffi::c_int,
    pub mnt_idmap: *mut mnt_idmap,
}
impl Default for vfsmount {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfsuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfsgid_t {
    pub val: gid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct export_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fiemap_extent_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hd_geometry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct poll_table_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kstatfs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_info_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_inode_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsverity_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsverity_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parameter_spec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fileattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iattr {
    pub ia_valid: core::ffi::c_uint,
    pub ia_mode: umode_t,
    pub __bindgen_anon_1: iattr__bindgen_ty_1,
    pub __bindgen_anon_2: iattr__bindgen_ty_2,
    pub ia_size: loff_t,
    pub ia_atime: timespec64,
    pub ia_mtime: timespec64,
    pub ia_ctime: timespec64,
    pub ia_file: *mut file,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_1 {
    pub ia_uid: kuid_t,
    pub ia_vfsuid: vfsuid_t,
}
impl Default for iattr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_2 {
    pub ia_gid: kgid_t,
    pub ia_vfsgid: vfsgid_t,
}
impl Default for iattr__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iattr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type projid_t = __kernel_uid32_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kprojid_t {
    pub val: projid_t,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2,
}
pub type qsize_t = core::ffi::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kqid {
    pub __bindgen_anon_1: kqid__bindgen_ty_1,
    pub type_: quota_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kqid__bindgen_ty_1 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub projid: kprojid_t,
}
impl Default for kqid__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kqid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mem_dqblk {
    pub dqb_bhardlimit: qsize_t,
    pub dqb_bsoftlimit: qsize_t,
    pub dqb_curspace: qsize_t,
    pub dqb_rsvspace: qsize_t,
    pub dqb_ihardlimit: qsize_t,
    pub dqb_isoftlimit: qsize_t,
    pub dqb_curinodes: qsize_t,
    pub dqb_btime: time64_t,
    pub dqb_itime: time64_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_dqinfo {
    pub dqi_format: *mut quota_format_type,
    pub dqi_fmt_id: core::ffi::c_int,
    pub dqi_dirty_list: list_head,
    pub dqi_flags: core::ffi::c_ulong,
    pub dqi_bgrace: core::ffi::c_uint,
    pub dqi_igrace: core::ffi::c_uint,
    pub dqi_max_spc_limit: qsize_t,
    pub dqi_max_ino_limit: qsize_t,
    pub dqi_priv: *mut core::ffi::c_void,
}
impl Default for mem_dqinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dquot {
    pub dq_hash: hlist_node,
    pub dq_inuse: list_head,
    pub dq_free: list_head,
    pub dq_dirty: list_head,
    pub dq_lock: mutex,
    pub dq_dqb_lock: spinlock_t,
    pub dq_count: atomic_t,
    pub dq_sb: *mut super_block,
    pub dq_id: kqid,
    pub dq_off: loff_t,
    pub dq_flags: core::ffi::c_ulong,
    pub dq_dqb: mem_dqblk,
}
impl Default for dquot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct quota_format_ops {
    pub check_quota_file: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub read_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub write_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub free_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub read_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> core::ffi::c_int>,
    pub commit_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> core::ffi::c_int>,
    pub release_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> core::ffi::c_int>,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dquot_operations {
    pub write_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> core::ffi::c_int>,
    pub alloc_dquot: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_int) -> *mut dquot,
    >,
    pub destroy_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>,
    pub acquire_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> core::ffi::c_int>,
    pub release_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> core::ffi::c_int>,
    pub mark_dirty:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> core::ffi::c_int>,
    pub write_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub get_reserved_space:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>,
    pub get_projid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> core::ffi::c_int,
    >,
    pub get_inode_usage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> core::ffi::c_int,
    >,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_dqblk {
    pub d_fieldmask: core::ffi::c_int,
    pub d_spc_hardlimit: u64_,
    pub d_spc_softlimit: u64_,
    pub d_ino_hardlimit: u64_,
    pub d_ino_softlimit: u64_,
    pub d_space: u64_,
    pub d_ino_count: u64_,
    pub d_ino_timer: s64,
    pub d_spc_timer: s64,
    pub d_ino_warns: core::ffi::c_int,
    pub d_spc_warns: core::ffi::c_int,
    pub d_rt_spc_hardlimit: u64_,
    pub d_rt_spc_softlimit: u64_,
    pub d_rt_space: u64_,
    pub d_rt_spc_timer: s64,
    pub d_rt_spc_warns: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_type_state {
    pub flags: core::ffi::c_uint,
    pub spc_timelimit: core::ffi::c_uint,
    pub ino_timelimit: core::ffi::c_uint,
    pub rt_spc_timelimit: core::ffi::c_uint,
    pub spc_warnlimit: core::ffi::c_uint,
    pub ino_warnlimit: core::ffi::c_uint,
    pub rt_spc_warnlimit: core::ffi::c_uint,
    pub ino: core::ffi::c_ulonglong,
    pub blocks: blkcnt_t,
    pub nextents: blkcnt_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_state {
    pub s_incoredqs: core::ffi::c_uint,
    pub s_state: [qc_type_state; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_info {
    pub i_fieldmask: core::ffi::c_int,
    pub i_flags: core::ffi::c_uint,
    pub i_spc_timelimit: core::ffi::c_uint,
    pub i_ino_timelimit: core::ffi::c_uint,
    pub i_rt_spc_timelimit: core::ffi::c_uint,
    pub i_spc_warnlimit: core::ffi::c_uint,
    pub i_ino_warnlimit: core::ffi::c_uint,
    pub i_rt_spc_warnlimit: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct quotactl_ops {
    pub quota_on: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: core::ffi::c_int,
            arg3: core::ffi::c_int,
            arg4: *const path,
        ) -> core::ffi::c_int,
    >,
    pub quota_off: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub quota_enable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub quota_disable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub quota_sync: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub set_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: core::ffi::c_int,
            arg3: *mut qc_info,
        ) -> core::ffi::c_int,
    >,
    pub get_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> core::ffi::c_int,
    >,
    pub get_nextdqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut kqid,
            arg3: *mut qc_dqblk,
        ) -> core::ffi::c_int,
    >,
    pub set_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> core::ffi::c_int,
    >,
    pub get_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut qc_state) -> core::ffi::c_int,
    >,
    pub rm_xquota: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_format_type {
    pub qf_fmt_id: core::ffi::c_int,
    pub qf_ops: *const quota_format_ops,
    pub qf_owner: *mut module,
    pub qf_next: *mut quota_format_type,
}
impl Default for quota_format_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_info {
    pub flags: core::ffi::c_uint,
    pub dqio_sem: rw_semaphore,
    pub files: [*mut inode; 3usize],
    pub info: [mem_dqinfo; 3usize],
    pub ops: [*const quota_format_ops; 3usize],
}
impl Default for quota_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct writeback_control {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct readahead_control {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kiocb {
    pub ki_filp: *mut file,
    pub ki_pos: loff_t,
    pub ki_complete:
        ::core::option::Option<unsafe extern "C" fn(iocb: *mut kiocb, ret: core::ffi::c_long)>,
    pub private: *mut core::ffi::c_void,
    pub ki_flags: core::ffi::c_int,
    pub ki_ioprio: u16_,
    pub __bindgen_anon_1: kiocb__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kiocb__bindgen_ty_1 {
    pub ki_waitq: *mut wait_page_queue,
    pub dio_complete:
        ::core::option::Option<unsafe extern "C" fn(data: *mut core::ffi::c_void) -> isize>,
}
impl Default for kiocb__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kiocb {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct address_space_operations {
    pub writepage: ::core::option::Option<
        unsafe extern "C" fn(page: *mut page, wbc: *mut writeback_control) -> core::ffi::c_int,
    >,
    pub read_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut folio) -> core::ffi::c_int,
    >,
    pub writepages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut writeback_control,
        ) -> core::ffi::c_int,
    >,
    pub dirty_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut folio) -> bool_,
    >,
    pub readahead: ::core::option::Option<unsafe extern "C" fn(arg1: *mut readahead_control)>,
    pub write_begin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: core::ffi::c_uint,
            pagep: *mut *mut page,
            fsdata: *mut *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub write_end: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: core::ffi::c_uint,
            copied: core::ffi::c_uint,
            page: *mut page,
            fsdata: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub bmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
    >,
    pub invalidate_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, offset: usize, len: usize)>,
    pub release_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, arg2: gfp_t) -> bool_>,
    pub free_folio: ::core::option::Option<unsafe extern "C" fn(folio: *mut folio)>,
    pub direct_IO: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, iter: *mut iov_iter) -> isize,
    >,
    pub migrate_folio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            dst: *mut folio,
            src: *mut folio,
            arg2: migrate_mode,
        ) -> core::ffi::c_int,
    >,
    pub launder_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio) -> core::ffi::c_int>,
    pub is_partially_uptodate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, from: usize, count: usize) -> bool_,
    >,
    pub is_dirty_writeback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, dirty: *mut bool_, wb: *mut bool_),
    >,
    pub error_remove_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut folio) -> core::ffi::c_int,
    >,
    pub swap_activate: ::core::option::Option<
        unsafe extern "C" fn(
            sis: *mut swap_info_struct,
            file: *mut file,
            span: *mut sector_t,
        ) -> core::ffi::c_int,
    >,
    pub swap_deactivate: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
    pub swap_rw: ::core::option::Option<
        unsafe extern "C" fn(iocb: *mut kiocb, iter: *mut iov_iter) -> core::ffi::c_int,
    >,
}
#[doc = " struct address_space - Contents of a cacheable, mappable object.\n @host: Owner, either the inode or the block_device.\n @i_pages: Cached pages.\n @invalidate_lock: Guards coherency between page cache contents and\n   file offset->disk block mappings in the filesystem during invalidates.\n   It is also used to block modification of page cache contents through\n   memory mappings.\n @gfp_mask: Memory allocation flags to use for allocating pages.\n @i_mmap_writable: Number of VM_SHARED, VM_MAYWRITE mappings.\n @nr_thps: Number of THPs in the pagecache (non-shmem only).\n @i_mmap: Tree of private and shared mappings.\n @i_mmap_rwsem: Protects @i_mmap and @i_mmap_writable.\n @nrpages: Number of page entries, protected by the i_pages lock.\n @writeback_index: Writeback starts here.\n @a_ops: Methods.\n @flags: Error bits and flags (AS_*).\n @wb_err: The most recent error which has occurred.\n @i_private_lock: For use by the owner of the address_space.\n @i_private_list: For use by the owner of the address_space.\n @i_private_data: For use by the owner of the address_space."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct address_space {
    pub host: *mut inode,
    pub i_pages: xarray,
    pub invalidate_lock: rw_semaphore,
    pub gfp_mask: gfp_t,
    pub i_mmap_writable: atomic_t,
    pub nr_thps: atomic_t,
    pub i_mmap: rb_root_cached,
    pub nrpages: core::ffi::c_ulong,
    pub writeback_index: core::ffi::c_ulong,
    pub a_ops: *const address_space_operations,
    pub flags: core::ffi::c_ulong,
    pub i_mmap_rwsem: rw_semaphore,
    pub wb_err: errseq_t,
    pub i_private_lock: spinlock_t,
    pub i_private_list: list_head,
    pub i_private_data: *mut core::ffi::c_void,
}
impl Default for address_space {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsnotify_mark_connector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inode {
    pub i_mode: umode_t,
    pub i_opflags: core::ffi::c_ushort,
    pub i_uid: kuid_t,
    pub i_gid: kgid_t,
    pub i_flags: core::ffi::c_uint,
    pub i_acl: *mut posix_acl,
    pub i_default_acl: *mut posix_acl,
    pub i_op: *const inode_operations,
    pub i_sb: *mut super_block,
    pub i_mapping: *mut address_space,
    pub i_security: *mut core::ffi::c_void,
    pub i_ino: core::ffi::c_ulong,
    pub __bindgen_anon_1: inode__bindgen_ty_1,
    pub i_rdev: dev_t,
    pub i_size: loff_t,
    pub __i_atime: timespec64,
    pub __i_mtime: timespec64,
    pub __i_ctime: timespec64,
    pub i_lock: spinlock_t,
    pub i_bytes: core::ffi::c_ushort,
    pub i_blkbits: u8_,
    pub i_write_hint: u8_,
    pub i_blocks: blkcnt_t,
    pub i_state: core::ffi::c_ulong,
    pub i_rwsem: rw_semaphore,
    pub dirtied_when: core::ffi::c_ulong,
    pub dirtied_time_when: core::ffi::c_ulong,
    pub i_hash: hlist_node,
    pub i_io_list: list_head,
    pub i_wb: *mut bdi_writeback,
    pub i_wb_frn_winner: core::ffi::c_int,
    pub i_wb_frn_avg_time: u16_,
    pub i_wb_frn_history: u16_,
    pub i_lru: list_head,
    pub i_sb_list: list_head,
    pub i_wb_list: list_head,
    pub __bindgen_anon_2: inode__bindgen_ty_2,
    pub i_version: atomic64_t,
    pub i_sequence: atomic64_t,
    pub i_count: atomic_t,
    pub i_dio_count: atomic_t,
    pub i_writecount: atomic_t,
    pub i_readcount: atomic_t,
    pub __bindgen_anon_3: inode__bindgen_ty_3,
    pub i_flctx: *mut file_lock_context,
    pub i_data: address_space,
    pub i_devices: list_head,
    pub __bindgen_anon_4: inode__bindgen_ty_4,
    pub i_generation: __u32,
    pub i_fsnotify_mask: __u32,
    pub i_fsnotify_marks: *mut fsnotify_mark_connector,
    pub i_crypt_info: *mut fscrypt_inode_info,
    pub i_verity_info: *mut fsverity_info,
    pub i_private: *mut core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_1 {
    pub i_nlink: core::ffi::c_uint,
    pub __i_nlink: core::ffi::c_uint,
}
impl Default for inode__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_2 {
    pub i_dentry: hlist_head,
    pub i_rcu: callback_head,
}
impl Default for inode__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_3 {
    pub i_fop: *const file_operations,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
}
impl Default for inode__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_4 {
    pub i_pipe: *mut pipe_inode_info,
    pub i_cdev: *mut cdev,
    pub i_link: *mut core::ffi::c_char,
    pub i_dir_seq: core::ffi::c_uint,
}
impl Default for inode__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for inode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fown_struct {
    pub lock: rwlock_t,
    pub pid: *mut pid,
    pub pid_type: pid_type,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub signum: core::ffi::c_int,
}
impl Default for fown_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct file_ra_state - Track a file's readahead state.\n @start: Where the most recent readahead started.\n @size: Number of pages read in the most recent readahead.\n @async_size: Numer of pages that were/are not needed immediately\n      and so were/are genuinely \"ahead\".  Start next readahead when\n      the first of these pages is accessed.\n @ra_pages: Maximum size of a readahead request, copied from the bdi.\n @mmap_miss: How many mmap accesses missed in the page cache.\n @prev_pos: The last byte in the most recent read request.\n\n When this structure is passed to ->readahead(), the \"most recent\"\n readahead means the current readahead."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_ra_state {
    pub start: core::ffi::c_ulong,
    pub size: core::ffi::c_uint,
    pub async_size: core::ffi::c_uint,
    pub ra_pages: core::ffi::c_uint,
    pub mmap_miss: core::ffi::c_uint,
    pub prev_pos: loff_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    pub __bindgen_anon_1: file__bindgen_ty_1,
    pub f_lock: spinlock_t,
    pub f_mode: fmode_t,
    pub f_count: atomic_long_t,
    pub f_pos_lock: mutex,
    pub f_pos: loff_t,
    pub f_flags: core::ffi::c_uint,
    pub f_owner: fown_struct,
    pub f_cred: *const cred,
    pub f_ra: file_ra_state,
    pub f_path: path,
    pub f_inode: *mut inode,
    pub f_op: *const file_operations,
    pub f_version: u64_,
    pub f_security: *mut core::ffi::c_void,
    pub private_data: *mut core::ffi::c_void,
    pub f_ep: *mut hlist_head,
    pub f_mapping: *mut address_space,
    pub f_wb_err: errseq_t,
    pub f_sb_err: errseq_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_1 {
    pub f_task_work: callback_head,
    pub f_llist: llist_node,
    pub f_iocb_flags: core::ffi::c_uint,
}
impl Default for file__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type fl_owner_t = *mut core::ffi::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sb_writers {
    pub frozen: core::ffi::c_ushort,
    pub freeze_kcount: core::ffi::c_int,
    pub freeze_ucount: core::ffi::c_int,
    pub rw_sem: [percpu_rw_semaphore; 3usize],
}
impl Default for sb_writers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct super_block {
    pub s_list: list_head,
    pub s_dev: dev_t,
    pub s_blocksize_bits: core::ffi::c_uchar,
    pub s_blocksize: core::ffi::c_ulong,
    pub s_maxbytes: loff_t,
    pub s_type: *mut file_system_type,
    pub s_op: *const super_operations,
    pub dq_op: *const dquot_operations,
    pub s_qcop: *const quotactl_ops,
    pub s_export_op: *const export_operations,
    pub s_flags: core::ffi::c_ulong,
    pub s_iflags: core::ffi::c_ulong,
    pub s_magic: core::ffi::c_ulong,
    pub s_root: *mut dentry,
    pub s_umount: rw_semaphore,
    pub s_count: core::ffi::c_int,
    pub s_active: atomic_t,
    pub s_security: *mut core::ffi::c_void,
    pub s_xattr: *const *mut xattr_handler,
    pub s_cop: *const fscrypt_operations,
    pub s_master_keys: *mut fscrypt_keyring,
    pub s_vop: *const fsverity_operations,
    pub s_encoding: *mut unicode_map,
    pub s_encoding_flags: __u16,
    pub s_roots: hlist_bl_head,
    pub s_mounts: list_head,
    pub s_bdev: *mut block_device,
    pub s_bdev_handle: *mut bdev_handle,
    pub s_bdi: *mut backing_dev_info,
    pub s_mtd: *mut mtd_info,
    pub s_instances: hlist_node,
    pub s_quota_types: core::ffi::c_uint,
    pub s_dquot: quota_info,
    pub s_writers: sb_writers,
    pub s_fs_info: *mut core::ffi::c_void,
    pub s_time_gran: u32_,
    pub s_time_min: time64_t,
    pub s_time_max: time64_t,
    pub s_fsnotify_mask: __u32,
    pub s_fsnotify_marks: *mut fsnotify_mark_connector,
    pub s_id: [core::ffi::c_char; 32usize],
    pub s_uuid: uuid_t,
    pub s_max_links: core::ffi::c_uint,
    pub s_vfs_rename_mutex: mutex,
    pub s_subtype: *const core::ffi::c_char,
    pub s_d_op: *const dentry_operations,
    pub s_shrink: *mut shrinker,
    pub s_remove_count: atomic_long_t,
    pub s_fsnotify_connectors: atomic_long_t,
    pub s_readonly_remount: core::ffi::c_int,
    pub s_wb_err: errseq_t,
    pub s_dio_done_wq: *mut workqueue_struct,
    pub s_pins: hlist_head,
    pub s_user_ns: *mut user_namespace,
    pub s_dentry_lru: list_lru,
    pub s_inode_lru: list_lru,
    pub rcu: callback_head,
    pub destroy_work: work_struct,
    pub s_sync_lock: mutex,
    pub s_stack_depth: core::ffi::c_int,
    pub __bindgen_padding_0: [u32; 11usize],
    pub s_inode_list_lock: spinlock_t,
    pub s_inodes: list_head,
    pub s_inode_wblist_lock: spinlock_t,
    pub s_inodes_wb: list_head,
}
impl Default for super_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type filldir_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dir_context,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_int,
        arg4: loff_t,
        arg5: u64_,
        arg6: core::ffi::c_uint,
    ) -> bool_,
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dir_context {
    pub actor: filldir_t,
    pub pos: loff_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_uring_cmd {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct inode_operations {
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: core::ffi::c_uint,
        ) -> *mut dentry,
    >,
    pub get_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut delayed_call,
        ) -> *const core::ffi::c_char,
    >,
    pub permission: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub get_inode_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: core::ffi::c_int,
            arg3: bool_,
        ) -> *mut posix_acl,
    >,
    pub readlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut core::ffi::c_char,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: bool_,
        ) -> core::ffi::c_int,
    >,
    pub link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut dentry,
        ) -> core::ffi::c_int,
    >,
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub symlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *const core::ffi::c_char,
        ) -> core::ffi::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
        ) -> core::ffi::c_int,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub mknod: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: dev_t,
        ) -> core::ffi::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *mut inode,
            arg5: *mut dentry,
            arg6: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub setattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut dentry,
            arg3: *mut iattr,
        ) -> core::ffi::c_int,
    >,
    pub getattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *const path,
            arg3: *mut kstat,
            arg4: u32_,
            arg5: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub listxattr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut core::ffi::c_char, arg3: usize) -> isize,
    >,
    pub fiemap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut fiemap_extent_info,
            start: u64_,
            len: u64_,
        ) -> core::ffi::c_int,
    >,
    pub update_time: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub atomic_open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut file,
            open_flag: core::ffi::c_uint,
            create_mode: umode_t,
        ) -> core::ffi::c_int,
    >,
    pub tmpfile: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut file,
            arg4: umode_t,
        ) -> core::ffi::c_int,
    >,
    pub get_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut dentry,
            arg3: core::ffi::c_int,
        ) -> *mut posix_acl,
    >,
    pub set_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut dentry,
            arg3: *mut posix_acl,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub fileattr_set: ::core::option::Option<
        unsafe extern "C" fn(
            idmap: *mut mnt_idmap,
            dentry: *mut dentry,
            fa: *mut fileattr,
        ) -> core::ffi::c_int,
    >,
    pub fileattr_get: ::core::option::Option<
        unsafe extern "C" fn(dentry: *mut dentry, fa: *mut fileattr) -> core::ffi::c_int,
    >,
    pub get_offset_ctx:
        ::core::option::Option<unsafe extern "C" fn(inode: *mut inode) -> *mut offset_ctx>,
}
impl Default for inode_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " enum freeze_holder - holder of the freeze\n @FREEZE_HOLDER_KERNEL: kernel wants to freeze or thaw filesystem\n @FREEZE_HOLDER_USERSPACE: userspace wants to freeze or thaw filesystem\n @FREEZE_MAY_NEST: whether nesting freeze and thaw requests is allowed\n\n Indicate who the owner of the freeze or thaw request is and whether\n the freeze needs to be exclusive or can nest.\n Without @FREEZE_MAY_NEST, multiple freeze and thaw requests from the\n same holder aren't allowed. It is however allowed to hold a single\n @FREEZE_HOLDER_USERSPACE and a single @FREEZE_HOLDER_KERNEL freeze at\n the same time. This is relied upon by some filesystems during online\n repair or similar."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum freeze_holder {
    FREEZE_HOLDER_KERNEL = 1,
    FREEZE_HOLDER_USERSPACE = 2,
    FREEZE_MAY_NEST = 4,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct super_operations {
    pub alloc_inode:
        ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block) -> *mut inode>,
    pub destroy_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub dirty_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, flags: core::ffi::c_int)>,
    pub write_inode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, wbc: *mut writeback_control) -> core::ffi::c_int,
    >,
    pub drop_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> core::ffi::c_int>,
    pub evict_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub put_super: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub sync_fs: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, wait: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub freeze_super: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, who: freeze_holder) -> core::ffi::c_int,
    >,
    pub freeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> core::ffi::c_int>,
    pub thaw_super: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, who: freeze_holder) -> core::ffi::c_int,
    >,
    pub unfreeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> core::ffi::c_int>,
    pub statfs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> core::ffi::c_int,
    >,
    pub remount_fs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut core::ffi::c_int,
            arg3: *mut core::ffi::c_char,
        ) -> core::ffi::c_int,
    >,
    pub umount_begin: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub show_devname: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub show_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub quota_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: core::ffi::c_int,
            arg3: *mut core::ffi::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub quota_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: core::ffi::c_int,
            arg3: *const core::ffi::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub get_dquots:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut *mut dquot>,
    pub nr_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut shrink_control,
        ) -> core::ffi::c_long,
    >,
    pub free_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut shrink_control,
        ) -> core::ffi::c_long,
    >,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct offset_ctx {
    pub xa: xarray,
    pub next_offset: u32_,
}
impl Default for offset_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct vmem_altmap - pre-allocated storage for vmemmap_populate\n @base_pfn: base of the entire dev_pagemap mapping\n @reserve: pages mapped, but reserved for driver use (relative to @base)\n @free: free pages set aside in the mapping for memmap storage\n @align: pages reserved to meet allocation alignments\n @alloc: track pages consumed, private to vmemmap_populate()"]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vmem_altmap {
    pub base_pfn: core::ffi::c_ulong,
    pub end_pfn: core::ffi::c_ulong,
    pub reserve: core::ffi::c_ulong,
    pub free: core::ffi::c_ulong,
    pub align: core::ffi::c_ulong,
    pub alloc: core::ffi::c_ulong,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum memory_type {
    MEMORY_DEVICE_PRIVATE = 1,
    MEMORY_DEVICE_COHERENT = 2,
    MEMORY_DEVICE_FS_DAX = 3,
    MEMORY_DEVICE_GENERIC = 4,
    MEMORY_DEVICE_PCI_P2PDMA = 5,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pagemap_ops {
    pub page_free: ::core::option::Option<unsafe extern "C" fn(page: *mut page)>,
    pub migrate_to_ram:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub memory_failure: ::core::option::Option<
        unsafe extern "C" fn(
            pgmap: *mut dev_pagemap,
            pfn: core::ffi::c_ulong,
            nr_pages: core::ffi::c_ulong,
            mf_flags: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
}
#[doc = " struct dev_pagemap - metadata for ZONE_DEVICE mappings\n @altmap: pre-allocated/reserved memory for vmemmap allocations\n @ref: reference count that pins the devm_memremap_pages() mapping\n @done: completion for @ref\n @type: memory type: see MEMORY_* in memory_hotplug.h\n @flags: PGMAP_* flags to specify defailed behavior\n @vmemmap_shift: structural definition of how the vmemmap page metadata\n      is populated, specifically the metadata page order.\n\tA zero value (default) uses base pages as the vmemmap metadata\n\trepresentation. A bigger value will set up compound struct pages\n\tof the requested order value.\n @ops: method table\n @owner: an opaque pointer identifying the entity that manages this\n\tinstance.  Used by various helpers to make sure that no\n\tforeign ZONE_DEVICE memory is accessed.\n @nr_range: number of ranges to be mapped\n @range: range to be mapped when nr_range == 1\n @ranges: array of ranges to be mapped when nr_range > 1"]
#[repr(C)]
pub struct dev_pagemap {
    pub altmap: vmem_altmap,
    pub ref_: percpu_ref,
    pub done: completion,
    pub type_: memory_type,
    pub flags: core::ffi::c_uint,
    pub vmemmap_shift: core::ffi::c_ulong,
    pub ops: *const dev_pagemap_ops,
    pub owner: *mut core::ffi::c_void,
    pub nr_range: core::ffi::c_int,
    pub __bindgen_anon_1: dev_pagemap__bindgen_ty_1,
}
#[repr(C)]
pub struct dev_pagemap__bindgen_ty_1 {
    pub range: __BindgenUnionField<range>,
    pub __bindgen_anon_1: __BindgenUnionField<dev_pagemap__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Default)]
pub struct dev_pagemap__bindgen_ty_1__bindgen_ty_1 {
    pub __empty_ranges: dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub ranges: __IncompleteArrayField<range>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
impl Default for dev_pagemap__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for dev_pagemap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct anon_vma {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_fault {
    pub __bindgen_anon_1: vm_fault__bindgen_ty_1,
    pub flags: fault_flag,
    pub pmd: *mut pmd_t,
    pub pud: *mut pud_t,
    pub __bindgen_anon_2: vm_fault__bindgen_ty_2,
    pub cow_page: *mut page,
    pub page: *mut page,
    pub pte: *mut pte_t,
    pub ptl: *mut spinlock_t,
    pub prealloc_pte: pgtable_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_fault__bindgen_ty_1 {
    pub vma: *mut vm_area_struct,
    pub gfp_mask: gfp_t,
    pub pgoff: core::ffi::c_ulong,
    pub address: core::ffi::c_ulong,
    pub real_address: core::ffi::c_ulong,
}
impl Default for vm_fault__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_fault__bindgen_ty_2 {
    pub orig_pte: pte_t,
    pub orig_pmd: pmd_t,
}
impl Default for vm_fault__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vm_fault {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vm_operations_struct {
    pub open: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    #[doc = " @close: Called when the VMA is being removed from the MM.\n Context: User context.  May sleep.  Caller holds mmap_lock."]
    pub close: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub may_split: ::core::option::Option<
        unsafe extern "C" fn(
            area: *mut vm_area_struct,
            addr: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub mremap:
        ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct) -> core::ffi::c_int>,
    pub mprotect: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            start: core::ffi::c_ulong,
            end: core::ffi::c_ulong,
            newflags: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub fault: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub huge_fault: ::core::option::Option<
        unsafe extern "C" fn(vmf: *mut vm_fault, order: core::ffi::c_uint) -> vm_fault_t,
    >,
    pub map_pages: ::core::option::Option<
        unsafe extern "C" fn(
            vmf: *mut vm_fault,
            start_pgoff: core::ffi::c_ulong,
            end_pgoff: core::ffi::c_ulong,
        ) -> vm_fault_t,
    >,
    pub pagesize: ::core::option::Option<
        unsafe extern "C" fn(area: *mut vm_area_struct) -> core::ffi::c_ulong,
    >,
    pub page_mkwrite:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub pfn_mkwrite: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub access: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            addr: core::ffi::c_ulong,
            buf: *mut core::ffi::c_void,
            len: core::ffi::c_int,
            write: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct) -> *const core::ffi::c_char,
    >,
    pub set_policy: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, new: *mut mempolicy) -> core::ffi::c_int,
    >,
    pub get_policy: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            addr: core::ffi::c_ulong,
            ilx: *mut core::ffi::c_ulong,
        ) -> *mut mempolicy,
    >,
    pub find_special_page: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, addr: core::ffi::c_ulong) -> *mut page,
    >,
}
#[doc = " struct bio_vec - a contiguous range of physical memory addresses\n @bv_page:   First page associated with the address range.\n @bv_len:    Number of bytes in the address range.\n @bv_offset: Start of the address range relative to the start of @bv_page.\n\n The following holds for a bvec if n * PAGE_SIZE < bv_offset + bv_len:\n\n   nth_page(@bv_page, n) == @bv_page + n\n\n This holds because page_is_mergeable() checks the above property."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_vec {
    pub bv_page: *mut page,
    pub bv_len: core::ffi::c_uint,
    pub bv_offset: core::ffi::c_uint,
}
impl Default for bio_vec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct bvec_iter {
    pub bi_sector: sector_t,
    pub bi_size: core::ffi::c_uint,
    pub bi_idx: core::ffi::c_uint,
    pub bi_bvec_done: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_iattrs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_elem_dir {
    pub subdirs: core::ffi::c_ulong,
    pub children: rb_root,
    pub root: *mut kernfs_root,
    pub rev: core::ffi::c_ulong,
}
impl Default for kernfs_elem_dir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_elem_symlink {
    pub target_kn: *mut kernfs_node,
}
impl Default for kernfs_elem_symlink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_elem_attr {
    pub ops: *const kernfs_ops,
    pub open: *mut kernfs_open_node,
    pub size: loff_t,
    pub notify_next: *mut kernfs_node,
}
impl Default for kernfs_elem_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_node {
    pub count: atomic_t,
    pub active: atomic_t,
    pub parent: *mut kernfs_node,
    pub name: *const core::ffi::c_char,
    pub rb: rb_node,
    pub ns: *const core::ffi::c_void,
    pub hash: core::ffi::c_uint,
    pub __bindgen_anon_1: kernfs_node__bindgen_ty_1,
    pub priv_: *mut core::ffi::c_void,
    pub id: u64_,
    pub flags: core::ffi::c_ushort,
    pub mode: umode_t,
    pub iattr: *mut kernfs_iattrs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node__bindgen_ty_1 {
    pub dir: kernfs_elem_dir,
    pub symlink: kernfs_elem_symlink,
    pub attr: kernfs_elem_attr,
}
impl Default for kernfs_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kernfs_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_file {
    pub kn: *mut kernfs_node,
    pub file: *mut file,
    pub seq_file: *mut seq_file,
    pub priv_: *mut core::ffi::c_void,
    pub mutex: mutex,
    pub prealloc_mutex: mutex,
    pub event: core::ffi::c_int,
    pub list: list_head,
    pub prealloc_buf: *mut core::ffi::c_char,
    pub atomic_write_len: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub vm_ops: *const vm_operations_struct,
}
impl Default for kernfs_open_file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl kernfs_open_file {
    #[inline]
    pub fn mmapped(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmapped(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn released(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_released(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mmapped: bool_, released: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmapped: u8 = unsafe { ::core::mem::transmute(mmapped) };
            mmapped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let released: u8 = unsafe { ::core::mem::transmute(released) };
            released as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernfs_ops {
    pub open:
        ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> core::ffi::c_int>,
    pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, v: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut core::ffi::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            v: *mut core::ffi::c_void,
            ppos: *mut loff_t,
        ) -> *mut core::ffi::c_void,
    >,
    pub seq_stop:
        ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut core::ffi::c_void)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut core::ffi::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub atomic_write_len: usize,
    pub prealloc: bool_,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut core::ffi::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            vma: *mut vm_area_struct,
        ) -> core::ffi::c_int,
    >,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            offset: loff_t,
            whence: core::ffi::c_int,
        ) -> loff_t,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_ns_type_operations {
    pub type_: kobj_ns_type,
    pub current_may_mount: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub grab_current_ns: ::core::option::Option<unsafe extern "C" fn() -> *mut core::ffi::c_void>,
    pub netlink_ns:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> *const core::ffi::c_void>,
    pub initial_ns: ::core::option::Option<unsafe extern "C" fn() -> *const core::ffi::c_void>,
    pub drop_ns: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
}
impl Default for kobj_ns_type_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct attribute {
    pub name: *const core::ffi::c_char,
    pub mode: umode_t,
}
impl Default for attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bin_attribute {
    pub attr: attribute,
    pub size: usize,
    pub private: *mut core::ffi::c_void,
    pub f_mapping: ::core::option::Option<unsafe extern "C" fn() -> *mut address_space>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut core::ffi::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut core::ffi::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: loff_t,
            arg5: core::ffi::c_int,
        ) -> loff_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            attr: *mut bin_attribute,
            vma: *mut vm_area_struct,
        ) -> core::ffi::c_int,
    >,
}
impl Default for bin_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sysfs_ops {
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *mut core::ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *const core::ffi::c_char,
            arg4: usize,
        ) -> isize,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobject {
    pub name: *const core::ffi::c_char,
    pub entry: list_head,
    pub parent: *mut kobject,
    pub kset: *mut kset,
    pub ktype: *const kobj_type,
    pub sd: *mut kernfs_node,
    pub kref: kref,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for kobject {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl kobject {
    #[inline]
    pub fn state_initialized(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_initialized(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_in_sysfs(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_in_sysfs(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_add_uevent_sent(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_add_uevent_sent(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_remove_uevent_sent(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_remove_uevent_sent(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uevent_suppress(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uevent_suppress(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state_initialized: core::ffi::c_uint,
        state_in_sysfs: core::ffi::c_uint,
        state_add_uevent_sent: core::ffi::c_uint,
        state_remove_uevent_sent: core::ffi::c_uint,
        uevent_suppress: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let state_initialized: u32 = unsafe { ::core::mem::transmute(state_initialized) };
            state_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let state_in_sysfs: u32 = unsafe { ::core::mem::transmute(state_in_sysfs) };
            state_in_sysfs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let state_add_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_add_uevent_sent) };
            state_add_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_remove_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_remove_uevent_sent) };
            state_remove_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let uevent_suppress: u32 = unsafe { ::core::mem::transmute(uevent_suppress) };
            uevent_suppress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_type {
    pub release: ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject)>,
    pub sysfs_ops: *const sysfs_ops,
    pub default_groups: *mut *const attribute_group,
    pub child_ns_type: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject) -> *const kobj_ns_type_operations,
    >,
    pub namespace: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject) -> *const core::ffi::c_void,
    >,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
}
impl Default for kobj_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_uevent_env {
    pub argv: [*mut core::ffi::c_char; 3usize],
    pub envp: [*mut core::ffi::c_char; 64usize],
    pub envp_idx: core::ffi::c_int,
    pub buf: [core::ffi::c_char; 2048usize],
    pub buflen: core::ffi::c_int,
}
impl Default for kobj_uevent_env {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kset_uevent_ops {
    pub filter:
        ::core::option::Option<unsafe extern "C" fn(kobj: *const kobject) -> core::ffi::c_int>,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject) -> *const core::ffi::c_char,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject, env: *mut kobj_uevent_env) -> core::ffi::c_int,
    >,
}
#[doc = " struct kset - a set of kobjects of a specific type, belonging to a specific subsystem.\n\n A kset defines a group of kobjects.  They can be individually\n different \"types\" but overall these kobjects all want to be grouped\n together and operated on in the same manner.  ksets are used to\n define the attribute callbacks and other common events that happen to\n a kobject.\n\n @list: the list of all kobjects for this kset\n @list_lock: a lock for iterating over the kobjects\n @kobj: the embedded kobject for this kset (recursion, isn't it fun...)\n @uevent_ops: the set of uevent operations for this kset.  These are\n called whenever a kobject has something happen to it so that the kset\n can add new environment variables, or filter out the uevents if so\n desired."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kset {
    pub list: list_head,
    pub list_lock: spinlock_t,
    pub kobj: kobject,
    pub uevent_ops: *const kset_uevent_ops,
}
impl Default for kset {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct em_perf_state - Performance state of a performance domain\n @frequency:\tThe frequency in KHz, for consistency with CPUFreq\n @power:\tThe power consumed at this level (by 1 CPU or by a registered\n\t\tdevice). It can be a total power: static and dynamic.\n @cost:\tThe cost coefficient associated with this level, used during\n\t\tenergy calculation. Equal to: power * max_frequency / frequency\n @flags:\tsee \"em_perf_state flags\" description below."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct em_perf_state {
    pub frequency: core::ffi::c_ulong,
    pub power: core::ffi::c_ulong,
    pub cost: core::ffi::c_ulong,
    pub flags: core::ffi::c_ulong,
}
#[doc = " struct em_perf_domain - Performance domain\n @table:\t\tList of performance states, in ascending order\n @nr_perf_states:\tNumber of performance states\n @flags:\t\tSee \"em_perf_domain flags\"\n @cpus:\t\tCpumask covering the CPUs of the domain. It's here\n\t\t\tfor performance reasons to avoid potential cache\n\t\t\tmisses during energy calculations in the scheduler\n\t\t\tand simplifies allocating/freeing that memory region.\n\n In case of CPU device, a \"performance domain\" represents a group of CPUs\n whose performance is scaled together. All CPUs of a performance domain\n must have the same micro-architecture. Performance domains often have\n a 1-to-1 mapping with CPUFreq policies. In case of other devices the @cpus\n field is unused."]
#[repr(C)]
pub struct em_perf_domain {
    pub table: *mut em_perf_state,
    pub nr_perf_states: core::ffi::c_int,
    pub flags: core::ffi::c_ulong,
    pub cpus: __IncompleteArrayField<core::ffi::c_ulong>,
}
impl Default for em_perf_domain {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pm_message {
    pub event: core::ffi::c_int,
}
pub type pm_message_t = pm_message;
#[doc = " struct dev_pm_ops - device PM callbacks.\n\n @prepare: The principal role of this callback is to prevent new children of\n\tthe device from being registered after it has returned (the driver's\n\tsubsystem and generally the rest of the kernel is supposed to prevent\n\tnew calls to the probe method from being made too once @prepare() has\n\tsucceeded).  If @prepare() detects a situation it cannot handle (e.g.\n\tregistration of a child already in progress), it may return -EAGAIN, so\n\tthat the PM core can execute it once again (e.g. after a new child has\n\tbeen registered) to recover from the race condition.\n\tThis method is executed for all kinds of suspend transitions and is\n\tfollowed by one of the suspend callbacks: @suspend(), @freeze(), or\n\t@poweroff().  If the transition is a suspend to memory or standby (that\n\tis, not related to hibernation), the return value of @prepare() may be\n\tused to indicate to the PM core to leave the device in runtime suspend\n\tif applicable.  Namely, if @prepare() returns a positive number, the PM\n\tcore will understand that as a declaration that the device appears to be\n\truntime-suspended and it may be left in that state during the entire\n\ttransition and during the subsequent resume if all of its descendants\n\tare left in runtime suspend too.  If that happens, @complete() will be\n\texecuted directly after @prepare() and it must ensure the proper\n\tfunctioning of the device after the system resume.\n\tThe PM core executes subsystem-level @prepare() for all devices before\n\tstarting to invoke suspend callbacks for any of them, so generally\n\tdevices may be assumed to be functional or to respond to runtime resume\n\trequests while @prepare() is being executed.  However, device drivers\n\tmay NOT assume anything about the availability of user space at that\n\ttime and it is NOT valid to request firmware from within @prepare()\n\t(it's too late to do that).  It also is NOT valid to allocate\n\tsubstantial amounts of memory from @prepare() in the GFP_KERNEL mode.\n\t[To work around these limitations, drivers may register suspend and\n\thibernation notifiers to be executed before the freezing of tasks.]\n\n @complete: Undo the changes made by @prepare().  This method is executed for\n\tall kinds of resume transitions, following one of the resume callbacks:\n\t@resume(), @thaw(), @restore().  Also called if the state transition\n\tfails before the driver's suspend callback: @suspend(), @freeze() or\n\t@poweroff(), can be executed (e.g. if the suspend callback fails for one\n\tof the other devices that the PM core has unsuccessfully attempted to\n\tsuspend earlier).\n\tThe PM core executes subsystem-level @complete() after it has executed\n\tthe appropriate resume callbacks for all devices.  If the corresponding\n\t@prepare() at the beginning of the suspend transition returned a\n\tpositive number and the device was left in runtime suspend (without\n\texecuting any suspend and resume callbacks for it), @complete() will be\n\tthe only callback executed for the device during resume.  In that case,\n\t@complete() must be prepared to do whatever is necessary to ensure the\n\tproper functioning of the device after the system resume.  To this end,\n\t@complete() can check the power.direct_complete flag of the device to\n\tlearn whether (unset) or not (set) the previous suspend and resume\n\tcallbacks have been executed for it.\n\n @suspend: Executed before putting the system into a sleep state in which the\n\tcontents of main memory are preserved.  The exact action to perform\n\tdepends on the device's subsystem (PM domain, device type, class or bus\n\ttype), but generally the device must be quiescent after subsystem-level\n\t@suspend() has returned, so that it doesn't do any I/O or DMA.\n\tSubsystem-level @suspend() is executed for all devices after invoking\n\tsubsystem-level @prepare() for all of them.\n\n @suspend_late: Continue operations started by @suspend().  For a number of\n\tdevices @suspend_late() may point to the same callback routine as the\n\truntime suspend callback.\n\n @resume: Executed after waking the system up from a sleep state in which the\n\tcontents of main memory were preserved.  The exact action to perform\n\tdepends on the device's subsystem, but generally the driver is expected\n\tto start working again, responding to hardware events and software\n\trequests (the device itself may be left in a low-power state, waiting\n\tfor a runtime resume to occur).  The state of the device at the time its\n\tdriver's @resume() callback is run depends on the platform and subsystem\n\tthe device belongs to.  On most platforms, there are no restrictions on\n\tavailability of resources like clocks during @resume().\n\tSubsystem-level @resume() is executed for all devices after invoking\n\tsubsystem-level @resume_noirq() for all of them.\n\n @resume_early: Prepare to execute @resume().  For a number of devices\n\t@resume_early() may point to the same callback routine as the runtime\n\tresume callback.\n\n @freeze: Hibernation-specific, executed before creating a hibernation image.\n\tAnalogous to @suspend(), but it should not enable the device to signal\n\twakeup events or change its power state.  The majority of subsystems\n\t(with the notable exception of the PCI bus type) expect the driver-level\n\t@freeze() to save the device settings in memory to be used by @restore()\n\tduring the subsequent resume from hibernation.\n\tSubsystem-level @freeze() is executed for all devices after invoking\n\tsubsystem-level @prepare() for all of them.\n\n @freeze_late: Continue operations started by @freeze().  Analogous to\n\t@suspend_late(), but it should not enable the device to signal wakeup\n\tevents or change its power state.\n\n @thaw: Hibernation-specific, executed after creating a hibernation image OR\n\tif the creation of an image has failed.  Also executed after a failing\n\tattempt to restore the contents of main memory from such an image.\n\tUndo the changes made by the preceding @freeze(), so the device can be\n\toperated in the same way as immediately before the call to @freeze().\n\tSubsystem-level @thaw() is executed for all devices after invoking\n\tsubsystem-level @thaw_noirq() for all of them.  It also may be executed\n\tdirectly after @freeze() in case of a transition error.\n\n @thaw_early: Prepare to execute @thaw().  Undo the changes made by the\n\tpreceding @freeze_late().\n\n @poweroff: Hibernation-specific, executed after saving a hibernation image.\n\tAnalogous to @suspend(), but it need not save the device's settings in\n\tmemory.\n\tSubsystem-level @poweroff() is executed for all devices after invoking\n\tsubsystem-level @prepare() for all of them.\n\n @poweroff_late: Continue operations started by @poweroff().  Analogous to\n\t@suspend_late(), but it need not save the device's settings in memory.\n\n @restore: Hibernation-specific, executed after restoring the contents of main\n\tmemory from a hibernation image, analogous to @resume().\n\n @restore_early: Prepare to execute @restore(), analogous to @resume_early().\n\n @suspend_noirq: Complete the actions started by @suspend().  Carry out any\n\tadditional operations required for suspending the device that might be\n\tracing with its driver's interrupt handler, which is guaranteed not to\n\trun while @suspend_noirq() is being executed.\n\tIt generally is expected that the device will be in a low-power state\n\t(appropriate for the target system sleep state) after subsystem-level\n\t@suspend_noirq() has returned successfully.  If the device can generate\n\tsystem wakeup signals and is enabled to wake up the system, it should be\n\tconfigured to do so at that time.  However, depending on the platform\n\tand device's subsystem, @suspend() or @suspend_late() may be allowed to\n\tput the device into the low-power state and configure it to generate\n\twakeup signals, in which case it generally is not necessary to define\n\t@suspend_noirq().\n\n @resume_noirq: Prepare for the execution of @resume() by carrying out any\n\toperations required for resuming the device that might be racing with\n\tits driver's interrupt handler, which is guaranteed not to run while\n\t@resume_noirq() is being executed.\n\n @freeze_noirq: Complete the actions started by @freeze().  Carry out any\n\tadditional operations required for freezing the device that might be\n\tracing with its driver's interrupt handler, which is guaranteed not to\n\trun while @freeze_noirq() is being executed.\n\tThe power state of the device should not be changed by either @freeze(),\n\tor @freeze_late(), or @freeze_noirq() and it should not be configured to\n\tsignal system wakeup by any of these callbacks.\n\n @thaw_noirq: Prepare for the execution of @thaw() by carrying out any\n\toperations required for thawing the device that might be racing with its\n\tdriver's interrupt handler, which is guaranteed not to run while\n\t@thaw_noirq() is being executed.\n\n @poweroff_noirq: Complete the actions started by @poweroff().  Analogous to\n\t@suspend_noirq(), but it need not save the device's settings in memory.\n\n @restore_noirq: Prepare for the execution of @restore() by carrying out any\n\toperations required for thawing the device that might be racing with its\n\tdriver's interrupt handler, which is guaranteed not to run while\n\t@restore_noirq() is being executed.  Analogous to @resume_noirq().\n\n @runtime_suspend: Prepare the device for a condition in which it won't be\n\table to communicate with the CPU(s) and RAM due to power management.\n\tThis need not mean that the device should be put into a low-power state.\n\tFor example, if the device is behind a link which is about to be turned\n\toff, the device may remain at full power.  If the device does go to low\n\tpower and is capable of generating runtime wakeup events, remote wakeup\n\t(i.e., a hardware mechanism allowing the device to request a change of\n\tits power state via an interrupt) should be enabled for it.\n\n @runtime_resume: Put the device into the fully active state in response to a\n\twakeup event generated by hardware or at the request of software.  If\n\tnecessary, put the device into the full-power state and restore its\n\tregisters, so that it is fully operational.\n\n @runtime_idle: Device appears to be inactive and it might be put into a\n\tlow-power state if all of the necessary conditions are satisfied.\n\tCheck these conditions, and return 0 if it's appropriate to let the PM\n\tcore queue a suspend request for the device.\n\n Several device power state transitions are externally visible, affecting\n the state of pending I/O queues and (for drivers that touch hardware)\n interrupts, wakeups, DMA, and other hardware state.  There may also be\n internal transitions to various low-power modes which are transparent\n to the rest of the driver stack (such as a driver that's ON gating off\n clocks which are not in active use).\n\n The externally visible transitions are handled with the help of callbacks\n included in this structure in such a way that, typically, two levels of\n callbacks are involved.  First, the PM core executes callbacks provided by PM\n domains, device types, classes and bus types.  They are the subsystem-level\n callbacks expected to execute callbacks provided by device drivers, although\n they may choose not to do that.  If the driver callbacks are executed, they\n have to collaborate with the subsystem-level callbacks to achieve the goals\n appropriate for the given system transition, given transition phase and the\n subsystem the device belongs to.\n\n All of the above callbacks, except for @complete(), return error codes.\n However, the error codes returned by @resume(), @thaw(), @restore(),\n @resume_noirq(), @thaw_noirq(), and @restore_noirq(), do not cause the PM\n core to abort the resume transition during which they are returned.  The\n error codes returned in those cases are only printed to the system logs for\n debugging purposes.  Still, it is recommended that drivers only return error\n codes from their resume methods in case of an unrecoverable failure (i.e.\n when the device being handled refuses to resume and becomes unusable) to\n allow the PM core to be modified in the future, so that it can avoid\n attempting to handle devices that failed to resume and their children.\n\n It is allowed to unregister devices while the above callbacks are being\n executed.  However, a callback routine MUST NOT try to unregister the device\n it was called for, although it may unregister children of that device (for\n example, if it detects that a child was unplugged while the system was\n asleep).\n\n There also are callbacks related to runtime power management of devices.\n Again, as a rule these callbacks are executed by the PM core for subsystems\n (PM domains, device types, classes and bus types) and the subsystem-level\n callbacks are expected to invoke the driver callbacks.  Moreover, the exact\n actions to be performed by a device driver's callbacks generally depend on\n the platform and subsystem the device belongs to.\n\n Refer to Documentation/power/runtime_pm.rst for more information about the\n role of the @runtime_suspend(), @runtime_resume() and @runtime_idle()\n callbacks in device runtime power management."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_ops {
    pub prepare: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub freeze: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub thaw: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub poweroff:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub restore: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub suspend_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub resume_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub freeze_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub thaw_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub poweroff_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub restore_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub suspend_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub resume_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub freeze_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub thaw_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub poweroff_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub restore_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub runtime_suspend:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub runtime_resume:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub runtime_idle:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
}
#[repr(i32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpm_status {
    RPM_INVALID = -1,
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wake_irq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_subsys_data {
    pub lock: spinlock_t,
    pub refcount: core::ffi::c_uint,
    pub clock_op_might_sleep: core::ffi::c_uint,
    pub clock_mutex: mutex,
    pub clock_list: list_head,
}
impl Default for pm_subsys_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_info {
    pub power_state: pm_message_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub driver_flags: u32_,
    pub lock: spinlock_t,
    pub entry: list_head,
    pub completion: completion,
    pub wakeup: *mut wakeup_source,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub suspend_timer: hrtimer,
    pub timer_expires: u64_,
    pub work: work_struct,
    pub wait_queue: wait_queue_head_t,
    pub wakeirq: *mut wake_irq,
    pub usage_count: atomic_t,
    pub child_count: atomic_t,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub links_count: core::ffi::c_uint,
    pub request: rpm_request,
    pub runtime_status: rpm_status,
    pub last_status: rpm_status,
    pub runtime_error: core::ffi::c_int,
    pub autosuspend_delay: core::ffi::c_int,
    pub last_busy: u64_,
    pub active_time: u64_,
    pub suspended_time: u64_,
    pub accounting_timestamp: u64_,
    pub subsys_data: *mut pm_subsys_data,
    pub set_latency_tolerance:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: s32)>,
    pub qos: *mut dev_pm_qos,
}
impl Default for dev_pm_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl dev_pm_info {
    #[inline]
    pub fn can_wakeup(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_wakeup(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_suspend(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async_suspend(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dpm_list(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_dpm_list(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_prepared(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_prepared(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_noirq_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_noirq_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_late_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_late_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_pm(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_complete(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_direct_complete(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        can_wakeup: core::ffi::c_uint,
        async_suspend: core::ffi::c_uint,
        in_dpm_list: bool_,
        is_prepared: bool_,
        is_suspended: bool_,
        is_noirq_suspended: bool_,
        is_late_suspended: bool_,
        no_pm: bool_,
        early_init: bool_,
        direct_complete: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_wakeup: u32 = unsafe { ::core::mem::transmute(can_wakeup) };
            can_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let async_suspend: u32 = unsafe { ::core::mem::transmute(async_suspend) };
            async_suspend as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_dpm_list: u8 = unsafe { ::core::mem::transmute(in_dpm_list) };
            in_dpm_list as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_prepared: u8 = unsafe { ::core::mem::transmute(is_prepared) };
            is_prepared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_suspended: u8 = unsafe { ::core::mem::transmute(is_suspended) };
            is_suspended as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_noirq_suspended: u8 = unsafe { ::core::mem::transmute(is_noirq_suspended) };
            is_noirq_suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_late_suspended: u8 = unsafe { ::core::mem::transmute(is_late_suspended) };
            is_late_suspended as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let no_pm: u8 = unsafe { ::core::mem::transmute(no_pm) };
            no_pm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let direct_complete: u8 = unsafe { ::core::mem::transmute(direct_complete) };
            direct_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn wakeup_path(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wakeup_path(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syscore(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syscore(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_pm_callbacks(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm_callbacks(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_in_progress(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_async_in_progress(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn must_resume(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_must_resume(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn may_skip_resume(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_may_skip_resume(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        wakeup_path: bool_,
        syscore: bool_,
        no_pm_callbacks: bool_,
        async_in_progress: bool_,
        must_resume: core::ffi::c_uint,
        may_skip_resume: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wakeup_path: u8 = unsafe { ::core::mem::transmute(wakeup_path) };
            wakeup_path as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syscore: u8 = unsafe { ::core::mem::transmute(syscore) };
            syscore as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_pm_callbacks: u8 = unsafe { ::core::mem::transmute(no_pm_callbacks) };
            no_pm_callbacks as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let async_in_progress: u8 = unsafe { ::core::mem::transmute(async_in_progress) };
            async_in_progress as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let must_resume: u32 = unsafe { ::core::mem::transmute(must_resume) };
            must_resume as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let may_skip_resume: u32 = unsafe { ::core::mem::transmute(may_skip_resume) };
            may_skip_resume as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn disable_depth(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_disable_depth(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn idle_notification(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idle_notification(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_pending(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_pending(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_resume(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_resume(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn needs_force_resume(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_needs_force_resume(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn runtime_auto(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_runtime_auto(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_children(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_children(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_callbacks(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_callbacks(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irq_safe(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_safe(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_autosuspend(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_autosuspend(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_autosuspends(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_autosuspends(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memalloc_noio(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memalloc_noio(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        disable_depth: core::ffi::c_uint,
        idle_notification: core::ffi::c_uint,
        request_pending: core::ffi::c_uint,
        deferred_resume: core::ffi::c_uint,
        needs_force_resume: core::ffi::c_uint,
        runtime_auto: core::ffi::c_uint,
        ignore_children: bool_,
        no_callbacks: core::ffi::c_uint,
        irq_safe: core::ffi::c_uint,
        use_autosuspend: core::ffi::c_uint,
        timer_autosuspends: core::ffi::c_uint,
        memalloc_noio: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let disable_depth: u32 = unsafe { ::core::mem::transmute(disable_depth) };
            disable_depth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let idle_notification: u32 = unsafe { ::core::mem::transmute(idle_notification) };
            idle_notification as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let request_pending: u32 = unsafe { ::core::mem::transmute(request_pending) };
            request_pending as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let deferred_resume: u32 = unsafe { ::core::mem::transmute(deferred_resume) };
            deferred_resume as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let needs_force_resume: u32 = unsafe { ::core::mem::transmute(needs_force_resume) };
            needs_force_resume as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let runtime_auto: u32 = unsafe { ::core::mem::transmute(runtime_auto) };
            runtime_auto as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ignore_children: u8 = unsafe { ::core::mem::transmute(ignore_children) };
            ignore_children as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let no_callbacks: u32 = unsafe { ::core::mem::transmute(no_callbacks) };
            no_callbacks as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let irq_safe: u32 = unsafe { ::core::mem::transmute(irq_safe) };
            irq_safe as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let use_autosuspend: u32 = unsafe { ::core::mem::transmute(use_autosuspend) };
            use_autosuspend as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let timer_autosuspends: u32 = unsafe { ::core::mem::transmute(timer_autosuspends) };
            timer_autosuspends as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let memalloc_noio: u32 = unsafe { ::core::mem::transmute(memalloc_noio) };
            memalloc_noio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " struct dev_pm_domain - power management domain representation.\n\n @ops: Power management operations associated with this domain.\n @start: Called when a user needs to start the device via the domain.\n @detach: Called when removing a device from the domain.\n @activate: Called before executing probe routines for bus types and drivers.\n @sync: Called after successful driver probe.\n @dismiss: Called after unsuccessful driver probe and after driver removal.\n @set_performance_state: Called to request a new performance state.\n\n Power domains provide callbacks that are executed during system suspend,\n hibernation, system resume and during runtime PM transitions instead of\n subsystem-level and driver-level callbacks."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_domain {
    pub ops: dev_pm_ops,
    pub start: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub detach: ::core::option::Option<unsafe extern "C" fn(dev: *mut device, power_off: bool_)>,
    pub activate:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub sync: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub dismiss: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub set_performance_state: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: core::ffi::c_uint) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_handle {
    _unused: [u8; 0],
}
#[doc = " struct bus_type - The bus type of the device\n\n @name:\tThe name of the bus.\n @dev_name:\tUsed for subsystems to enumerate devices like (\"foo%u\", dev->id).\n @bus_groups:\tDefault attributes of the bus.\n @dev_groups:\tDefault attributes of the devices on the bus.\n @drv_groups: Default attributes of the device drivers on the bus.\n @match:\tCalled, perhaps multiple times, whenever a new device or driver\n\t\tis added for this bus. It should return a positive value if the\n\t\tgiven device can be handled by the given driver and zero\n\t\totherwise. It may also return error code if determining that\n\t\tthe driver supports the device is not possible. In case of\n\t\t-EPROBE_DEFER it will queue the device for deferred probing.\n @uevent:\tCalled when a device is added, removed, or a few other things\n\t\tthat generate uevents to add the environment variables.\n @probe:\tCalled when a new device or driver add to this bus, and callback\n\t\tthe specific driver's probe to initial the matched device.\n @sync_state:\tCalled to sync device state to software state after all the\n\t\tstate tracking consumers linked to this device (present at\n\t\tthe time of late_initcall) have successfully bound to a\n\t\tdriver. If the device has no consumers, this function will\n\t\tbe called at late_initcall_sync level. If the device has\n\t\tconsumers that are never bound to a driver, this function\n\t\twill never get called until they do.\n @remove:\tCalled when a device removed from this bus.\n @shutdown:\tCalled at shut-down time to quiesce the device.\n\n @online:\tCalled to put the device back online (after offlining it).\n @offline:\tCalled to put the device offline for hot-removal. May fail.\n\n @suspend:\tCalled when a device on this bus wants to go to sleep mode.\n @resume:\tCalled to bring a device on this bus out of sleep mode.\n @num_vf:\tCalled to find out how many virtual functions a device on this\n\t\tbus supports.\n @dma_configure:\tCalled to setup DMA configuration on a device on\n\t\t\tthis bus.\n @dma_cleanup:\tCalled to cleanup DMA configuration on a device on\n\t\t\tthis bus.\n @pm:\t\tPower management operations of this bus, callback the specific\n\t\tdevice driver's pm-ops.\n @need_parent_lock:\tWhen probing or removing a device on this bus, the\n\t\t\tdevice core should lock the device's parent.\n\n A bus is a channel between the processor and one or more devices. For the\n purposes of the device model, all devices are connected via a bus, even if\n it is an internal, virtual, \"platform\" bus. Buses can plug into each other.\n A USB controller is usually a PCI device, for example. The device model\n represents the actual connections between buses and the devices they control.\n A bus is represented by the bus_type structure. It contains the name, the\n default attributes, the bus' methods, PM operations, and the driver core's\n private data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bus_type {
    pub name: *const core::ffi::c_char,
    pub dev_name: *const core::ffi::c_char,
    pub bus_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub drv_groups: *mut *const attribute_group,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, drv: *mut device_driver) -> core::ffi::c_int,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> core::ffi::c_int,
    >,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub online: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub offline: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> core::ffi::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub num_vf: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub dma_configure:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub dma_cleanup: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub pm: *const dev_pm_ops,
    pub need_parent_lock: bool_,
}
impl Default for bus_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct class - device classes\n @name:\tName of the class.\n @class_groups: Default attributes of this class.\n @dev_groups:\tDefault attributes of the devices that belong to the class.\n @dev_uevent:\tCalled when a device is added, removed from this class, or a\n\t\tfew other things that generate uevents to add the environment\n\t\tvariables.\n @devnode:\tCallback to provide the devtmpfs.\n @class_release: Called to release this class.\n @dev_release: Called to release the device.\n @shutdown_pre: Called at shut-down time before driver shutdown.\n @ns_type:\tCallbacks so sysfs can detemine namespaces.\n @namespace:\tNamespace of the device belongs to this class.\n @get_ownership: Allows class to specify uid/gid of the sysfs directories\n\t\tfor the devices belonging to the class. Usually tied to\n\t\tdevice's namespace.\n @pm:\t\tThe default device power management operations of this class.\n\n A class is a higher-level view of a device that abstracts out low-level\n implementation details. Drivers may see a SCSI disk or an ATA disk, but,\n at the class level, they are all simply disks. Classes allow user space\n to work with devices based on what they do, rather than how they are\n connected or how they work."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class {
    pub name: *const core::ffi::c_char,
    pub class_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub dev_uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> core::ffi::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, mode: *mut umode_t) -> *mut core::ffi::c_char,
    >,
    pub class_release: ::core::option::Option<unsafe extern "C" fn(class: *const class)>,
    pub dev_release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub shutdown_pre:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub ns_type: *const kobj_ns_type_operations,
    pub namespace: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device) -> *const core::ffi::c_void,
    >,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
    pub pm: *const dev_pm_ops,
}
impl Default for class {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhash_head {
    pub next: *mut rhash_head,
}
impl Default for rhash_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct rhashtable_compare_arg - Key for the function rhashtable_compare\n @ht: Hash table\n @key: Key to compare against"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable_compare_arg {
    pub ht: *mut rhashtable,
    pub key: *const core::ffi::c_void,
}
impl Default for rhashtable_compare_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rht_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(data: *const core::ffi::c_void, len: u32_, seed: u32_) -> u32_,
>;
pub type rht_obj_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(data: *const core::ffi::c_void, len: u32_, seed: u32_) -> u32_,
>;
pub type rht_obj_cmpfn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut rhashtable_compare_arg,
        obj: *const core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[doc = " struct rhashtable_params - Hash table construction parameters\n @nelem_hint: Hint on number of elements, should be 75% of desired size\n @key_len: Length of key\n @key_offset: Offset of key in struct to be hashed\n @head_offset: Offset of rhash_head in struct to be hashed\n @max_size: Maximum size while expanding\n @min_size: Minimum size while shrinking\n @automatic_shrinking: Enable automatic shrinking of tables\n @hashfn: Hash function (default: jhash2 if !(key_len % 4), or jhash)\n @obj_hashfn: Function to hash object\n @obj_cmpfn: Function to compare key with object"]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rhashtable_params {
    pub nelem_hint: u16_,
    pub key_len: u16_,
    pub key_offset: u16_,
    pub head_offset: u16_,
    pub max_size: core::ffi::c_uint,
    pub min_size: u16_,
    pub automatic_shrinking: bool_,
    pub hashfn: rht_hashfn_t,
    pub obj_hashfn: rht_obj_hashfn_t,
    pub obj_cmpfn: rht_obj_cmpfn_t,
}
#[doc = " struct rhashtable - Hash table handle\n @tbl: Bucket table\n @key_len: Key length for hashfn\n @max_elems: Maximum number of elements in table\n @p: Configuration parameters\n @rhlist: True if this is an rhltable\n @run_work: Deferred worker to expand/shrink asynchronously\n @mutex: Mutex to protect current/future table swapping\n @lock: Spin lock to protect walker list\n @nelems: Number of elements in table"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable {
    pub tbl: *mut bucket_table,
    pub key_len: core::ffi::c_uint,
    pub max_elems: core::ffi::c_uint,
    pub p: rhashtable_params,
    pub rhlist: bool_,
    pub run_work: work_struct,
    pub mutex: mutex,
    pub lock: spinlock_t,
    pub nelems: atomic_t,
}
impl Default for rhashtable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut core::ffi::c_void,
    pub iov_len: __kernel_size_t,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvec {
    pub iov_base: *mut core::ffi::c_void,
    pub iov_len: usize,
}
impl Default for kvec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iov_iter {
    pub iter_type: u8_,
    pub copy_mc: bool_,
    pub nofault: bool_,
    pub data_source: bool_,
    pub iov_offset: usize,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1,
    pub __bindgen_anon_2: iov_iter__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_1 {
    pub __ubuf_iovec: iovec,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iov_iter__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub count: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __iov: *const iovec,
    pub kvec: *const kvec,
    pub bvec: *const bio_vec,
    pub xarray: *mut xarray,
    pub ubuf: *mut core::ffi::c_void,
}
impl Default for iov_iter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iov_iter__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iov_iter__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_2 {
    pub nr_segs: core::ffi::c_ulong,
    pub xarray_start: loff_t,
}
impl Default for iov_iter__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iov_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vdso_image {
    pub data: *mut core::ffi::c_void,
    pub size: core::ffi::c_ulong,
    pub alt: core::ffi::c_ulong,
    pub alt_len: core::ffi::c_ulong,
    pub extable_base: core::ffi::c_ulong,
    pub extable_len: core::ffi::c_ulong,
    pub extable: *const core::ffi::c_void,
    pub sym_vvar_start: core::ffi::c_long,
    pub sym_vvar_page: core::ffi::c_long,
    pub sym_pvclock_page: core::ffi::c_long,
    pub sym_hvclock_page: core::ffi::c_long,
    pub sym_timens_page: core::ffi::c_long,
    pub sym_VDSO32_NOTE_MASK: core::ffi::c_long,
    pub sym___kernel_sigreturn: core::ffi::c_long,
    pub sym___kernel_rt_sigreturn: core::ffi::c_long,
    pub sym___kernel_vsyscall: core::ffi::c_long,
    pub sym_int80_landing_pad: core::ffi::c_long,
    pub sym_vdso32_sigreturn_landing_pad: core::ffi::c_long,
    pub sym_vdso32_rt_sigreturn_landing_pad: core::ffi::c_long,
}
impl Default for vdso_image {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Elf64_Addr = __u64;
pub type Elf64_Half = __u16;
pub type Elf64_Word = __u32;
pub type Elf64_Xword = __u64;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_sym {
    pub st_name: Elf64_Word,
    pub st_info: core::ffi::c_uchar,
    pub st_other: core::ffi::c_uchar,
    pub st_shndx: Elf64_Half,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
pub type Elf64_Sym = elf64_sym;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_param {
    pub name: *const core::ffi::c_char,
    pub mod_: *mut module,
    pub ops: *const kernel_param_ops,
    pub perm: u16_,
    pub level: s8,
    pub flags: u8_,
    pub __bindgen_anon_1: kernel_param__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernel_param__bindgen_ty_1 {
    pub arg: *mut core::ffi::c_void,
    pub str_: *const kparam_string,
    pub arr: *const kparam_array,
}
impl Default for kernel_param__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kernel_param {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kparam_string {
    pub maxlen: core::ffi::c_uint,
    pub string: *mut core::ffi::c_char,
}
impl Default for kparam_string {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kparam_array {
    pub max: core::ffi::c_uint,
    pub elemsize: core::ffi::c_uint,
    pub num: *mut core::ffi::c_uint,
    pub ops: *const kernel_param_ops,
    pub elem: *mut core::ffi::c_void,
}
impl Default for kparam_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct latch_tree_node {
    pub node: [rb_node; 2usize],
}
impl Default for latch_tree_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct error_injection_entry {
    pub addr: core::ffi::c_ulong,
    pub etype: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mod_arch_specific {
    pub num_orcs: core::ffi::c_uint,
    pub orc_unwind_ip: *mut core::ffi::c_int,
    pub orc_unwind: *mut orc_entry,
}
impl Default for mod_arch_specific {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_kobject {
    pub kobj: kobject,
    pub mod_: *mut module,
    pub drivers_dir: *mut kobject,
    pub mp: *mut module_param_attrs,
    pub kobj_completion: *mut completion,
}
impl Default for module_kobject {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *mut core::ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
    pub setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut module, arg2: *const core::ffi::c_char),
    >,
    pub test: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module) -> core::ffi::c_int>,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module)>,
}
impl Default for module_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mod_tree_node {
    pub mod_: *mut module,
    pub node: latch_tree_node,
}
impl Default for mod_tree_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_memory {
    pub base: *mut core::ffi::c_void,
    pub size: core::ffi::c_uint,
    pub mtn: mod_tree_node,
}
impl Default for module_memory {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mod_kallsyms {
    pub symtab: *mut Elf64_Sym,
    pub num_symtab: core::ffi::c_uint,
    pub strtab: *mut core::ffi::c_char,
    pub typetab: *mut core::ffi::c_char,
}
impl Default for mod_kallsyms {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " enum probe_type - device driver probe type to try\n\tDevice drivers may opt in for special handling of their\n\trespective probe routines. This tells the core what to\n\texpect and prefer.\n\n @PROBE_DEFAULT_STRATEGY: Used by drivers that work equally well\n\twhether probed synchronously or asynchronously.\n @PROBE_PREFER_ASYNCHRONOUS: Drivers for \"slow\" devices which\n\tprobing order is not essential for booting the system may\n\topt into executing their probes asynchronously.\n @PROBE_FORCE_SYNCHRONOUS: Use this to annotate drivers that need\n\ttheir probe routines to run synchronously with driver and\n\tdevice registration (with the exception of -EPROBE_DEFER\n\thandling - re-probing always ends up being done asynchronously).\n\n Note that the end goal is to switch the kernel to use asynchronous\n probing by default, so annotating drivers with\n %PROBE_PREFER_ASYNCHRONOUS is a temporary measure that allows us\n to speed up boot process while we are validating the rest of the\n drivers."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2,
}
#[doc = " struct device_driver - The basic device driver structure\n @name:\tName of the device driver.\n @bus:\tThe bus which the device of this driver belongs to.\n @owner:\tThe module owner.\n @mod_name:\tUsed for built-in modules.\n @suppress_bind_attrs: Disables bind/unbind via sysfs.\n @probe_type:\tType of the probe (synchronous or asynchronous) to use.\n @of_match_table: The open firmware table.\n @acpi_match_table: The ACPI match table.\n @probe:\tCalled to query the existence of a specific device,\n\t\twhether this driver can work with it, and bind the driver\n\t\tto a specific device.\n @sync_state:\tCalled to sync device state to software state after all the\n\t\tstate tracking consumers linked to this device (present at\n\t\tthe time of late_initcall) have successfully bound to a\n\t\tdriver. If the device has no consumers, this function will\n\t\tbe called at late_initcall_sync level. If the device has\n\t\tconsumers that are never bound to a driver, this function\n\t\twill never get called until they do.\n @remove:\tCalled when the device is removed from the system to\n\t\tunbind a device from this driver.\n @shutdown:\tCalled at shut-down time to quiesce the device.\n @suspend:\tCalled to put the device to sleep mode. Usually to a\n\t\tlow power state.\n @resume:\tCalled to bring a device from sleep mode.\n @groups:\tDefault attributes that get created by the driver core\n\t\tautomatically.\n @dev_groups:\tAdditional attributes attached to device instance once\n\t\tit is bound to the driver.\n @pm:\t\tPower management operations of the device which matched\n\t\tthis driver.\n @coredump:\tCalled when sysfs entry is written to. The device driver\n\t\tis expected to call the dev_coredump API resulting in a\n\t\tuevent.\n @p:\t\tDriver core's private data, no one other than the driver\n\t\tcore can touch this.\n\n The device driver-model tracks all of the drivers known to the system.\n The main reason for this tracking is to enable the driver core to match\n up drivers with new devices. Once drivers are known objects within the\n system, however, a number of other things become possible. Device drivers\n can export information and configuration variables that are independent\n of any specific device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_driver {
    pub name: *const core::ffi::c_char,
    pub bus: *const bus_type,
    pub owner: *mut module,
    pub mod_name: *const core::ffi::c_char,
    pub suppress_bind_attrs: bool_,
    pub probe_type: probe_type,
    pub of_match_table: *mut of_device_id,
    pub acpi_match_table: *mut acpi_device_id,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> core::ffi::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub pm: *const dev_pm_ops,
    pub coredump: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub p: *mut driver_private,
}
impl Default for device_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_archdata {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct driver_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pin_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_iommu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_device_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_type {
    pub name: *const core::ffi::c_char,
    pub groups: *mut *const attribute_group,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> core::ffi::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *const device,
            mode: *mut umode_t,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ) -> *mut core::ffi::c_char,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub pm: *const dev_pm_ops,
}
impl Default for device_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct device_dma_parameters {
    pub max_segment_size: core::ffi::c_uint,
    pub min_align_mask: core::ffi::c_uint,
    pub segment_boundary_mask: core::ffi::c_ulong,
}
#[repr(u32)]
#[doc = " enum dl_dev_state - Device driver presence tracking information.\n @DL_DEV_NO_DRIVER: There is no driver attached to the device.\n @DL_DEV_PROBING: A driver is probing.\n @DL_DEV_DRIVER_BOUND: The driver has been bound to the device.\n @DL_DEV_UNBINDING: The driver is unbinding from the device."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum dl_dev_state {
    DL_DEV_NO_DRIVER = 0,
    DL_DEV_PROBING = 1,
    DL_DEV_DRIVER_BOUND = 2,
    DL_DEV_UNBINDING = 3,
}
#[repr(u32)]
#[doc = " enum device_removable - Whether the device is removable. The criteria for a\n device to be classified as removable is determined by its subsystem or bus.\n @DEVICE_REMOVABLE_NOT_SUPPORTED: This attribute is not supported for this\n\t\t\t\t    device (default).\n @DEVICE_REMOVABLE_UNKNOWN:  Device location is Unknown.\n @DEVICE_FIXED: Device is not removable by the user.\n @DEVICE_REMOVABLE: Device is removable by the user."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum device_removable {
    DEVICE_REMOVABLE_NOT_SUPPORTED = 0,
    DEVICE_REMOVABLE_UNKNOWN = 1,
    DEVICE_FIXED = 2,
    DEVICE_REMOVABLE = 3,
}
#[doc = " struct dev_links_info - Device data related to device links.\n @suppliers: List of links to supplier devices.\n @consumers: List of links to consumer devices.\n @defer_sync: Hook to global list of devices that have deferred sync_state.\n @status: Driver status information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_links_info {
    pub suppliers: list_head,
    pub consumers: list_head,
    pub defer_sync: list_head,
    pub status: dl_dev_state,
}
impl Default for dev_links_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct dev_msi_info - Device data related to MSI\n @domain:\tThe MSI interrupt domain associated to the device\n @data:\tPointer to MSI device data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_msi_info {
    pub domain: *mut irq_domain,
    pub data: *mut msi_device_data,
}
impl Default for dev_msi_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " enum device_physical_location_panel - Describes which panel surface of the\n system's housing the device connection point resides on.\n @DEVICE_PANEL_TOP: Device connection point is on the top panel.\n @DEVICE_PANEL_BOTTOM: Device connection point is on the bottom panel.\n @DEVICE_PANEL_LEFT: Device connection point is on the left panel.\n @DEVICE_PANEL_RIGHT: Device connection point is on the right panel.\n @DEVICE_PANEL_FRONT: Device connection point is on the front panel.\n @DEVICE_PANEL_BACK: Device connection point is on the back panel.\n @DEVICE_PANEL_UNKNOWN: The panel with device connection point is unknown."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum device_physical_location_panel {
    DEVICE_PANEL_TOP = 0,
    DEVICE_PANEL_BOTTOM = 1,
    DEVICE_PANEL_LEFT = 2,
    DEVICE_PANEL_RIGHT = 3,
    DEVICE_PANEL_FRONT = 4,
    DEVICE_PANEL_BACK = 5,
    DEVICE_PANEL_UNKNOWN = 6,
}
#[repr(u32)]
#[doc = " enum device_physical_location_vertical_position - Describes vertical\n position of the device connection point on the panel surface.\n @DEVICE_VERT_POS_UPPER: Device connection point is at upper part of panel.\n @DEVICE_VERT_POS_CENTER: Device connection point is at center part of panel.\n @DEVICE_VERT_POS_LOWER: Device connection point is at lower part of panel."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum device_physical_location_vertical_position {
    DEVICE_VERT_POS_UPPER = 0,
    DEVICE_VERT_POS_CENTER = 1,
    DEVICE_VERT_POS_LOWER = 2,
}
#[repr(u32)]
#[doc = " enum device_physical_location_horizontal_position - Describes horizontal\n position of the device connection point on the panel surface.\n @DEVICE_HORI_POS_LEFT: Device connection point is at left part of panel.\n @DEVICE_HORI_POS_CENTER: Device connection point is at center part of panel.\n @DEVICE_HORI_POS_RIGHT: Device connection point is at right part of panel."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum device_physical_location_horizontal_position {
    DEVICE_HORI_POS_LEFT = 0,
    DEVICE_HORI_POS_CENTER = 1,
    DEVICE_HORI_POS_RIGHT = 2,
}
#[doc = " struct device_physical_location - Device data related to physical location\n of the device connection point.\n @panel: Panel surface of the system's housing that the device connection\n         point resides on.\n @vertical_position: Vertical position of the device connection point within\n                     the panel.\n @horizontal_position: Horizontal position of the device connection point\n                       within the panel.\n @dock: Set if the device connection point resides in a docking station or\n        port replicator.\n @lid: Set if this device connection point resides on the lid of laptop\n       system."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_physical_location {
    pub panel: device_physical_location_panel,
    pub vertical_position: device_physical_location_vertical_position,
    pub horizontal_position: device_physical_location_horizontal_position,
    pub dock: bool_,
    pub lid: bool_,
}
impl Default for device_physical_location {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct device - The basic device structure\n @parent:\tThe device's \"parent\" device, the device to which it is attached.\n \t\tIn most cases, a parent device is some sort of bus or host\n \t\tcontroller. If parent is NULL, the device, is a top-level device,\n \t\twhich is not usually what you want.\n @p:\t\tHolds the private data of the driver core portions of the device.\n \t\tSee the comment of the struct device_private for detail.\n @kobj:\tA top-level, abstract class from which other classes are derived.\n @init_name:\tInitial name of the device.\n @type:\tThe type of device.\n \t\tThis identifies the device type and carries type-specific\n \t\tinformation.\n @mutex:\tMutex to synchronize calls to its driver.\n @bus:\tType of bus device is on.\n @driver:\tWhich driver has allocated this\n @platform_data: Platform data specific to the device.\n \t\tExample: For devices on custom boards, as typical of embedded\n \t\tand SOC based hardware, Linux often uses platform_data to point\n \t\tto board-specific structures describing devices and how they\n \t\tare wired.  That can include what ports are available, chip\n \t\tvariants, which GPIO pins act in what additional roles, and so\n \t\ton.  This shrinks the \"Board Support Packages\" (BSPs) and\n \t\tminimizes board-specific #ifdefs in drivers.\n @driver_data: Private pointer for driver specific info.\n @links:\tLinks to suppliers and consumers of this device.\n @power:\tFor device power management.\n\t\tSee Documentation/driver-api/pm/devices.rst for details.\n @pm_domain:\tProvide callbacks that are executed during system suspend,\n \t\thibernation, system resume and during runtime PM transitions\n \t\talong with subsystem-level and driver-level callbacks.\n @em_pd:\tdevice's energy model performance domain\n @pins:\tFor device pin management.\n\t\tSee Documentation/driver-api/pin-control.rst for details.\n @msi:\tMSI related data\n @numa_node:\tNUMA node this device is close to.\n @dma_ops:    DMA mapping operations for this device.\n @dma_mask:\tDma mask (if dma'ble device).\n @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all\n \t\thardware supports 64-bit addresses for consistent allocations\n \t\tsuch descriptors.\n @bus_dma_limit: Limit of an upstream bridge or bus which imposes a smaller\n\t\tDMA limit than the device itself supports.\n @dma_range_map: map for DMA memory ranges relative to that of RAM\n @dma_parms:\tA low level driver may set these to teach IOMMU code about\n \t\tsegment limitations.\n @dma_pools:\tDma pools (if dma'ble device).\n @dma_mem:\tInternal for coherent mem override.\n @cma_area:\tContiguous memory area for dma allocations\n @dma_io_tlb_mem: Software IO TLB allocator.  Not for driver use.\n @dma_io_tlb_pools:\tList of transient swiotlb memory pools.\n @dma_io_tlb_lock:\tProtects changes to the list of active pools.\n @dma_uses_io_tlb: %true if device has used the software IO TLB.\n @archdata:\tFor arch-specific additions.\n @of_node:\tAssociated device tree node.\n @fwnode:\tAssociated device node supplied by platform firmware.\n @devt:\tFor creating the sysfs \"dev\".\n @id:\t\tdevice instance\n @devres_lock: Spinlock to protect the resource of the device.\n @devres_head: The resources list of the device.\n @class:\tThe class of the device.\n @groups:\tOptional attribute groups.\n @release:\tCallback to free the device after all references have\n \t\tgone away. This should be set by the allocator of the\n \t\tdevice (i.e. the bus driver that discovered the device).\n @iommu_group: IOMMU group the device belongs to.\n @iommu:\tPer device generic IOMMU runtime data\n @physical_location: Describes physical location of the device connection\n\t\tpoint in the system housing.\n @removable:  Whether the device can be removed from the system. This\n              should be set by the subsystem / bus driver that discovered\n              the device.\n\n @offline_disabled: If set, the device is permanently online.\n @offline:\tSet after successful invocation of bus type's .offline().\n @of_node_reused: Set if the device-tree node is shared with an ancestor\n              device.\n @state_synced: The hardware state of this device has been synced to match\n\t\t  the software state of this device by calling the driver/bus\n\t\t  sync_state() callback.\n @can_match:\tThe device has matched with a driver at least once or it is in\n\t\ta bus (like AMBA) which can't check for matching drivers until\n\t\tother devices probe successfully.\n @dma_coherent: this particular device is dma coherent, even if the\n\t\tarchitecture supports non-coherent devices.\n @dma_ops_bypass: If set to %true then the dma_ops are bypassed for the\n\t\tstreaming DMA operations (->map_* / ->unmap_* / ->sync_*),\n\t\tand optionall (if the coherent mask is large enough) also\n\t\tfor dma allocations.  This flag is managed by the dma ops\n\t\tinstance from ->dma_supported.\n\n At the lowest level, every device in a Linux system is represented by an\n instance of struct device. The device structure contains the information\n that the device model core needs to model the system. Most subsystems,\n however, track additional information about the devices they host. As a\n result, it is rare for devices to be represented by bare device structures;\n instead, that structure, like kobject structures, is usually embedded within\n a higher-level representation of the device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device {
    pub kobj: kobject,
    pub parent: *mut device,
    pub p: *mut device_private,
    pub init_name: *const core::ffi::c_char,
    pub type_: *const device_type,
    pub bus: *const bus_type,
    pub driver: *mut device_driver,
    pub platform_data: *mut core::ffi::c_void,
    pub driver_data: *mut core::ffi::c_void,
    pub mutex: mutex,
    pub links: dev_links_info,
    pub power: dev_pm_info,
    pub pm_domain: *mut dev_pm_domain,
    pub em_pd: *mut em_perf_domain,
    pub pins: *mut dev_pin_info,
    pub msi: dev_msi_info,
    pub dma_ops: *mut dma_map_ops,
    pub dma_mask: *mut u64_,
    pub coherent_dma_mask: u64_,
    pub bus_dma_limit: u64_,
    pub dma_range_map: *mut bus_dma_region,
    pub dma_parms: *mut device_dma_parameters,
    pub dma_pools: list_head,
    pub cma_area: *mut cma,
    pub dma_io_tlb_mem: *mut io_tlb_mem,
    pub archdata: dev_archdata,
    pub of_node: *mut device_node,
    pub fwnode: *mut fwnode_handle,
    pub numa_node: core::ffi::c_int,
    pub devt: dev_t,
    pub id: u32_,
    pub devres_lock: spinlock_t,
    pub devres_head: list_head,
    pub class: *const class,
    pub groups: *mut *const attribute_group,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub iommu_group: *mut iommu_group,
    pub iommu: *mut dev_iommu,
    pub physical_location: *mut device_physical_location,
    pub removable: device_removable,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl device {
    #[inline]
    pub fn offline_disabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline_disabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offline(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn of_node_reused(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_of_node_reused(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_synced(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_state_synced(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_match(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_match(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        offline_disabled: bool_,
        offline: bool_,
        of_node_reused: bool_,
        state_synced: bool_,
        can_match: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let offline_disabled: u8 = unsafe { ::core::mem::transmute(offline_disabled) };
            offline_disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offline: u8 = unsafe { ::core::mem::transmute(offline) };
            offline as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let of_node_reused: u8 = unsafe { ::core::mem::transmute(of_node_reused) };
            of_node_reused as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_synced: u8 = unsafe { ::core::mem::transmute(state_synced) };
            state_synced as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let can_match: u8 = unsafe { ::core::mem::transmute(can_match) };
            can_match as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " struct wakeup_source - Representation of wakeup sources\n\n @name: Name of the wakeup source\n @id: Wakeup source id\n @entry: Wakeup source list entry\n @lock: Wakeup source lock\n @wakeirq: Optional device specific wakeirq\n @timer: Wakeup timer list\n @timer_expires: Wakeup timer expiration\n @total_time: Total time this wakeup source has been active.\n @max_time: Maximum time this wakeup source has been continuously active.\n @last_time: Monotonic clock when the wakeup source's was touched last time.\n @prevent_sleep_time: Total time this source has been preventing autosleep.\n @event_count: Number of signaled wakeup events.\n @active_count: Number of times the wakeup source was activated.\n @relax_count: Number of times the wakeup source was deactivated.\n @expire_count: Number of times the wakeup source's timeout has expired.\n @wakeup_count: Number of times the wakeup source might abort suspend.\n @dev: Struct device for sysfs statistics about the wakeup source.\n @active: Status of the wakeup source.\n @autosleep_enabled: Autosleep is active, so update @prevent_sleep_time."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wakeup_source {
    pub name: *const core::ffi::c_char,
    pub id: core::ffi::c_int,
    pub entry: list_head,
    pub lock: spinlock_t,
    pub wakeirq: *mut wake_irq,
    pub timer: timer_list,
    pub timer_expires: core::ffi::c_ulong,
    pub total_time: ktime_t,
    pub max_time: ktime_t,
    pub last_time: ktime_t,
    pub start_prevent_time: ktime_t,
    pub prevent_sleep_time: ktime_t,
    pub event_count: core::ffi::c_ulong,
    pub active_count: core::ffi::c_ulong,
    pub relax_count: core::ffi::c_ulong,
    pub expire_count: core::ffi::c_ulong,
    pub wakeup_count: core::ffi::c_ulong,
    pub dev: *mut device,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl Default for wakeup_source {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl wakeup_source {
    #[inline]
    pub fn active(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autosleep_enabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_autosleep_enabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active: bool_,
        autosleep_enabled: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active: u8 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autosleep_enabled: u8 = unsafe { ::core::mem::transmute(autosleep_enabled) };
            autosleep_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_subsys_state {
    _unused: [u8; 0],
}
pub type bio_end_io_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut bio)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_crypt_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct block_device {
    pub bd_start_sect: sector_t,
    pub bd_nr_sectors: sector_t,
    pub bd_disk: *mut gendisk,
    pub bd_queue: *mut request_queue,
    pub bd_stats: *mut disk_stats,
    pub bd_stamp: core::ffi::c_ulong,
    pub bd_read_only: bool_,
    pub bd_partno: u8_,
    pub bd_write_holder: bool_,
    pub bd_has_submit_bio: bool_,
    pub bd_dev: dev_t,
    pub bd_inode: *mut inode,
    pub bd_openers: atomic_t,
    pub bd_size_lock: spinlock_t,
    pub bd_claiming: *mut core::ffi::c_void,
    pub bd_holder: *mut core::ffi::c_void,
    pub bd_holder_ops: *const blk_holder_ops,
    pub bd_holder_lock: mutex,
    pub bd_holders: core::ffi::c_int,
    pub bd_holder_dir: *mut kobject,
    pub bd_fsfreeze_count: atomic_t,
    pub bd_fsfreeze_mutex: mutex,
    pub bd_meta_info: *mut partition_meta_info,
    pub bd_ro_warned: bool_,
    pub bd_writers: core::ffi::c_int,
    pub bd_device: device,
}
impl Default for block_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type blk_status_t = u8_;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bio_issue {
    pub value: u64_,
}
pub type blk_opf_t = __u32;
pub type blk_qc_t = core::ffi::c_uint;
#[repr(C)]
pub struct bio {
    pub bi_next: *mut bio,
    pub bi_bdev: *mut block_device,
    pub bi_opf: blk_opf_t,
    pub bi_flags: core::ffi::c_ushort,
    pub bi_ioprio: core::ffi::c_ushort,
    pub bi_status: blk_status_t,
    pub __bi_remaining: atomic_t,
    pub bi_iter: bvec_iter,
    pub bi_cookie: blk_qc_t,
    pub bi_end_io: bio_end_io_t,
    pub bi_private: *mut core::ffi::c_void,
    pub bi_blkg: *mut blkcg_gq,
    pub bi_issue: bio_issue,
    pub bi_iocost_cost: u64_,
    pub bi_crypt_context: *mut bio_crypt_ctx,
    pub __bindgen_anon_1: bio__bindgen_ty_1,
    pub bi_vcnt: core::ffi::c_ushort,
    pub bi_max_vecs: core::ffi::c_ushort,
    pub __bi_cnt: atomic_t,
    pub bi_io_vec: *mut bio_vec,
    pub bi_pool: *mut bio_set,
    pub bi_inline_vecs: __IncompleteArrayField<bio_vec>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bio__bindgen_ty_1 {
    pub bi_integrity: *mut bio_integrity_payload,
}
impl Default for bio__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct bio_integrity_payload {
    pub bip_bio: *mut bio,
    pub bip_iter: bvec_iter,
    pub bip_vcnt: core::ffi::c_ushort,
    pub bip_max_vcnt: core::ffi::c_ushort,
    pub bip_flags: core::ffi::c_ushort,
    pub bio_iter: bvec_iter,
    pub bip_work: work_struct,
    pub bip_vec: *mut bio_vec,
    pub bip_inline_vecs: __IncompleteArrayField<bio_vec>,
}
impl Default for bio_integrity_payload {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_set {
    pub bio_slab: *mut kmem_cache,
    pub front_pad: core::ffi::c_uint,
    pub cache: *mut bio_alloc_cache,
    pub bio_pool: mempool_t,
    pub bvec_pool: mempool_t,
    pub bio_integrity_pool: mempool_t,
    pub bvec_integrity_pool: mempool_t,
    pub back_pad: core::ffi::c_uint,
    pub rescue_lock: spinlock_t,
    pub rescue_list: bio_list,
    pub rescue_work: work_struct,
    pub rescue_workqueue: *mut workqueue_struct,
    pub cpuhp_dead: hlist_node,
}
impl Default for bio_set {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_list {
    pub head: *mut bio,
    pub tail: *mut bio,
}
impl Default for bio_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct closure_syncer {
    _unused: [u8; 0],
}
pub type closure_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut work_struct)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct closure_waitlist {
    pub list: llist_head,
}
impl Default for closure_waitlist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct closure {
    pub __bindgen_anon_1: closure__bindgen_ty_1,
    pub parent: *mut closure,
    pub remaining: atomic_t,
    pub closure_get_happened: bool_,
    pub magic: core::ffi::c_uint,
    pub all: list_head,
    pub ip: core::ffi::c_ulong,
    pub waiting_on: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union closure__bindgen_ty_1 {
    pub __bindgen_anon_1: closure__bindgen_ty_1__bindgen_ty_1,
    pub work: work_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct closure__bindgen_ty_1__bindgen_ty_1 {
    pub wq: *mut workqueue_struct,
    pub s: *mut closure_syncer,
    pub list: llist_node,
    pub fn_: closure_fn,
}
impl Default for closure__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for closure__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for closure {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rhash_lock_head {}
#[doc = " struct bucket_table - Table of hash buckets\n @size: Number of hash buckets\n @nest: Number of bits of first-level nested table.\n @rehash: Current bucket being rehashed\n @hash_rnd: Random seed to fold into hash\n @walkers: List of active walkers\n @rcu: RCU structure for freeing the table\n @future_tbl: Table under construction during rehashing\n @ntbl: Nested table used when out of memory.\n @buckets: size * hash buckets"]
#[repr(C)]
#[repr(align(64))]
pub struct bucket_table {
    pub size: core::ffi::c_uint,
    pub nest: core::ffi::c_uint,
    pub hash_rnd: u32_,
    pub walkers: list_head,
    pub rcu: callback_head,
    pub future_tbl: *mut bucket_table,
    pub dep_map: lockdep_map,
    pub __bindgen_padding_0: u64,
    pub buckets: __IncompleteArrayField<*mut rhash_lock_head>,
}
impl Default for bucket_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct blk_zone - Zone descriptor for BLKREPORTZONE ioctl.\n\n @start: Zone start in 512 B sector units\n @len: Zone length in 512 B sector units\n @wp: Zone write pointer location in 512 B sector units\n @type: see enum blk_zone_type for possible values\n @cond: see enum blk_zone_cond for possible values\n @non_seq: Flag indicating that the zone is using non-sequential resources\n           (for host-aware zoned block devices only).\n @reset: Flag indicating that a zone reset is recommended.\n @resv: Padding for 8B alignment.\n @capacity: Zone usable capacity in 512 B sector units\n @reserved: Padding to 64 B to match the ZBC, ZAC and ZNS defined zone\n            descriptor size.\n\n start, len, capacity and wp use the regular 512 B sector unit, regardless\n of the device logical block size. The overall structure size is 64 B to\n match the ZBC, ZAC and ZNS defined zone descriptor and allow support for\n future additional zone information."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_zone {
    pub start: __u64,
    pub len: __u64,
    pub wp: __u64,
    pub type_: __u8,
    pub cond: __u8,
    pub non_seq: __u8,
    pub reset: __u8,
    pub resv: [__u8; 4usize],
    pub capacity: __u64,
    pub reserved: [__u8; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct elevator_queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_trace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blkcg_gq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_flush_queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pr_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rq_qos {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_queue_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_crypto_profile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct partition_meta_info {
    pub uuid: [core::ffi::c_char; 37usize],
    pub volname: [u8_; 64usize],
}
impl Default for partition_meta_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct disk_events {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct badblocks {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_integrity {
    pub profile: *mut blk_integrity_profile,
    pub flags: core::ffi::c_uchar,
    pub tuple_size: core::ffi::c_uchar,
    pub interval_exp: core::ffi::c_uchar,
    pub tag_size: core::ffi::c_uchar,
}
impl Default for blk_integrity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type blk_mode_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gendisk {
    pub major: core::ffi::c_int,
    pub first_minor: core::ffi::c_int,
    pub minors: core::ffi::c_int,
    pub disk_name: [core::ffi::c_char; 32usize],
    pub events: core::ffi::c_ushort,
    pub event_flags: core::ffi::c_ushort,
    pub part_tbl: xarray,
    pub part0: *mut block_device,
    pub fops: *const block_device_operations,
    pub queue: *mut request_queue,
    pub private_data: *mut core::ffi::c_void,
    pub bio_split: bio_set,
    pub flags: core::ffi::c_int,
    pub state: core::ffi::c_ulong,
    pub open_mutex: mutex,
    pub open_partitions: core::ffi::c_uint,
    pub bdi: *mut backing_dev_info,
    pub queue_kobj: kobject,
    pub slave_dir: *mut kobject,
    pub slave_bdevs: list_head,
    pub random: *mut timer_rand_state,
    pub sync_io: atomic_t,
    pub ev: *mut disk_events,
    pub nr_zones: core::ffi::c_uint,
    pub max_open_zones: core::ffi::c_uint,
    pub max_active_zones: core::ffi::c_uint,
    pub conv_zones_bitmap: *mut core::ffi::c_ulong,
    pub seq_zones_wlock: *mut core::ffi::c_ulong,
    pub cdi: *mut cdrom_device_info,
    pub node_id: core::ffi::c_int,
    pub bb: *mut badblocks,
    pub lockdep_map: lockdep_map,
    pub diskseq: u64_,
    pub open_mode: blk_mode_t,
    pub ia_ranges: *mut blk_independent_access_ranges,
}
impl Default for gendisk {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum blk_bounce {
    BLK_BOUNCE_NONE = 0,
    BLK_BOUNCE_HIGH = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct queue_limits {
    pub bounce: blk_bounce,
    pub seg_boundary_mask: core::ffi::c_ulong,
    pub virt_boundary_mask: core::ffi::c_ulong,
    pub max_hw_sectors: core::ffi::c_uint,
    pub max_dev_sectors: core::ffi::c_uint,
    pub chunk_sectors: core::ffi::c_uint,
    pub max_sectors: core::ffi::c_uint,
    pub max_user_sectors: core::ffi::c_uint,
    pub max_segment_size: core::ffi::c_uint,
    pub physical_block_size: core::ffi::c_uint,
    pub logical_block_size: core::ffi::c_uint,
    pub alignment_offset: core::ffi::c_uint,
    pub io_min: core::ffi::c_uint,
    pub io_opt: core::ffi::c_uint,
    pub max_discard_sectors: core::ffi::c_uint,
    pub max_hw_discard_sectors: core::ffi::c_uint,
    pub max_secure_erase_sectors: core::ffi::c_uint,
    pub max_write_zeroes_sectors: core::ffi::c_uint,
    pub max_zone_append_sectors: core::ffi::c_uint,
    pub discard_granularity: core::ffi::c_uint,
    pub discard_alignment: core::ffi::c_uint,
    pub zone_write_granularity: core::ffi::c_uint,
    pub max_segments: core::ffi::c_ushort,
    pub max_integrity_segments: core::ffi::c_ushort,
    pub max_discard_segments: core::ffi::c_ushort,
    pub misaligned: core::ffi::c_uchar,
    pub discard_misaligned: core::ffi::c_uchar,
    pub raid_partial_stripes_expensive: core::ffi::c_uchar,
    pub zoned: bool_,
    pub dma_alignment: core::ffi::c_uint,
}
impl Default for queue_limits {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type report_zones_cb = ::core::option::Option<
    unsafe extern "C" fn(
        zone: *mut blk_zone,
        idx: core::ffi::c_uint,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_independent_access_range {
    pub kobj: kobject,
    pub sector: sector_t,
    pub nr_sectors: sector_t,
}
impl Default for blk_independent_access_range {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct blk_independent_access_ranges {
    pub kobj: kobject,
    pub sysfs_registered: bool_,
    pub nr_ia_ranges: core::ffi::c_uint,
    pub ia_range: __IncompleteArrayField<blk_independent_access_range>,
}
impl Default for blk_independent_access_ranges {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request_queue {
    pub queuedata: *mut core::ffi::c_void,
    pub elevator: *mut elevator_queue,
    pub mq_ops: *mut blk_mq_ops,
    pub queue_ctx: *mut blk_mq_ctx,
    pub queue_flags: core::ffi::c_ulong,
    pub rq_timeout: core::ffi::c_uint,
    pub queue_depth: core::ffi::c_uint,
    pub refs: refcount_t,
    pub nr_hw_queues: core::ffi::c_uint,
    pub hctx_table: xarray,
    pub q_usage_counter: percpu_ref,
    pub last_merge: *mut request,
    pub queue_lock: spinlock_t,
    pub quiesce_depth: core::ffi::c_int,
    pub disk: *mut gendisk,
    pub mq_kobj: *mut kobject,
    pub limits: queue_limits,
    pub integrity: blk_integrity,
    pub dev: *mut device,
    pub rpm_status: rpm_status,
    pub pm_only: atomic_t,
    pub stats: *mut blk_queue_stats,
    pub rq_qos: *mut rq_qos,
    pub rq_qos_mutex: mutex,
    pub id: core::ffi::c_int,
    pub dma_pad_mask: core::ffi::c_uint,
    pub nr_requests: core::ffi::c_ulong,
    pub crypto_profile: *mut blk_crypto_profile,
    pub crypto_kobject: *mut kobject,
    pub timeout: timer_list,
    pub timeout_work: work_struct,
    pub nr_active_requests_shared_tags: atomic_t,
    pub required_elevator_features: core::ffi::c_uint,
    pub sched_shared_tags: *mut blk_mq_tags,
    pub icq_list: list_head,
    pub blkcg_pols: [core::ffi::c_ulong; 1usize],
    pub root_blkg: *mut blkcg_gq,
    pub blkg_list: list_head,
    pub blkcg_mutex: mutex,
    pub node: core::ffi::c_int,
    pub requeue_lock: spinlock_t,
    pub requeue_list: list_head,
    pub requeue_work: delayed_work,
    pub blk_trace: *mut blk_trace,
    pub fq: *mut blk_flush_queue,
    pub flush_list: list_head,
    pub sysfs_lock: mutex,
    pub sysfs_dir_lock: mutex,
    pub unused_hctx_list: list_head,
    pub unused_hctx_lock: spinlock_t,
    pub mq_freeze_depth: core::ffi::c_int,
    pub td: *mut throtl_data,
    pub callback_head: callback_head,
    pub mq_freeze_wq: wait_queue_head_t,
    pub mq_freeze_lock: mutex,
    pub tag_set: *mut blk_mq_tag_set,
    pub tag_set_list: list_head,
    pub debugfs_dir: *mut dentry,
    pub sched_debugfs_dir: *mut dentry,
    pub rqos_debugfs_dir: *mut dentry,
    pub debugfs_mutex: mutex,
    pub mq_sysfs_init_done: bool_,
}
impl Default for request_queue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum blk_unique_id {
    BLK_UID_T10 = 1,
    BLK_UID_EUI64 = 2,
    BLK_UID_NAA = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct block_device_operations {
    pub submit_bio: ::core::option::Option<unsafe extern "C" fn(bio: *mut bio)>,
    pub poll_bio: ::core::option::Option<
        unsafe extern "C" fn(
            bio: *mut bio,
            iob: *mut io_comp_batch,
            flags: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut gendisk, mode: blk_mode_t) -> core::ffi::c_int,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(disk: *mut gendisk)>,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            bdev: *mut block_device,
            mode: blk_mode_t,
            cmd: core::ffi::c_uint,
            arg: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            bdev: *mut block_device,
            mode: blk_mode_t,
            cmd: core::ffi::c_uint,
            arg: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub check_events: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut gendisk, clearing: core::ffi::c_uint) -> core::ffi::c_uint,
    >,
    pub unlock_native_capacity: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk)>,
    pub getgeo: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: *mut hd_geometry) -> core::ffi::c_int,
    >,
    pub set_read_only: ::core::option::Option<
        unsafe extern "C" fn(bdev: *mut block_device, ro: bool_) -> core::ffi::c_int,
    >,
    pub free_disk: ::core::option::Option<unsafe extern "C" fn(disk: *mut gendisk)>,
    pub swap_slot_free_notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: core::ffi::c_ulong),
    >,
    pub report_zones: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gendisk,
            sector: sector_t,
            nr_zones: core::ffi::c_uint,
            cb: report_zones_cb,
            data: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut gendisk, mode: *mut umode_t) -> *mut core::ffi::c_char,
    >,
    pub get_unique_id: ::core::option::Option<
        unsafe extern "C" fn(
            disk: *mut gendisk,
            id: *mut u8_,
            id_type: blk_unique_id,
        ) -> core::ffi::c_int,
    >,
    pub owner: *mut module,
    pub pr_ops: *const pr_ops,
    pub alternative_gpt_sector: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut gendisk, sector: *mut sector_t) -> core::ffi::c_int,
    >,
}
impl Default for block_device_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_holder_ops {
    pub mark_dead:
        ::core::option::Option<unsafe extern "C" fn(bdev: *mut block_device, surprise: bool_)>,
    pub sync: ::core::option::Option<unsafe extern "C" fn(bdev: *mut block_device)>,
    pub freeze:
        ::core::option::Option<unsafe extern "C" fn(bdev: *mut block_device) -> core::ffi::c_int>,
    pub thaw:
        ::core::option::Option<unsafe extern "C" fn(bdev: *mut block_device) -> core::ffi::c_int>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bdev_handle {
    pub bdev: *mut block_device,
    pub holder: *mut core::ffi::c_void,
    pub mode: blk_mode_t,
}
impl Default for bdev_handle {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_comp_batch {
    pub req_list: *mut request,
    pub need_ts: bool_,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_comp_batch)>,
}
impl Default for io_comp_batch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Default, Copy, Clone)]
pub struct u128_u {
    pub v: u128,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Default, Copy, Clone)]
pub struct mean_and_variance {
    pub n: s64,
    pub sum: s64,
    pub sum_squares: u128_u,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mean_and_variance_weighted {
    pub init: bool_,
    pub weight: u8_,
    pub mean: s64,
    pub variance: u64_,
}
#[repr(C)]
pub struct darray_char {
    pub nr: usize,
    pub size: usize,
    pub data: *mut core::ffi::c_char,
    pub preallocated: __IncompleteArrayField<core::ffi::c_char>,
}
impl Default for darray_char {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct darray_str {
    pub nr: usize,
    pub size: usize,
    pub data: *mut *mut core::ffi::c_char,
    pub preallocated: __IncompleteArrayField<*mut core::ffi::c_char>,
}
impl Default for darray_str {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __bch2_darray_resize(
        arg1: *mut darray_char,
        arg2: usize,
        arg3: usize,
        arg4: gfp_t,
    ) -> core::ffi::c_int;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum printbuf_si {
    PRINTBUF_UNITS_2 = 0,
    PRINTBUF_UNITS_10 = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct printbuf {
    pub buf: *mut core::ffi::c_char,
    pub size: core::ffi::c_uint,
    pub pos: core::ffi::c_uint,
    pub last_newline: core::ffi::c_uint,
    pub last_field: core::ffi::c_uint,
    pub indent: core::ffi::c_uint,
    pub atomic: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub nr_tabstops: u8_,
    pub cur_tabstop: u8_,
    pub _tabstops: [u8_; 6usize],
}
impl Default for printbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl printbuf {
    #[inline]
    pub fn allocation_failure(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allocation_failure(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn heap_allocated(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_heap_allocated(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn si_units(&self) -> printbuf_si {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_si_units(&mut self, val: printbuf_si) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn human_readable_units(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_human_readable_units(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_indent_or_tabstops(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_has_indent_or_tabstops(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn suppress_indent_tabstop_handling(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_suppress_indent_tabstop_handling(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        allocation_failure: bool_,
        heap_allocated: bool_,
        si_units: printbuf_si,
        human_readable_units: bool_,
        has_indent_or_tabstops: bool_,
        suppress_indent_tabstop_handling: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let allocation_failure: u8 = unsafe { ::core::mem::transmute(allocation_failure) };
            allocation_failure as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let heap_allocated: u8 = unsafe { ::core::mem::transmute(heap_allocated) };
            heap_allocated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let si_units: u32 = unsafe { ::core::mem::transmute(si_units) };
            si_units as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let human_readable_units: u8 = unsafe { ::core::mem::transmute(human_readable_units) };
            human_readable_units as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_indent_or_tabstops: u8 =
                unsafe { ::core::mem::transmute(has_indent_or_tabstops) };
            has_indent_or_tabstops as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let suppress_indent_tabstop_handling: u8 =
                unsafe { ::core::mem::transmute(suppress_indent_tabstop_handling) };
            suppress_indent_tabstop_handling as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn bch2_printbuf_make_room(
        arg1: *mut printbuf,
        arg2: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_prt_printf(out: *mut printbuf, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn bch2_prt_vprintf(
        out: *mut printbuf,
        fmt: *const core::ffi::c_char,
        arg1: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn bch2_printbuf_str(arg1: *const printbuf) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn bch2_printbuf_exit(arg1: *mut printbuf);
}
extern "C" {
    pub fn bch2_printbuf_tabstops_reset(arg1: *mut printbuf);
}
extern "C" {
    pub fn bch2_printbuf_tabstop_pop(arg1: *mut printbuf);
}
extern "C" {
    pub fn bch2_printbuf_tabstop_push(
        arg1: *mut printbuf,
        arg2: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_printbuf_indent_add(arg1: *mut printbuf, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn bch2_printbuf_indent_sub(arg1: *mut printbuf, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn bch2_prt_newline(arg1: *mut printbuf);
}
extern "C" {
    pub fn bch2_prt_tab(arg1: *mut printbuf);
}
extern "C" {
    pub fn bch2_prt_tab_rjust(arg1: *mut printbuf);
}
extern "C" {
    pub fn bch2_prt_bytes_indented(
        arg1: *mut printbuf,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bch2_prt_human_readable_u64(arg1: *mut printbuf, arg2: u64_);
}
extern "C" {
    pub fn bch2_prt_human_readable_s64(arg1: *mut printbuf, arg2: s64);
}
extern "C" {
    pub fn bch2_prt_units_u64(arg1: *mut printbuf, arg2: u64_);
}
extern "C" {
    pub fn bch2_prt_units_s64(arg1: *mut printbuf, arg2: s64);
}
extern "C" {
    pub fn bch2_prt_string_option(
        arg1: *mut printbuf,
        arg2: *const *const core::ffi::c_char,
        arg3: usize,
    );
}
extern "C" {
    pub fn bch2_prt_bitflags(
        arg1: *mut printbuf,
        arg2: *const *const core::ffi::c_char,
        arg3: u64_,
    );
}
extern "C" {
    pub fn bch2_prt_bitflags_vector(
        arg1: *mut printbuf,
        arg2: *const *const core::ffi::c_char,
        arg3: *mut core::ffi::c_ulong,
        arg4: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bch2_pr_time_units(arg1: *mut printbuf, arg2: u64_);
}
extern "C" {
    pub fn bch2_prt_datetime(arg1: *mut printbuf, arg2: time64_t);
}
extern "C" {
    pub fn bch2_strtoint_h(
        arg1: *const core::ffi::c_char,
        arg2: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_strtouint_h(
        arg1: *const core::ffi::c_char,
        arg2: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_strtoll_h(
        arg1: *const core::ffi::c_char,
        arg2: *mut core::ffi::c_longlong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_strtoull_h(
        arg1: *const core::ffi::c_char,
        arg2: *mut core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_strtou64_h(arg1: *const core::ffi::c_char, arg2: *mut u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_is_zero(arg1: *const core::ffi::c_void, arg2: usize) -> bool_;
}
extern "C" {
    pub fn bch2_read_flag_list(
        arg1: *mut core::ffi::c_char,
        arg2: *const *const core::ffi::c_char,
    ) -> u64_;
}
extern "C" {
    pub fn bch2_prt_u64_base2_nbits(arg1: *mut printbuf, arg2: u64_, arg3: core::ffi::c_uint);
}
extern "C" {
    pub fn bch2_prt_u64_base2(arg1: *mut printbuf, arg2: u64_);
}
extern "C" {
    pub fn bch2_print_string_as_lines(
        prefix: *const core::ffi::c_char,
        lines: *const core::ffi::c_char,
    );
}
#[repr(C)]
pub struct bch_stacktrace {
    pub nr: usize,
    pub size: usize,
    pub data: *mut core::ffi::c_ulong,
    pub preallocated: __IncompleteArrayField<core::ffi::c_ulong>,
}
impl Default for bch_stacktrace {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn bch2_save_backtrace(
        stack: *mut bch_stacktrace,
        arg1: *mut task_struct,
        arg2: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_prt_backtrace(arg1: *mut printbuf, arg2: *mut bch_stacktrace);
}
extern "C" {
    pub fn bch2_prt_task_backtrace(
        arg1: *mut printbuf,
        arg2: *mut task_struct,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch2_quantiles {
    pub entries: [bch2_quantiles_bch2_quantile_entry; 15usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch2_quantiles_bch2_quantile_entry {
    pub m: u64_,
    pub step: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch2_time_stat_buffer {
    pub nr: core::ffi::c_uint,
    pub entries: [bch2_time_stat_buffer_bch2_time_stat_buffer_entry; 32usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch2_time_stat_buffer_bch2_time_stat_buffer_entry {
    pub start: u64_,
    pub end: u64_,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct bch2_time_stats {
    pub lock: spinlock_t,
    pub min_duration: u64_,
    pub max_duration: u64_,
    pub total_duration: u64_,
    pub max_freq: u64_,
    pub min_freq: u64_,
    pub last_event: u64_,
    pub quantiles: bch2_quantiles,
    pub __bindgen_padding_0: u64,
    pub duration_stats: mean_and_variance,
    pub duration_stats_weighted: mean_and_variance_weighted,
    pub __bindgen_padding_1: u64,
    pub freq_stats: mean_and_variance,
    pub freq_stats_weighted: mean_and_variance_weighted,
    pub buffer: *mut bch2_time_stat_buffer,
}
impl Default for bch2_time_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __bch2_time_stats_update(stats: *mut bch2_time_stats, arg1: u64_, arg2: u64_);
}
extern "C" {
    pub fn bch2_time_stats_to_text(arg1: *mut printbuf, arg2: *mut bch2_time_stats);
}
extern "C" {
    pub fn bch2_time_stats_exit(arg1: *mut bch2_time_stats);
}
extern "C" {
    pub fn bch2_time_stats_init(arg1: *mut bch2_time_stats);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_ratelimit {
    pub next: u64_,
    pub rate: core::ffi::c_uint,
}
extern "C" {
    pub fn bch2_ratelimit_delay(arg1: *mut bch_ratelimit) -> u64_;
}
extern "C" {
    pub fn bch2_ratelimit_increment(arg1: *mut bch_ratelimit, arg2: u64_);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_pd_controller {
    pub rate: bch_ratelimit,
    pub last_update: core::ffi::c_ulong,
    pub last_actual: s64,
    pub smoothed_derivative: s64,
    pub p_term_inverse: core::ffi::c_uint,
    pub d_smooth: core::ffi::c_uint,
    pub d_term: core::ffi::c_uint,
    pub last_derivative: s64,
    pub last_proportional: s64,
    pub last_change: s64,
    pub last_target: s64,
    pub backpressure: bool_,
}
extern "C" {
    pub fn bch2_pd_controller_update(
        arg1: *mut bch_pd_controller,
        arg2: s64,
        arg3: s64,
        arg4: core::ffi::c_int,
    );
}
extern "C" {
    pub fn bch2_pd_controller_init(arg1: *mut bch_pd_controller);
}
extern "C" {
    pub fn bch2_pd_controller_debug_to_text(arg1: *mut printbuf, arg2: *mut bch_pd_controller);
}
extern "C" {
    pub fn bch2_bio_map(bio: *mut bio, base: *mut core::ffi::c_void, arg1: usize);
}
extern "C" {
    pub fn bch2_bio_alloc_pages(arg1: *mut bio, arg2: usize, arg3: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_rand_range(arg1: usize) -> usize;
}
extern "C" {
    pub fn bch2_acc_percpu_u64s(arg1: *mut u64_, arg2: core::ffi::c_uint) -> *mut u64_;
}
extern "C" {
    pub fn bch2_darray_str_exit(arg1: *mut darray_str);
}
extern "C" {
    pub fn bch2_split_devs(
        arg1: *const core::ffi::c_char,
        arg2: *mut darray_str,
    ) -> core::ffi::c_int;
}
pub type __uuid_t = uuid_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bkey_format {
    pub key_u64s: __u8,
    pub nr_fields: __u8,
    pub bits_per_field: [__u8; 6usize],
    pub field_offset: [__le64; 6usize],
}
#[repr(C, packed(4))]
#[derive(Default, Copy, Clone)]
pub struct bpos {
    pub snapshot: __u32,
    pub offset: __u64,
    pub inode: __u64,
}
#[repr(C)]
#[derive(Default)]
pub struct bch_val {
    pub __nothing: __IncompleteArrayField<__u64>,
}
#[repr(C, packed(4))]
#[derive(Default, Copy, Clone)]
pub struct bversion {
    pub lo: __u64,
    pub hi: __u32,
}
#[repr(C, packed(8))]
pub struct bkey_packed {
    pub _data: __IncompleteArrayField<__u64>,
    pub u64s: __u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub type_: __u8,
    pub key_start: __IncompleteArrayField<__u8>,
    pub pad: [__u8; 37usize],
}
impl Default for bkey_packed {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bkey_packed {
    #[inline]
    pub fn format(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_format(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn needs_whiteout(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_needs_whiteout(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        format: __u8,
        needs_whiteout: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let format: u8 = unsafe { ::core::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let needs_whiteout: u8 = unsafe { ::core::mem::transmute(needs_whiteout) };
            needs_whiteout as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_le128 {
    pub lo: __le64,
    pub hi: __le64,
}
#[repr(C)]
pub struct bkey_i {
    pub _data: __IncompleteArrayField<__u64>,
    pub k: bkey,
    pub v: bch_val,
}
impl Default for bkey_i {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(8))]
#[derive(Default, Copy, Clone)]
pub struct bch_csum {
    pub lo: __le64,
    pub hi: __le64,
}
#[repr(C)]
#[derive(Default)]
pub struct bch_sb_field {
    pub _data: __IncompleteArrayField<__u64>,
    pub u64s: __le32,
    pub type_: __le32,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct bch_extent_stripe_ptr {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl bch_extent_stripe_ptr {
    #[inline]
    pub fn type_(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_type(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn block(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_block(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn redundancy(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_redundancy(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn idx(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 47u8) as u64) }
    }
    #[inline]
    pub fn set_idx(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 47u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: __u64,
        block: __u64,
        redundancy: __u64,
        idx: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let type_: u64 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 8u8, {
            let block: u64 = unsafe { ::core::mem::transmute(block) };
            block as u64
        });
        __bindgen_bitfield_unit.set(13usize, 4u8, {
            let redundancy: u64 = unsafe { ::core::mem::transmute(redundancy) };
            redundancy as u64
        });
        __bindgen_bitfield_unit.set(17usize, 47u8, {
            let idx: u64 = unsafe { ::core::mem::transmute(idx) };
            idx as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct bch_extent_rebalance {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl bch_extent_rebalance {
    #[inline]
    pub fn type_(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u64) }
    }
    #[inline]
    pub fn set_type(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 34u8) as u64) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 34u8, val as u64)
        }
    }
    #[inline]
    pub fn compression(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_compression(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn target(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_target(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: __u64,
        unused: __u64,
        compression: __u64,
        target: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let type_: u64 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 34u8, {
            let unused: u64 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let compression: u64 = unsafe { ::core::mem::transmute(compression) };
            compression as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let target: u64 = unsafe { ::core::mem::transmute(target) };
            target as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union bch_extent_entry {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
impl Default for bch_extent_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(8))]
pub struct bch_inode_v3 {
    pub v: bch_val,
    pub bi_journal_seq: __le64,
    pub bi_hash_seed: __le64,
    pub bi_flags: __le64,
    pub bi_sectors: __le64,
    pub bi_size: __le64,
    pub bi_version: __le64,
    pub fields: __IncompleteArrayField<__u8>,
}
impl Default for bch_inode_v3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct bch_subvolume {
    pub v: bch_val,
    pub flags: __le32,
    pub snapshot: __le32,
    pub inode: __le64,
    pub parent: __le32,
    pub pad: __le32,
    pub otime: bch_le128,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bch_sb_field_type {
    BCH_SB_FIELD_journal = 0,
    BCH_SB_FIELD_members_v1 = 1,
    BCH_SB_FIELD_crypt = 2,
    BCH_SB_FIELD_replicas_v0 = 3,
    BCH_SB_FIELD_quota = 4,
    BCH_SB_FIELD_disk_groups = 5,
    BCH_SB_FIELD_clean = 6,
    BCH_SB_FIELD_replicas = 7,
    BCH_SB_FIELD_journal_seq_blacklist = 8,
    BCH_SB_FIELD_journal_v2 = 9,
    BCH_SB_FIELD_counters = 10,
    BCH_SB_FIELD_members_v2 = 11,
    BCH_SB_FIELD_errors = 12,
    BCH_SB_FIELD_ext = 13,
    BCH_SB_FIELD_downgrade = 14,
    BCH_SB_FIELD_NR = 15,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bch_member_error_type {
    BCH_MEMBER_ERROR_read = 0,
    BCH_MEMBER_ERROR_write = 1,
    BCH_MEMBER_ERROR_checksum = 2,
    BCH_MEMBER_ERROR_NR = 3,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_member {
    pub uuid: __uuid_t,
    pub nbuckets: __le64,
    pub first_bucket: __le16,
    pub bucket_size: __le16,
    pub pad: __le32,
    pub last_mount: __le64,
    pub flags: __le64,
    pub iops: [__le32; 4usize],
    pub errors: [__le64; 3usize],
    pub errors_at_reset: [__le64; 3usize],
    pub errors_reset_time: __le64,
    pub seq: __le64,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bch_member_state {
    BCH_MEMBER_STATE_rw = 0,
    BCH_MEMBER_STATE_ro = 1,
    BCH_MEMBER_STATE_failed = 2,
    BCH_MEMBER_STATE_spare = 3,
    BCH_MEMBER_STATE_NR = 4,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nonce {
    pub d: [__le32; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_key {
    pub key: [__le64; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_encrypted_key {
    pub magic: __le64,
    pub key: bch_key,
}
#[repr(C)]
#[derive(Default)]
pub struct bch_sb_field_crypt {
    pub field: bch_sb_field,
    pub flags: __le64,
    pub kdf_flags: __le64,
    pub key: bch_encrypted_key,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bch_data_type {
    BCH_DATA_free = 0,
    BCH_DATA_sb = 1,
    BCH_DATA_journal = 2,
    BCH_DATA_btree = 3,
    BCH_DATA_user = 4,
    BCH_DATA_cached = 5,
    BCH_DATA_parity = 6,
    BCH_DATA_stripe = 7,
    BCH_DATA_need_gc_gens = 8,
    BCH_DATA_need_discard = 9,
    BCH_DATA_NR = 10,
}
#[repr(C, packed)]
pub struct bch_replicas_entry_v1 {
    pub data_type: __u8,
    pub nr_devs: __u8,
    pub nr_required: __u8,
    pub devs: __IncompleteArrayField<__u8>,
}
impl Default for bch_replicas_entry_v1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct jset_entry {
    pub u64s: __le16,
    pub btree_id: __u8,
    pub level: __u8,
    pub type_: __u8,
    pub pad: [__u8; 3usize],
    pub start: __IncompleteArrayField<bkey_i>,
    pub _data: __IncompleteArrayField<__u64>,
}
impl Default for jset_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct bch_sb_layout {
    pub magic: __uuid_t,
    pub layout_type: __u8,
    pub sb_max_size_bits: __u8,
    pub nr_superblocks: __u8,
    pub pad: [__u8; 5usize],
    pub sb_offset: [__le64; 61usize],
}
impl Default for bch_sb_layout {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(8))]
pub struct bch_sb {
    pub csum: bch_csum,
    pub version: __le16,
    pub version_min: __le16,
    pub pad: [__le16; 2usize],
    pub magic: __uuid_t,
    pub uuid: __uuid_t,
    pub user_uuid: __uuid_t,
    pub label: [__u8; 32usize],
    pub offset: __le64,
    pub seq: __le64,
    pub block_size: __le16,
    pub dev_idx: __u8,
    pub nr_devices: __u8,
    pub u64s: __le32,
    pub time_base_lo: __le64,
    pub time_base_hi: __le32,
    pub time_precision: __le32,
    pub flags: [__le64; 7usize],
    pub write_time: __le64,
    pub features: [__le64; 2usize],
    pub compat: [__le64; 2usize],
    pub layout: bch_sb_layout,
    pub start: __IncompleteArrayField<bch_sb_field>,
    pub _data: __IncompleteArrayField<__le64>,
}
impl Default for bch_sb {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(8))]
pub struct jset {
    pub csum: bch_csum,
    pub magic: __le64,
    pub seq: __le64,
    pub version: __le32,
    pub flags: __le32,
    pub u64s: __le32,
    pub encrypted_start: __IncompleteArrayField<__u8>,
    pub _read_clock: __le16,
    pub _write_clock: __le16,
    pub last_seq: __le64,
    pub start: __IncompleteArrayField<jset_entry>,
    pub _data: __IncompleteArrayField<__u64>,
}
impl Default for jset {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum btree_id {
    BTREE_ID_extents = 0,
    BTREE_ID_inodes = 1,
    BTREE_ID_dirents = 2,
    BTREE_ID_xattrs = 3,
    BTREE_ID_alloc = 4,
    BTREE_ID_quotas = 5,
    BTREE_ID_stripes = 6,
    BTREE_ID_reflink = 7,
    BTREE_ID_subvolumes = 8,
    BTREE_ID_snapshots = 9,
    BTREE_ID_lru = 10,
    BTREE_ID_freespace = 11,
    BTREE_ID_need_discard = 12,
    BTREE_ID_backpointers = 13,
    BTREE_ID_bucket_gens = 14,
    BTREE_ID_snapshot_trees = 15,
    BTREE_ID_deleted_inodes = 16,
    BTREE_ID_logged_ops = 17,
    BTREE_ID_rebalance_work = 18,
    BTREE_ID_NR = 19,
}
#[repr(C, packed(8))]
pub struct bset {
    pub seq: __le64,
    pub journal_seq: __le64,
    pub flags: __le32,
    pub version: __le16,
    pub u64s: __le16,
    pub start: __IncompleteArrayField<bkey_packed>,
    pub _data: __IncompleteArrayField<__u64>,
}
impl Default for bset {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct btree_node {
    pub csum: bch_csum,
    pub magic: __le64,
    pub flags: __le64,
    pub min_key: bpos,
    pub max_key: bpos,
    pub _ptr: bch_extent_ptr,
    pub format: bkey_format,
    pub __bindgen_anon_1: btree_node__bindgen_ty_1,
}
#[repr(C)]
pub struct btree_node__bindgen_ty_1 {
    pub keys: __BindgenUnionField<bset>,
    pub __bindgen_anon_1: __BindgenUnionField<btree_node__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Default)]
pub struct btree_node__bindgen_ty_1__bindgen_ty_1 {
    pub pad: [__u8; 22usize],
    pub u64s: __le16,
    pub _data: __IncompleteArrayField<__u64>,
}
impl Default for btree_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for btree_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(8))]
pub struct btree_node_entry {
    pub csum: bch_csum,
    pub __bindgen_anon_1: btree_node_entry__bindgen_ty_1,
}
#[repr(C)]
pub struct btree_node_entry__bindgen_ty_1 {
    pub keys: __BindgenUnionField<bset>,
    pub __bindgen_anon_1: __BindgenUnionField<btree_node_entry__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Default)]
pub struct btree_node_entry__bindgen_ty_1__bindgen_ty_1 {
    pub pad: [__u8; 22usize],
    pub u64s: __le16,
    pub _data: __IncompleteArrayField<__u64>,
}
impl Default for btree_node_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for btree_node_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bch_errcode {
    BCH_ERR_START = 2048,
    BCH_ERR_ERANGE_option_too_small = 2049,
    BCH_ERR_ERANGE_option_too_big = 2050,
    BCH_ERR_ENOMEM_stripe_buf = 2051,
    BCH_ERR_ENOMEM_replicas_table = 2052,
    BCH_ERR_ENOMEM_cpu_replicas = 2053,
    BCH_ERR_ENOMEM_replicas_gc = 2054,
    BCH_ERR_ENOMEM_disk_groups_validate = 2055,
    BCH_ERR_ENOMEM_disk_groups_to_cpu = 2056,
    BCH_ERR_ENOMEM_mark_snapshot = 2057,
    BCH_ERR_ENOMEM_mark_stripe = 2058,
    BCH_ERR_ENOMEM_mark_stripe_ptr = 2059,
    BCH_ERR_ENOMEM_btree_key_cache_create = 2060,
    BCH_ERR_ENOMEM_btree_key_cache_fill = 2061,
    BCH_ERR_ENOMEM_btree_key_cache_insert = 2062,
    BCH_ERR_ENOMEM_trans_kmalloc = 2063,
    BCH_ERR_ENOMEM_trans_log_msg = 2064,
    BCH_ERR_ENOMEM_do_encrypt = 2065,
    BCH_ERR_ENOMEM_ec_read_extent = 2066,
    BCH_ERR_ENOMEM_ec_stripe_mem_alloc = 2067,
    BCH_ERR_ENOMEM_ec_new_stripe_alloc = 2068,
    BCH_ERR_ENOMEM_fs_btree_cache_init = 2069,
    BCH_ERR_ENOMEM_fs_btree_key_cache_init = 2070,
    BCH_ERR_ENOMEM_fs_counters_init = 2071,
    BCH_ERR_ENOMEM_fs_btree_write_buffer_init = 2072,
    BCH_ERR_ENOMEM_io_clock_init = 2073,
    BCH_ERR_ENOMEM_blacklist_table_init = 2074,
    BCH_ERR_ENOMEM_sb_realloc_injected = 2075,
    BCH_ERR_ENOMEM_sb_bio_realloc = 2076,
    BCH_ERR_ENOMEM_sb_buf_realloc = 2077,
    BCH_ERR_ENOMEM_sb_journal_validate = 2078,
    BCH_ERR_ENOMEM_sb_journal_v2_validate = 2079,
    BCH_ERR_ENOMEM_journal_entry_add = 2080,
    BCH_ERR_ENOMEM_journal_read_buf_realloc = 2081,
    BCH_ERR_ENOMEM_btree_interior_update_worker_init = 2082,
    BCH_ERR_ENOMEM_btree_interior_update_pool_init = 2083,
    BCH_ERR_ENOMEM_bio_read_init = 2084,
    BCH_ERR_ENOMEM_bio_read_split_init = 2085,
    BCH_ERR_ENOMEM_bio_write_init = 2086,
    BCH_ERR_ENOMEM_bio_bounce_pages_init = 2087,
    BCH_ERR_ENOMEM_writepage_bioset_init = 2088,
    BCH_ERR_ENOMEM_dio_read_bioset_init = 2089,
    BCH_ERR_ENOMEM_dio_write_bioset_init = 2090,
    BCH_ERR_ENOMEM_nocow_flush_bioset_init = 2091,
    BCH_ERR_ENOMEM_promote_table_init = 2092,
    BCH_ERR_ENOMEM_compression_bounce_read_init = 2093,
    BCH_ERR_ENOMEM_compression_bounce_write_init = 2094,
    BCH_ERR_ENOMEM_compression_workspace_init = 2095,
    BCH_ERR_ENOMEM_decompression_workspace_init = 2096,
    BCH_ERR_ENOMEM_bucket_gens = 2097,
    BCH_ERR_ENOMEM_buckets_nouse = 2098,
    BCH_ERR_ENOMEM_usage_init = 2099,
    BCH_ERR_ENOMEM_btree_node_read_all_replicas = 2100,
    BCH_ERR_ENOMEM_btree_node_reclaim = 2101,
    BCH_ERR_ENOMEM_btree_node_mem_alloc = 2102,
    BCH_ERR_ENOMEM_btree_cache_cannibalize_lock = 2103,
    BCH_ERR_ENOMEM_buckets_waiting_for_journal_init = 2104,
    BCH_ERR_ENOMEM_buckets_waiting_for_journal_set = 2105,
    BCH_ERR_ENOMEM_set_nr_journal_buckets = 2106,
    BCH_ERR_ENOMEM_dev_journal_init = 2107,
    BCH_ERR_ENOMEM_journal_pin_fifo = 2108,
    BCH_ERR_ENOMEM_journal_buf = 2109,
    BCH_ERR_ENOMEM_gc_start = 2110,
    BCH_ERR_ENOMEM_gc_alloc_start = 2111,
    BCH_ERR_ENOMEM_gc_reflink_start = 2112,
    BCH_ERR_ENOMEM_gc_gens = 2113,
    BCH_ERR_ENOMEM_gc_repair_key = 2114,
    BCH_ERR_ENOMEM_fsck_extent_ends_at = 2115,
    BCH_ERR_ENOMEM_fsck_add_nlink = 2116,
    BCH_ERR_ENOMEM_journal_key_insert = 2117,
    BCH_ERR_ENOMEM_journal_keys_sort = 2118,
    BCH_ERR_ENOMEM_read_superblock_clean = 2119,
    BCH_ERR_ENOMEM_fs_alloc = 2120,
    BCH_ERR_ENOMEM_fs_name_alloc = 2121,
    BCH_ERR_ENOMEM_fs_other_alloc = 2122,
    BCH_ERR_ENOMEM_dev_alloc = 2123,
    BCH_ERR_ENOSPC_disk_reservation = 2124,
    BCH_ERR_ENOSPC_bucket_alloc = 2125,
    BCH_ERR_ENOSPC_disk_label_add = 2126,
    BCH_ERR_ENOSPC_stripe_create = 2127,
    BCH_ERR_ENOSPC_inode_create = 2128,
    BCH_ERR_ENOSPC_str_hash_create = 2129,
    BCH_ERR_ENOSPC_snapshot_create = 2130,
    BCH_ERR_ENOSPC_subvolume_create = 2131,
    BCH_ERR_ENOSPC_sb = 2132,
    BCH_ERR_ENOSPC_sb_journal = 2133,
    BCH_ERR_ENOSPC_sb_journal_seq_blacklist = 2134,
    BCH_ERR_ENOSPC_sb_quota = 2135,
    BCH_ERR_ENOSPC_sb_replicas = 2136,
    BCH_ERR_ENOSPC_sb_members = 2137,
    BCH_ERR_ENOSPC_sb_members_v2 = 2138,
    BCH_ERR_ENOSPC_sb_crypt = 2139,
    BCH_ERR_ENOSPC_sb_downgrade = 2140,
    BCH_ERR_ENOSPC_btree_slot = 2141,
    BCH_ERR_ENOSPC_snapshot_tree = 2142,
    BCH_ERR_ENOENT_bkey_type_mismatch = 2143,
    BCH_ERR_ENOENT_str_hash_lookup = 2144,
    BCH_ERR_ENOENT_str_hash_set_must_replace = 2145,
    BCH_ERR_ENOENT_inode = 2146,
    BCH_ERR_ENOENT_not_subvol = 2147,
    BCH_ERR_ENOENT_not_directory = 2148,
    BCH_ERR_ENOENT_directory_dead = 2149,
    BCH_ERR_ENOENT_subvolume = 2150,
    BCH_ERR_ENOENT_snapshot_tree = 2151,
    BCH_ERR_ENOENT_dirent_doesnt_match_inode = 2152,
    BCH_ERR_ENOENT_dev_not_found = 2153,
    BCH_ERR_ENOENT_dev_idx_not_found = 2154,
    BCH_ERR_open_buckets_empty = 2155,
    BCH_ERR_freelist_empty = 2156,
    BCH_ERR_no_buckets_found = 2157,
    BCH_ERR_transaction_restart = 2158,
    BCH_ERR_transaction_restart_fault_inject = 2159,
    BCH_ERR_transaction_restart_relock = 2160,
    BCH_ERR_transaction_restart_relock_path = 2161,
    BCH_ERR_transaction_restart_relock_path_intent = 2162,
    BCH_ERR_transaction_restart_relock_after_fill = 2163,
    BCH_ERR_transaction_restart_too_many_iters = 2164,
    BCH_ERR_transaction_restart_lock_node_reused = 2165,
    BCH_ERR_transaction_restart_fill_relock = 2166,
    BCH_ERR_transaction_restart_fill_mem_alloc_fail = 2167,
    BCH_ERR_transaction_restart_mem_realloced = 2168,
    BCH_ERR_transaction_restart_in_traverse_all = 2169,
    BCH_ERR_transaction_restart_would_deadlock = 2170,
    BCH_ERR_transaction_restart_would_deadlock_write = 2171,
    BCH_ERR_transaction_restart_deadlock_recursion_limit = 2172,
    BCH_ERR_transaction_restart_upgrade = 2173,
    BCH_ERR_transaction_restart_key_cache_upgrade = 2174,
    BCH_ERR_transaction_restart_key_cache_fill = 2175,
    BCH_ERR_transaction_restart_key_cache_raced = 2176,
    BCH_ERR_transaction_restart_key_cache_realloced = 2177,
    BCH_ERR_transaction_restart_journal_preres_get = 2178,
    BCH_ERR_transaction_restart_split_race = 2179,
    BCH_ERR_transaction_restart_write_buffer_flush = 2180,
    BCH_ERR_transaction_restart_nested = 2181,
    BCH_ERR_no_btree_node = 2182,
    BCH_ERR_no_btree_node_relock = 2183,
    BCH_ERR_no_btree_node_upgrade = 2184,
    BCH_ERR_no_btree_node_drop = 2185,
    BCH_ERR_no_btree_node_lock_root = 2186,
    BCH_ERR_no_btree_node_up = 2187,
    BCH_ERR_no_btree_node_down = 2188,
    BCH_ERR_no_btree_node_init = 2189,
    BCH_ERR_no_btree_node_cached = 2190,
    BCH_ERR_no_btree_node_srcu_reset = 2191,
    BCH_ERR_btree_insert_fail = 2192,
    BCH_ERR_btree_insert_btree_node_full = 2193,
    BCH_ERR_btree_insert_need_mark_replicas = 2194,
    BCH_ERR_btree_insert_need_journal_res = 2195,
    BCH_ERR_btree_insert_need_journal_reclaim = 2196,
    BCH_ERR_backpointer_to_overwritten_btree_node = 2197,
    BCH_ERR_lock_fail_root_changed = 2198,
    BCH_ERR_journal_reclaim_would_deadlock = 2199,
    BCH_ERR_fsck = 2200,
    BCH_ERR_fsck_fix = 2201,
    BCH_ERR_fsck_ignore = 2202,
    BCH_ERR_fsck_errors_not_fixed = 2203,
    BCH_ERR_fsck_repair_unimplemented = 2204,
    BCH_ERR_fsck_repair_impossible = 2205,
    BCH_ERR_restart_recovery = 2206,
    BCH_ERR_data_update_done = 2207,
    BCH_ERR_device_state_not_allowed = 2208,
    BCH_ERR_member_info_missing = 2209,
    BCH_ERR_mismatched_block_size = 2210,
    BCH_ERR_block_size_too_small = 2211,
    BCH_ERR_bucket_size_too_small = 2212,
    BCH_ERR_device_size_too_small = 2213,
    BCH_ERR_device_not_a_member_of_filesystem = 2214,
    BCH_ERR_device_has_been_removed = 2215,
    BCH_ERR_device_splitbrain = 2216,
    BCH_ERR_device_already_online = 2217,
    BCH_ERR_insufficient_devices_to_start = 2218,
    BCH_ERR_invalid = 2219,
    BCH_ERR_internal_fsck_err = 2220,
    BCH_ERR_opt_parse_error = 2221,
    BCH_ERR_erofs_trans_commit = 2222,
    BCH_ERR_erofs_no_writes = 2223,
    BCH_ERR_erofs_journal_err = 2224,
    BCH_ERR_erofs_sb_err = 2225,
    BCH_ERR_erofs_unfixed_errors = 2226,
    BCH_ERR_erofs_norecovery = 2227,
    BCH_ERR_erofs_nochanges = 2228,
    BCH_ERR_insufficient_devices = 2229,
    BCH_ERR_operation_blocked = 2230,
    BCH_ERR_btree_cache_cannibalize_lock_blocked = 2231,
    BCH_ERR_journal_res_get_blocked = 2232,
    BCH_ERR_journal_preres_get_blocked = 2233,
    BCH_ERR_bucket_alloc_blocked = 2234,
    BCH_ERR_stripe_alloc_blocked = 2235,
    BCH_ERR_invalid_sb = 2236,
    BCH_ERR_invalid_sb_magic = 2237,
    BCH_ERR_invalid_sb_version = 2238,
    BCH_ERR_invalid_sb_features = 2239,
    BCH_ERR_invalid_sb_too_big = 2240,
    BCH_ERR_invalid_sb_csum_type = 2241,
    BCH_ERR_invalid_sb_csum = 2242,
    BCH_ERR_invalid_sb_block_size = 2243,
    BCH_ERR_invalid_sb_uuid = 2244,
    BCH_ERR_invalid_sb_too_many_members = 2245,
    BCH_ERR_invalid_sb_dev_idx = 2246,
    BCH_ERR_invalid_sb_time_precision = 2247,
    BCH_ERR_invalid_sb_field_size = 2248,
    BCH_ERR_invalid_sb_layout = 2249,
    BCH_ERR_invalid_sb_layout_type = 2250,
    BCH_ERR_invalid_sb_layout_nr_superblocks = 2251,
    BCH_ERR_invalid_sb_layout_superblocks_overlap = 2252,
    BCH_ERR_invalid_sb_members_missing = 2253,
    BCH_ERR_invalid_sb_members = 2254,
    BCH_ERR_invalid_sb_disk_groups = 2255,
    BCH_ERR_invalid_sb_replicas = 2256,
    BCH_ERR_invalid_replicas_entry = 2257,
    BCH_ERR_invalid_sb_journal = 2258,
    BCH_ERR_invalid_sb_journal_seq_blacklist = 2259,
    BCH_ERR_invalid_sb_crypt = 2260,
    BCH_ERR_invalid_sb_clean = 2261,
    BCH_ERR_invalid_sb_quota = 2262,
    BCH_ERR_invalid_sb_errors = 2263,
    BCH_ERR_invalid_sb_opt_compression = 2264,
    BCH_ERR_invalid_sb_ext = 2265,
    BCH_ERR_invalid_sb_downgrade = 2266,
    BCH_ERR_invalid_bkey = 2267,
    BCH_ERR_nocow_lock_blocked = 2268,
    BCH_ERR_btree_node_read_err = 2269,
    BCH_ERR_sb_not_downgraded = 2270,
    BCH_ERR_btree_write_all_failed = 2271,
    BCH_ERR_btree_node_read_err_fixable = 2272,
    BCH_ERR_btree_node_read_err_want_retry = 2273,
    BCH_ERR_btree_node_read_err_must_retry = 2274,
    BCH_ERR_btree_node_read_err_bad_node = 2275,
    BCH_ERR_btree_node_read_err_incompatible = 2276,
    BCH_ERR_nopromote = 2277,
    BCH_ERR_nopromote_may_not = 2278,
    BCH_ERR_nopromote_already_promoted = 2279,
    BCH_ERR_nopromote_unwritten = 2280,
    BCH_ERR_nopromote_congested = 2281,
    BCH_ERR_nopromote_in_flight = 2282,
    BCH_ERR_nopromote_no_writes = 2283,
    BCH_ERR_nopromote_enomem = 2284,
    BCH_ERR_MAX = 2285,
}
extern "C" {
    pub fn bch2_err_str(arg1: core::ffi::c_int) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn __bch2_err_matches(arg1: core::ffi::c_int, arg2: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn __bch2_err_class(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_blk_status_to_str(arg1: blk_status_t) -> *const core::ffi::c_char;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct nocow_lock_bucket {
    pub wait: closure_waitlist,
    pub lock: spinlock_t,
    pub b: [u64_; 4usize],
    pub l: [atomic_t; 4usize],
}
impl Default for nocow_lock_bucket {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct bucket_nocow_lock_table {
    pub l: [nocow_lock_bucket; 1024usize],
}
impl Default for bucket_nocow_lock_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum opt_flags {
    OPT_FS = 1,
    OPT_DEVICE = 2,
    OPT_INODE = 4,
    OPT_FORMAT = 8,
    OPT_MOUNT = 16,
    OPT_RUNTIME = 32,
    OPT_HUMAN_READABLE = 64,
    OPT_MUST_BE_POW_2 = 128,
    OPT_SB_FIELD_SECTORS = 256,
    OPT_SB_FIELD_ILOG2 = 512,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum opt_type {
    BCH_OPT_BOOL = 0,
    BCH_OPT_UINT = 1,
    BCH_OPT_STR = 2,
    BCH_OPT_FN = 3,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_opt_fn {
    pub parse: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bch_fs,
            arg2: *const core::ffi::c_char,
            arg3: *mut u64_,
            arg4: *mut printbuf,
        ) -> core::ffi::c_int,
    >,
    pub to_text: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut printbuf, arg2: *mut bch_fs, arg3: *mut bch_sb, arg4: u64_),
    >,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(arg1: u64_, arg2: *mut printbuf) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_opts {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 9usize]>,
    pub block_size: u16_,
    pub btree_node_size: u32_,
    pub errors: u8_,
    pub metadata_replicas: u8_,
    pub data_replicas: u8_,
    pub metadata_replicas_required: u8_,
    pub data_replicas_required: u8_,
    pub encoded_extent_max: u32_,
    pub metadata_checksum: u8_,
    pub data_checksum: u8_,
    pub compression: u8_,
    pub background_compression: u8_,
    pub str_hash: u8_,
    pub metadata_target: u16_,
    pub foreground_target: u16_,
    pub background_target: u16_,
    pub promote_target: u16_,
    pub erasure_code: u16_,
    pub inodes_32bit: u8_,
    pub shard_inode_numbers: u8_,
    pub inodes_use_key_cache: u8_,
    pub btree_node_mem_ptr_optimization: u8_,
    pub gc_reserve_percent: u8_,
    pub gc_reserve_bytes: u64_,
    pub root_reserve_percent: u8_,
    pub wide_macs: u8_,
    pub inline_data: u8_,
    pub acl: u8_,
    pub usrquota: u8_,
    pub grpquota: u8_,
    pub prjquota: u8_,
    pub degraded: u8_,
    pub very_degraded: u8_,
    pub discard: u8_,
    pub verbose: u8_,
    pub journal_flush_delay: u32_,
    pub journal_flush_disabled: u8_,
    pub journal_reclaim_delay: u32_,
    pub move_bytes_in_flight: u32_,
    pub move_ios_in_flight: u32_,
    pub fsck: u8_,
    pub fix_errors: u8_,
    pub ratelimit_errors: u8_,
    pub nochanges: u8_,
    pub norecovery: u8_,
    pub keep_journal: u8_,
    pub read_entire_journal: u8_,
    pub read_journal_only: u8_,
    pub journal_transaction_names: u8_,
    pub noexcl: u8_,
    pub direct_io: u8_,
    pub sb: u64_,
    pub read_only: u8_,
    pub nostart: u8_,
    pub reconstruct_alloc: u8_,
    pub version_upgrade: u8_,
    pub buckets_nouse: u8_,
    pub stdio: u64_,
    pub project: u8_,
    pub nocow: u8_,
    pub nocow_enabled: u8_,
    pub no_data_io: u8_,
    pub fs_size: u64_,
    pub bucket: u32_,
    pub durability: u8_,
    pub btree_node_prefetch: u8_,
}
impl bch_opts {
    #[inline]
    pub fn block_size_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_block_size_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn btree_node_size_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_btree_node_size_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn errors_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_errors_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn metadata_replicas_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_metadata_replicas_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_replicas_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data_replicas_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn metadata_replicas_required_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_metadata_replicas_required_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_replicas_required_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data_replicas_required_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encoded_extent_max_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_encoded_extent_max_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn metadata_checksum_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_metadata_checksum_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_checksum_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data_checksum_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn compression_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compression_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn background_compression_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_background_compression_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn str_hash_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_str_hash_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn metadata_target_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_metadata_target_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn foreground_target_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_foreground_target_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn background_target_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_background_target_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn promote_target_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_promote_target_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn erasure_code_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_erasure_code_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inodes_32bit_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inodes_32bit_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shard_inode_numbers_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shard_inode_numbers_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inodes_use_key_cache_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inodes_use_key_cache_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn btree_node_mem_ptr_optimization_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_btree_node_mem_ptr_optimization_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gc_reserve_percent_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gc_reserve_percent_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gc_reserve_bytes_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gc_reserve_bytes_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn root_reserve_percent_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_root_reserve_percent_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wide_macs_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wide_macs_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inline_data_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inline_data_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acl_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_acl_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usrquota_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usrquota_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn grpquota_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_grpquota_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prjquota_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_prjquota_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn degraded_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_degraded_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn very_degraded_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_very_degraded_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn discard_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_discard_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn verbose_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_verbose_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn journal_flush_delay_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_journal_flush_delay_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn journal_flush_disabled_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_journal_flush_disabled_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn journal_reclaim_delay_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_journal_reclaim_delay_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn move_bytes_in_flight_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_move_bytes_in_flight_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn move_ios_in_flight_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_move_ios_in_flight_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsck_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fsck_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fix_errors_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fix_errors_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ratelimit_errors_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ratelimit_errors_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nochanges_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nochanges_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn norecovery_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_norecovery_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keep_journal_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_journal_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_entire_journal_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read_entire_journal_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_journal_only_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read_journal_only_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn journal_transaction_names_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_journal_transaction_names_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn noexcl_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noexcl_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_io_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_direct_io_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sb_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sb_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_only_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read_only_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nostart_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nostart_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reconstruct_alloc_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reconstruct_alloc_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn version_upgrade_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_version_upgrade_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn buckets_nouse_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_buckets_nouse_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stdio_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stdio_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn project_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_project_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nocow_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nocow_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nocow_enabled_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nocow_enabled_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_data_io_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_data_io_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fs_size_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fs_size_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bucket_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bucket_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn durability_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_durability_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn btree_node_prefetch_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(65usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_btree_node_prefetch_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(65usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        block_size_defined: core::ffi::c_uint,
        btree_node_size_defined: core::ffi::c_uint,
        errors_defined: core::ffi::c_uint,
        metadata_replicas_defined: core::ffi::c_uint,
        data_replicas_defined: core::ffi::c_uint,
        metadata_replicas_required_defined: core::ffi::c_uint,
        data_replicas_required_defined: core::ffi::c_uint,
        encoded_extent_max_defined: core::ffi::c_uint,
        metadata_checksum_defined: core::ffi::c_uint,
        data_checksum_defined: core::ffi::c_uint,
        compression_defined: core::ffi::c_uint,
        background_compression_defined: core::ffi::c_uint,
        str_hash_defined: core::ffi::c_uint,
        metadata_target_defined: core::ffi::c_uint,
        foreground_target_defined: core::ffi::c_uint,
        background_target_defined: core::ffi::c_uint,
        promote_target_defined: core::ffi::c_uint,
        erasure_code_defined: core::ffi::c_uint,
        inodes_32bit_defined: core::ffi::c_uint,
        shard_inode_numbers_defined: core::ffi::c_uint,
        inodes_use_key_cache_defined: core::ffi::c_uint,
        btree_node_mem_ptr_optimization_defined: core::ffi::c_uint,
        gc_reserve_percent_defined: core::ffi::c_uint,
        gc_reserve_bytes_defined: core::ffi::c_uint,
        root_reserve_percent_defined: core::ffi::c_uint,
        wide_macs_defined: core::ffi::c_uint,
        inline_data_defined: core::ffi::c_uint,
        acl_defined: core::ffi::c_uint,
        usrquota_defined: core::ffi::c_uint,
        grpquota_defined: core::ffi::c_uint,
        prjquota_defined: core::ffi::c_uint,
        degraded_defined: core::ffi::c_uint,
        very_degraded_defined: core::ffi::c_uint,
        discard_defined: core::ffi::c_uint,
        verbose_defined: core::ffi::c_uint,
        journal_flush_delay_defined: core::ffi::c_uint,
        journal_flush_disabled_defined: core::ffi::c_uint,
        journal_reclaim_delay_defined: core::ffi::c_uint,
        move_bytes_in_flight_defined: core::ffi::c_uint,
        move_ios_in_flight_defined: core::ffi::c_uint,
        fsck_defined: core::ffi::c_uint,
        fix_errors_defined: core::ffi::c_uint,
        ratelimit_errors_defined: core::ffi::c_uint,
        nochanges_defined: core::ffi::c_uint,
        norecovery_defined: core::ffi::c_uint,
        keep_journal_defined: core::ffi::c_uint,
        read_entire_journal_defined: core::ffi::c_uint,
        read_journal_only_defined: core::ffi::c_uint,
        journal_transaction_names_defined: core::ffi::c_uint,
        noexcl_defined: core::ffi::c_uint,
        direct_io_defined: core::ffi::c_uint,
        sb_defined: core::ffi::c_uint,
        read_only_defined: core::ffi::c_uint,
        nostart_defined: core::ffi::c_uint,
        reconstruct_alloc_defined: core::ffi::c_uint,
        version_upgrade_defined: core::ffi::c_uint,
        buckets_nouse_defined: core::ffi::c_uint,
        stdio_defined: core::ffi::c_uint,
        project_defined: core::ffi::c_uint,
        nocow_defined: core::ffi::c_uint,
        nocow_enabled_defined: core::ffi::c_uint,
        no_data_io_defined: core::ffi::c_uint,
        fs_size_defined: core::ffi::c_uint,
        bucket_defined: core::ffi::c_uint,
        durability_defined: core::ffi::c_uint,
        btree_node_prefetch_defined: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 9usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 9usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let block_size_defined: u32 = unsafe { ::core::mem::transmute(block_size_defined) };
            block_size_defined as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let btree_node_size_defined: u32 =
                unsafe { ::core::mem::transmute(btree_node_size_defined) };
            btree_node_size_defined as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let errors_defined: u32 = unsafe { ::core::mem::transmute(errors_defined) };
            errors_defined as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let metadata_replicas_defined: u32 =
                unsafe { ::core::mem::transmute(metadata_replicas_defined) };
            metadata_replicas_defined as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let data_replicas_defined: u32 =
                unsafe { ::core::mem::transmute(data_replicas_defined) };
            data_replicas_defined as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let metadata_replicas_required_defined: u32 =
                unsafe { ::core::mem::transmute(metadata_replicas_required_defined) };
            metadata_replicas_required_defined as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let data_replicas_required_defined: u32 =
                unsafe { ::core::mem::transmute(data_replicas_required_defined) };
            data_replicas_required_defined as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let encoded_extent_max_defined: u32 =
                unsafe { ::core::mem::transmute(encoded_extent_max_defined) };
            encoded_extent_max_defined as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let metadata_checksum_defined: u32 =
                unsafe { ::core::mem::transmute(metadata_checksum_defined) };
            metadata_checksum_defined as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let data_checksum_defined: u32 =
                unsafe { ::core::mem::transmute(data_checksum_defined) };
            data_checksum_defined as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let compression_defined: u32 = unsafe { ::core::mem::transmute(compression_defined) };
            compression_defined as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let background_compression_defined: u32 =
                unsafe { ::core::mem::transmute(background_compression_defined) };
            background_compression_defined as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let str_hash_defined: u32 = unsafe { ::core::mem::transmute(str_hash_defined) };
            str_hash_defined as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let metadata_target_defined: u32 =
                unsafe { ::core::mem::transmute(metadata_target_defined) };
            metadata_target_defined as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let foreground_target_defined: u32 =
                unsafe { ::core::mem::transmute(foreground_target_defined) };
            foreground_target_defined as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let background_target_defined: u32 =
                unsafe { ::core::mem::transmute(background_target_defined) };
            background_target_defined as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let promote_target_defined: u32 =
                unsafe { ::core::mem::transmute(promote_target_defined) };
            promote_target_defined as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let erasure_code_defined: u32 = unsafe { ::core::mem::transmute(erasure_code_defined) };
            erasure_code_defined as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let inodes_32bit_defined: u32 = unsafe { ::core::mem::transmute(inodes_32bit_defined) };
            inodes_32bit_defined as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let shard_inode_numbers_defined: u32 =
                unsafe { ::core::mem::transmute(shard_inode_numbers_defined) };
            shard_inode_numbers_defined as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let inodes_use_key_cache_defined: u32 =
                unsafe { ::core::mem::transmute(inodes_use_key_cache_defined) };
            inodes_use_key_cache_defined as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let btree_node_mem_ptr_optimization_defined: u32 =
                unsafe { ::core::mem::transmute(btree_node_mem_ptr_optimization_defined) };
            btree_node_mem_ptr_optimization_defined as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let gc_reserve_percent_defined: u32 =
                unsafe { ::core::mem::transmute(gc_reserve_percent_defined) };
            gc_reserve_percent_defined as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let gc_reserve_bytes_defined: u32 =
                unsafe { ::core::mem::transmute(gc_reserve_bytes_defined) };
            gc_reserve_bytes_defined as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let root_reserve_percent_defined: u32 =
                unsafe { ::core::mem::transmute(root_reserve_percent_defined) };
            root_reserve_percent_defined as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let wide_macs_defined: u32 = unsafe { ::core::mem::transmute(wide_macs_defined) };
            wide_macs_defined as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let inline_data_defined: u32 = unsafe { ::core::mem::transmute(inline_data_defined) };
            inline_data_defined as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let acl_defined: u32 = unsafe { ::core::mem::transmute(acl_defined) };
            acl_defined as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let usrquota_defined: u32 = unsafe { ::core::mem::transmute(usrquota_defined) };
            usrquota_defined as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let grpquota_defined: u32 = unsafe { ::core::mem::transmute(grpquota_defined) };
            grpquota_defined as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let prjquota_defined: u32 = unsafe { ::core::mem::transmute(prjquota_defined) };
            prjquota_defined as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let degraded_defined: u32 = unsafe { ::core::mem::transmute(degraded_defined) };
            degraded_defined as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let very_degraded_defined: u32 =
                unsafe { ::core::mem::transmute(very_degraded_defined) };
            very_degraded_defined as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let discard_defined: u32 = unsafe { ::core::mem::transmute(discard_defined) };
            discard_defined as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let verbose_defined: u32 = unsafe { ::core::mem::transmute(verbose_defined) };
            verbose_defined as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let journal_flush_delay_defined: u32 =
                unsafe { ::core::mem::transmute(journal_flush_delay_defined) };
            journal_flush_delay_defined as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let journal_flush_disabled_defined: u32 =
                unsafe { ::core::mem::transmute(journal_flush_disabled_defined) };
            journal_flush_disabled_defined as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let journal_reclaim_delay_defined: u32 =
                unsafe { ::core::mem::transmute(journal_reclaim_delay_defined) };
            journal_reclaim_delay_defined as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let move_bytes_in_flight_defined: u32 =
                unsafe { ::core::mem::transmute(move_bytes_in_flight_defined) };
            move_bytes_in_flight_defined as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let move_ios_in_flight_defined: u32 =
                unsafe { ::core::mem::transmute(move_ios_in_flight_defined) };
            move_ios_in_flight_defined as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let fsck_defined: u32 = unsafe { ::core::mem::transmute(fsck_defined) };
            fsck_defined as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let fix_errors_defined: u32 = unsafe { ::core::mem::transmute(fix_errors_defined) };
            fix_errors_defined as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let ratelimit_errors_defined: u32 =
                unsafe { ::core::mem::transmute(ratelimit_errors_defined) };
            ratelimit_errors_defined as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let nochanges_defined: u32 = unsafe { ::core::mem::transmute(nochanges_defined) };
            nochanges_defined as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let norecovery_defined: u32 = unsafe { ::core::mem::transmute(norecovery_defined) };
            norecovery_defined as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let keep_journal_defined: u32 = unsafe { ::core::mem::transmute(keep_journal_defined) };
            keep_journal_defined as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let read_entire_journal_defined: u32 =
                unsafe { ::core::mem::transmute(read_entire_journal_defined) };
            read_entire_journal_defined as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let read_journal_only_defined: u32 =
                unsafe { ::core::mem::transmute(read_journal_only_defined) };
            read_journal_only_defined as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let journal_transaction_names_defined: u32 =
                unsafe { ::core::mem::transmute(journal_transaction_names_defined) };
            journal_transaction_names_defined as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let noexcl_defined: u32 = unsafe { ::core::mem::transmute(noexcl_defined) };
            noexcl_defined as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let direct_io_defined: u32 = unsafe { ::core::mem::transmute(direct_io_defined) };
            direct_io_defined as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let sb_defined: u32 = unsafe { ::core::mem::transmute(sb_defined) };
            sb_defined as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let read_only_defined: u32 = unsafe { ::core::mem::transmute(read_only_defined) };
            read_only_defined as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let nostart_defined: u32 = unsafe { ::core::mem::transmute(nostart_defined) };
            nostart_defined as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let reconstruct_alloc_defined: u32 =
                unsafe { ::core::mem::transmute(reconstruct_alloc_defined) };
            reconstruct_alloc_defined as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let version_upgrade_defined: u32 =
                unsafe { ::core::mem::transmute(version_upgrade_defined) };
            version_upgrade_defined as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let buckets_nouse_defined: u32 =
                unsafe { ::core::mem::transmute(buckets_nouse_defined) };
            buckets_nouse_defined as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let stdio_defined: u32 = unsafe { ::core::mem::transmute(stdio_defined) };
            stdio_defined as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let project_defined: u32 = unsafe { ::core::mem::transmute(project_defined) };
            project_defined as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let nocow_defined: u32 = unsafe { ::core::mem::transmute(nocow_defined) };
            nocow_defined as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let nocow_enabled_defined: u32 =
                unsafe { ::core::mem::transmute(nocow_enabled_defined) };
            nocow_enabled_defined as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let no_data_io_defined: u32 = unsafe { ::core::mem::transmute(no_data_io_defined) };
            no_data_io_defined as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let fs_size_defined: u32 = unsafe { ::core::mem::transmute(fs_size_defined) };
            fs_size_defined as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let bucket_defined: u32 = unsafe { ::core::mem::transmute(bucket_defined) };
            bucket_defined as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let durability_defined: u32 = unsafe { ::core::mem::transmute(durability_defined) };
            durability_defined as u64
        });
        __bindgen_bitfield_unit.set(65usize, 1u8, {
            let btree_node_prefetch_defined: u32 =
                unsafe { ::core::mem::transmute(btree_node_prefetch_defined) };
            btree_node_prefetch_defined as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn bch2_opts_apply(arg1: *mut bch_opts, arg2: bch_opts);
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bch_opt_id {
    Opt_block_size = 0,
    Opt_btree_node_size = 1,
    Opt_errors = 2,
    Opt_metadata_replicas = 3,
    Opt_data_replicas = 4,
    Opt_metadata_replicas_required = 5,
    Opt_data_replicas_required = 6,
    Opt_encoded_extent_max = 7,
    Opt_metadata_checksum = 8,
    Opt_data_checksum = 9,
    Opt_compression = 10,
    Opt_background_compression = 11,
    Opt_str_hash = 12,
    Opt_metadata_target = 13,
    Opt_foreground_target = 14,
    Opt_background_target = 15,
    Opt_promote_target = 16,
    Opt_erasure_code = 17,
    Opt_inodes_32bit = 18,
    Opt_shard_inode_numbers = 19,
    Opt_inodes_use_key_cache = 20,
    Opt_btree_node_mem_ptr_optimization = 21,
    Opt_gc_reserve_percent = 22,
    Opt_gc_reserve_bytes = 23,
    Opt_root_reserve_percent = 24,
    Opt_wide_macs = 25,
    Opt_inline_data = 26,
    Opt_acl = 27,
    Opt_usrquota = 28,
    Opt_grpquota = 29,
    Opt_prjquota = 30,
    Opt_degraded = 31,
    Opt_very_degraded = 32,
    Opt_discard = 33,
    Opt_verbose = 34,
    Opt_journal_flush_delay = 35,
    Opt_journal_flush_disabled = 36,
    Opt_journal_reclaim_delay = 37,
    Opt_move_bytes_in_flight = 38,
    Opt_move_ios_in_flight = 39,
    Opt_fsck = 40,
    Opt_fix_errors = 41,
    Opt_ratelimit_errors = 42,
    Opt_nochanges = 43,
    Opt_norecovery = 44,
    Opt_keep_journal = 45,
    Opt_read_entire_journal = 46,
    Opt_read_journal_only = 47,
    Opt_journal_transaction_names = 48,
    Opt_noexcl = 49,
    Opt_direct_io = 50,
    Opt_sb = 51,
    Opt_read_only = 52,
    Opt_nostart = 53,
    Opt_reconstruct_alloc = 54,
    Opt_version_upgrade = 55,
    Opt_buckets_nouse = 56,
    Opt_stdio = 57,
    Opt_project = 58,
    Opt_nocow = 59,
    Opt_nocow_enabled = 60,
    Opt_no_data_io = 61,
    Opt_fs_size = 62,
    Opt_bucket = 63,
    Opt_durability = 64,
    Opt_btree_node_prefetch = 65,
    bch2_opts_nr = 66,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bch_option {
    pub attr: attribute,
    pub get_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *const bch_sb) -> u64_>,
    pub set_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bch_sb, arg2: u64_)>,
    pub type_: opt_type,
    pub flags: opt_flags,
    pub min: u64_,
    pub max: u64_,
    pub choices: *const *const core::ffi::c_char,
    pub fn_: bch_opt_fn,
    pub hint: *const core::ffi::c_char,
    pub help: *const core::ffi::c_char,
}
impl Default for bch_option {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn bch2_opt_defined_by_id(arg1: *const bch_opts, arg2: bch_opt_id) -> bool_;
}
extern "C" {
    pub fn bch2_opt_get_by_id(arg1: *const bch_opts, arg2: bch_opt_id) -> u64_;
}
extern "C" {
    pub fn bch2_opt_set_by_id(arg1: *mut bch_opts, arg2: bch_opt_id, arg3: u64_);
}
extern "C" {
    pub fn bch2_opt_from_sb(arg1: *mut bch_sb, arg2: bch_opt_id) -> u64_;
}
extern "C" {
    pub fn bch2_opts_from_sb(arg1: *mut bch_opts, arg2: *mut bch_sb) -> core::ffi::c_int;
}
extern "C" {
    pub fn __bch2_opt_set_sb(arg1: *mut bch_sb, arg2: *const bch_option, arg3: u64_);
}
extern "C" {
    pub fn bch2_opt_set_sb(arg1: *mut bch_fs, arg2: *const bch_option, arg3: u64_);
}
extern "C" {
    pub fn bch2_opt_lookup(arg1: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_opt_validate(
        arg1: *const bch_option,
        arg2: u64_,
        arg3: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_opt_parse(
        arg1: *mut bch_fs,
        arg2: *const bch_option,
        arg3: *const core::ffi::c_char,
        arg4: *mut u64_,
        arg5: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_opt_to_text(
        arg1: *mut printbuf,
        arg2: *mut bch_fs,
        arg3: *mut bch_sb,
        arg4: *const bch_option,
        arg5: u64_,
        arg6: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bch2_opt_check_may_set(
        arg1: *mut bch_fs,
        arg2: core::ffi::c_int,
        arg3: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_opts_check_may_set(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_parse_mount_opts(
        arg1: *mut bch_fs,
        arg2: *mut bch_opts,
        arg3: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_io_opts {
    pub data_checksum: u8_,
    pub compression: u8_,
    pub project: u32_,
    pub background_compression: u8_,
    pub data_replicas: u8_,
    pub promote_target: u16_,
    pub foreground_target: u16_,
    pub background_target: u16_,
    pub erasure_code: u16_,
    pub nocow: u8_,
}
extern "C" {
    pub fn bch2_opts_to_inode_opts(arg1: bch_opts) -> bch_io_opts;
}
extern "C" {
    pub fn bch2_opt_is_inode_opt(arg1: bch_opt_id) -> bool_;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bch_recovery_pass {
    BCH_RECOVERY_PASS_alloc_read = 0,
    BCH_RECOVERY_PASS_stripes_read = 1,
    BCH_RECOVERY_PASS_initialize_subvolumes = 2,
    BCH_RECOVERY_PASS_snapshots_read = 3,
    BCH_RECOVERY_PASS_check_topology = 4,
    BCH_RECOVERY_PASS_check_allocations = 5,
    BCH_RECOVERY_PASS_trans_mark_dev_sbs = 6,
    BCH_RECOVERY_PASS_fs_journal_alloc = 7,
    BCH_RECOVERY_PASS_set_may_go_rw = 8,
    BCH_RECOVERY_PASS_journal_replay = 9,
    BCH_RECOVERY_PASS_check_alloc_info = 10,
    BCH_RECOVERY_PASS_check_lrus = 11,
    BCH_RECOVERY_PASS_check_btree_backpointers = 12,
    BCH_RECOVERY_PASS_check_backpointers_to_extents = 13,
    BCH_RECOVERY_PASS_check_extents_to_backpointers = 14,
    BCH_RECOVERY_PASS_check_alloc_to_lru_refs = 15,
    BCH_RECOVERY_PASS_fs_freespace_init = 16,
    BCH_RECOVERY_PASS_bucket_gens_init = 17,
    BCH_RECOVERY_PASS_check_snapshot_trees = 18,
    BCH_RECOVERY_PASS_check_snapshots = 19,
    BCH_RECOVERY_PASS_check_subvols = 20,
    BCH_RECOVERY_PASS_delete_dead_snapshots = 21,
    BCH_RECOVERY_PASS_fs_upgrade_for_subvolumes = 22,
    BCH_RECOVERY_PASS_resume_logged_ops = 23,
    BCH_RECOVERY_PASS_check_inodes = 24,
    BCH_RECOVERY_PASS_check_extents = 25,
    BCH_RECOVERY_PASS_check_indirect_extents = 26,
    BCH_RECOVERY_PASS_check_dirents = 27,
    BCH_RECOVERY_PASS_check_xattrs = 28,
    BCH_RECOVERY_PASS_check_root = 29,
    BCH_RECOVERY_PASS_check_directory_structure = 30,
    BCH_RECOVERY_PASS_check_nlinks = 31,
    BCH_RECOVERY_PASS_delete_dead_inodes = 32,
    BCH_RECOVERY_PASS_fix_reflink_p = 33,
    BCH_RECOVERY_PASS_set_fs_needs_rebalance = 34,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bch_sb_error_id {
    BCH_FSCK_ERR_clean_but_journal_not_empty = 0,
    BCH_FSCK_ERR_dirty_but_no_journal_entries = 1,
    BCH_FSCK_ERR_dirty_but_no_journal_entries_post_drop_nonflushes = 2,
    BCH_FSCK_ERR_sb_clean_journal_seq_mismatch = 3,
    BCH_FSCK_ERR_sb_clean_btree_root_mismatch = 4,
    BCH_FSCK_ERR_sb_clean_missing = 5,
    BCH_FSCK_ERR_jset_unsupported_version = 6,
    BCH_FSCK_ERR_jset_unknown_csum = 7,
    BCH_FSCK_ERR_jset_last_seq_newer_than_seq = 8,
    BCH_FSCK_ERR_jset_past_bucket_end = 9,
    BCH_FSCK_ERR_jset_seq_blacklisted = 10,
    BCH_FSCK_ERR_journal_entries_missing = 11,
    BCH_FSCK_ERR_journal_entry_replicas_not_marked = 12,
    BCH_FSCK_ERR_journal_entry_past_jset_end = 13,
    BCH_FSCK_ERR_journal_entry_replicas_data_mismatch = 14,
    BCH_FSCK_ERR_journal_entry_bkey_u64s_0 = 15,
    BCH_FSCK_ERR_journal_entry_bkey_past_end = 16,
    BCH_FSCK_ERR_journal_entry_bkey_bad_format = 17,
    BCH_FSCK_ERR_journal_entry_bkey_invalid = 18,
    BCH_FSCK_ERR_journal_entry_btree_root_bad_size = 19,
    BCH_FSCK_ERR_journal_entry_blacklist_bad_size = 20,
    BCH_FSCK_ERR_journal_entry_blacklist_v2_bad_size = 21,
    BCH_FSCK_ERR_journal_entry_blacklist_v2_start_past_end = 22,
    BCH_FSCK_ERR_journal_entry_usage_bad_size = 23,
    BCH_FSCK_ERR_journal_entry_data_usage_bad_size = 24,
    BCH_FSCK_ERR_journal_entry_clock_bad_size = 25,
    BCH_FSCK_ERR_journal_entry_clock_bad_rw = 26,
    BCH_FSCK_ERR_journal_entry_dev_usage_bad_size = 27,
    BCH_FSCK_ERR_journal_entry_dev_usage_bad_dev = 28,
    BCH_FSCK_ERR_journal_entry_dev_usage_bad_pad = 29,
    BCH_FSCK_ERR_btree_node_unreadable = 30,
    BCH_FSCK_ERR_btree_node_fault_injected = 31,
    BCH_FSCK_ERR_btree_node_bad_magic = 32,
    BCH_FSCK_ERR_btree_node_bad_seq = 33,
    BCH_FSCK_ERR_btree_node_unsupported_version = 34,
    BCH_FSCK_ERR_btree_node_bset_older_than_sb_min = 35,
    BCH_FSCK_ERR_btree_node_bset_newer_than_sb = 36,
    BCH_FSCK_ERR_btree_node_data_missing = 37,
    BCH_FSCK_ERR_btree_node_bset_after_end = 38,
    BCH_FSCK_ERR_btree_node_replicas_sectors_written_mismatch = 39,
    BCH_FSCK_ERR_btree_node_replicas_data_mismatch = 40,
    BCH_FSCK_ERR_bset_unknown_csum = 41,
    BCH_FSCK_ERR_bset_bad_csum = 42,
    BCH_FSCK_ERR_bset_past_end_of_btree_node = 43,
    BCH_FSCK_ERR_bset_wrong_sector_offset = 44,
    BCH_FSCK_ERR_bset_empty = 45,
    BCH_FSCK_ERR_bset_bad_seq = 46,
    BCH_FSCK_ERR_bset_blacklisted_journal_seq = 47,
    BCH_FSCK_ERR_first_bset_blacklisted_journal_seq = 48,
    BCH_FSCK_ERR_btree_node_bad_btree = 49,
    BCH_FSCK_ERR_btree_node_bad_level = 50,
    BCH_FSCK_ERR_btree_node_bad_min_key = 51,
    BCH_FSCK_ERR_btree_node_bad_max_key = 52,
    BCH_FSCK_ERR_btree_node_bad_format = 53,
    BCH_FSCK_ERR_btree_node_bkey_past_bset_end = 54,
    BCH_FSCK_ERR_btree_node_bkey_bad_format = 55,
    BCH_FSCK_ERR_btree_node_bad_bkey = 56,
    BCH_FSCK_ERR_btree_node_bkey_out_of_order = 57,
    BCH_FSCK_ERR_btree_root_bkey_invalid = 58,
    BCH_FSCK_ERR_btree_root_read_error = 59,
    BCH_FSCK_ERR_btree_root_bad_min_key = 60,
    BCH_FSCK_ERR_btree_root_bad_max_key = 61,
    BCH_FSCK_ERR_btree_node_read_error = 62,
    BCH_FSCK_ERR_btree_node_topology_bad_min_key = 63,
    BCH_FSCK_ERR_btree_node_topology_bad_max_key = 64,
    BCH_FSCK_ERR_btree_node_topology_overwritten_by_prev_node = 65,
    BCH_FSCK_ERR_btree_node_topology_overwritten_by_next_node = 66,
    BCH_FSCK_ERR_btree_node_topology_interior_node_empty = 67,
    BCH_FSCK_ERR_fs_usage_hidden_wrong = 68,
    BCH_FSCK_ERR_fs_usage_btree_wrong = 69,
    BCH_FSCK_ERR_fs_usage_data_wrong = 70,
    BCH_FSCK_ERR_fs_usage_cached_wrong = 71,
    BCH_FSCK_ERR_fs_usage_reserved_wrong = 72,
    BCH_FSCK_ERR_fs_usage_persistent_reserved_wrong = 73,
    BCH_FSCK_ERR_fs_usage_nr_inodes_wrong = 74,
    BCH_FSCK_ERR_fs_usage_replicas_wrong = 75,
    BCH_FSCK_ERR_dev_usage_buckets_wrong = 76,
    BCH_FSCK_ERR_dev_usage_sectors_wrong = 77,
    BCH_FSCK_ERR_dev_usage_fragmented_wrong = 78,
    BCH_FSCK_ERR_dev_usage_buckets_ec_wrong = 79,
    BCH_FSCK_ERR_bkey_version_in_future = 80,
    BCH_FSCK_ERR_bkey_u64s_too_small = 81,
    BCH_FSCK_ERR_bkey_invalid_type_for_btree = 82,
    BCH_FSCK_ERR_bkey_extent_size_zero = 83,
    BCH_FSCK_ERR_bkey_extent_size_greater_than_offset = 84,
    BCH_FSCK_ERR_bkey_size_nonzero = 85,
    BCH_FSCK_ERR_bkey_snapshot_nonzero = 86,
    BCH_FSCK_ERR_bkey_snapshot_zero = 87,
    BCH_FSCK_ERR_bkey_at_pos_max = 88,
    BCH_FSCK_ERR_bkey_before_start_of_btree_node = 89,
    BCH_FSCK_ERR_bkey_after_end_of_btree_node = 90,
    BCH_FSCK_ERR_bkey_val_size_nonzero = 91,
    BCH_FSCK_ERR_bkey_val_size_too_small = 92,
    BCH_FSCK_ERR_alloc_v1_val_size_bad = 93,
    BCH_FSCK_ERR_alloc_v2_unpack_error = 94,
    BCH_FSCK_ERR_alloc_v3_unpack_error = 95,
    BCH_FSCK_ERR_alloc_v4_val_size_bad = 96,
    BCH_FSCK_ERR_alloc_v4_backpointers_start_bad = 97,
    BCH_FSCK_ERR_alloc_key_data_type_bad = 98,
    BCH_FSCK_ERR_alloc_key_empty_but_have_data = 99,
    BCH_FSCK_ERR_alloc_key_dirty_sectors_0 = 100,
    BCH_FSCK_ERR_alloc_key_data_type_inconsistency = 101,
    BCH_FSCK_ERR_alloc_key_to_missing_dev_bucket = 102,
    BCH_FSCK_ERR_alloc_key_cached_inconsistency = 103,
    BCH_FSCK_ERR_alloc_key_cached_but_read_time_zero = 104,
    BCH_FSCK_ERR_alloc_key_to_missing_lru_entry = 105,
    BCH_FSCK_ERR_alloc_key_data_type_wrong = 106,
    BCH_FSCK_ERR_alloc_key_gen_wrong = 107,
    BCH_FSCK_ERR_alloc_key_dirty_sectors_wrong = 108,
    BCH_FSCK_ERR_alloc_key_cached_sectors_wrong = 109,
    BCH_FSCK_ERR_alloc_key_stripe_wrong = 110,
    BCH_FSCK_ERR_alloc_key_stripe_redundancy_wrong = 111,
    BCH_FSCK_ERR_bucket_sector_count_overflow = 112,
    BCH_FSCK_ERR_bucket_metadata_type_mismatch = 113,
    BCH_FSCK_ERR_need_discard_key_wrong = 114,
    BCH_FSCK_ERR_freespace_key_wrong = 115,
    BCH_FSCK_ERR_freespace_hole_missing = 116,
    BCH_FSCK_ERR_bucket_gens_val_size_bad = 117,
    BCH_FSCK_ERR_bucket_gens_key_wrong = 118,
    BCH_FSCK_ERR_bucket_gens_hole_wrong = 119,
    BCH_FSCK_ERR_bucket_gens_to_invalid_dev = 120,
    BCH_FSCK_ERR_bucket_gens_to_invalid_buckets = 121,
    BCH_FSCK_ERR_bucket_gens_nonzero_for_invalid_buckets = 122,
    BCH_FSCK_ERR_need_discard_freespace_key_to_invalid_dev_bucket = 123,
    BCH_FSCK_ERR_need_discard_freespace_key_bad = 124,
    BCH_FSCK_ERR_backpointer_pos_wrong = 125,
    BCH_FSCK_ERR_backpointer_to_missing_device = 126,
    BCH_FSCK_ERR_backpointer_to_missing_alloc = 127,
    BCH_FSCK_ERR_backpointer_to_missing_ptr = 128,
    BCH_FSCK_ERR_lru_entry_at_time_0 = 129,
    BCH_FSCK_ERR_lru_entry_to_invalid_bucket = 130,
    BCH_FSCK_ERR_lru_entry_bad = 131,
    BCH_FSCK_ERR_btree_ptr_val_too_big = 132,
    BCH_FSCK_ERR_btree_ptr_v2_val_too_big = 133,
    BCH_FSCK_ERR_btree_ptr_has_non_ptr = 134,
    BCH_FSCK_ERR_extent_ptrs_invalid_entry = 135,
    BCH_FSCK_ERR_extent_ptrs_no_ptrs = 136,
    BCH_FSCK_ERR_extent_ptrs_too_many_ptrs = 137,
    BCH_FSCK_ERR_extent_ptrs_redundant_crc = 138,
    BCH_FSCK_ERR_extent_ptrs_redundant_stripe = 139,
    BCH_FSCK_ERR_extent_ptrs_unwritten = 140,
    BCH_FSCK_ERR_extent_ptrs_written_and_unwritten = 141,
    BCH_FSCK_ERR_ptr_to_invalid_device = 142,
    BCH_FSCK_ERR_ptr_to_duplicate_device = 143,
    BCH_FSCK_ERR_ptr_after_last_bucket = 144,
    BCH_FSCK_ERR_ptr_before_first_bucket = 145,
    BCH_FSCK_ERR_ptr_spans_multiple_buckets = 146,
    BCH_FSCK_ERR_ptr_to_missing_backpointer = 147,
    BCH_FSCK_ERR_ptr_to_missing_alloc_key = 148,
    BCH_FSCK_ERR_ptr_to_missing_replicas_entry = 149,
    BCH_FSCK_ERR_ptr_to_missing_stripe = 150,
    BCH_FSCK_ERR_ptr_to_incorrect_stripe = 151,
    BCH_FSCK_ERR_ptr_gen_newer_than_bucket_gen = 152,
    BCH_FSCK_ERR_ptr_too_stale = 153,
    BCH_FSCK_ERR_stale_dirty_ptr = 154,
    BCH_FSCK_ERR_ptr_bucket_data_type_mismatch = 155,
    BCH_FSCK_ERR_ptr_cached_and_erasure_coded = 156,
    BCH_FSCK_ERR_ptr_crc_uncompressed_size_too_small = 157,
    BCH_FSCK_ERR_ptr_crc_csum_type_unknown = 158,
    BCH_FSCK_ERR_ptr_crc_compression_type_unknown = 159,
    BCH_FSCK_ERR_ptr_crc_redundant = 160,
    BCH_FSCK_ERR_ptr_crc_uncompressed_size_too_big = 161,
    BCH_FSCK_ERR_ptr_crc_nonce_mismatch = 162,
    BCH_FSCK_ERR_ptr_stripe_redundant = 163,
    BCH_FSCK_ERR_reservation_key_nr_replicas_invalid = 164,
    BCH_FSCK_ERR_reflink_v_refcount_wrong = 165,
    BCH_FSCK_ERR_reflink_p_to_missing_reflink_v = 166,
    BCH_FSCK_ERR_stripe_pos_bad = 167,
    BCH_FSCK_ERR_stripe_val_size_bad = 168,
    BCH_FSCK_ERR_stripe_sector_count_wrong = 169,
    BCH_FSCK_ERR_snapshot_tree_pos_bad = 170,
    BCH_FSCK_ERR_snapshot_tree_to_missing_snapshot = 171,
    BCH_FSCK_ERR_snapshot_tree_to_missing_subvol = 172,
    BCH_FSCK_ERR_snapshot_tree_to_wrong_subvol = 173,
    BCH_FSCK_ERR_snapshot_tree_to_snapshot_subvol = 174,
    BCH_FSCK_ERR_snapshot_pos_bad = 175,
    BCH_FSCK_ERR_snapshot_parent_bad = 176,
    BCH_FSCK_ERR_snapshot_children_not_normalized = 177,
    BCH_FSCK_ERR_snapshot_child_duplicate = 178,
    BCH_FSCK_ERR_snapshot_child_bad = 179,
    BCH_FSCK_ERR_snapshot_skiplist_not_normalized = 180,
    BCH_FSCK_ERR_snapshot_skiplist_bad = 181,
    BCH_FSCK_ERR_snapshot_should_not_have_subvol = 182,
    BCH_FSCK_ERR_snapshot_to_bad_snapshot_tree = 183,
    BCH_FSCK_ERR_snapshot_bad_depth = 184,
    BCH_FSCK_ERR_snapshot_bad_skiplist = 185,
    BCH_FSCK_ERR_subvol_pos_bad = 186,
    BCH_FSCK_ERR_subvol_not_master_and_not_snapshot = 187,
    BCH_FSCK_ERR_subvol_to_missing_root = 188,
    BCH_FSCK_ERR_subvol_root_wrong_bi_subvol = 189,
    BCH_FSCK_ERR_bkey_in_missing_snapshot = 190,
    BCH_FSCK_ERR_inode_pos_inode_nonzero = 191,
    BCH_FSCK_ERR_inode_pos_blockdev_range = 192,
    BCH_FSCK_ERR_inode_unpack_error = 193,
    BCH_FSCK_ERR_inode_str_hash_invalid = 194,
    BCH_FSCK_ERR_inode_v3_fields_start_bad = 195,
    BCH_FSCK_ERR_inode_snapshot_mismatch = 196,
    BCH_FSCK_ERR_inode_unlinked_but_clean = 197,
    BCH_FSCK_ERR_inode_unlinked_but_nlink_nonzero = 198,
    BCH_FSCK_ERR_inode_checksum_type_invalid = 199,
    BCH_FSCK_ERR_inode_compression_type_invalid = 200,
    BCH_FSCK_ERR_inode_subvol_root_but_not_dir = 201,
    BCH_FSCK_ERR_inode_i_size_dirty_but_clean = 202,
    BCH_FSCK_ERR_inode_i_sectors_dirty_but_clean = 203,
    BCH_FSCK_ERR_inode_i_sectors_wrong = 204,
    BCH_FSCK_ERR_inode_dir_wrong_nlink = 205,
    BCH_FSCK_ERR_inode_dir_multiple_links = 206,
    BCH_FSCK_ERR_inode_multiple_links_but_nlink_0 = 207,
    BCH_FSCK_ERR_inode_wrong_backpointer = 208,
    BCH_FSCK_ERR_inode_wrong_nlink = 209,
    BCH_FSCK_ERR_inode_unreachable = 210,
    BCH_FSCK_ERR_deleted_inode_but_clean = 211,
    BCH_FSCK_ERR_deleted_inode_missing = 212,
    BCH_FSCK_ERR_deleted_inode_is_dir = 213,
    BCH_FSCK_ERR_deleted_inode_not_unlinked = 214,
    BCH_FSCK_ERR_extent_overlapping = 215,
    BCH_FSCK_ERR_extent_in_missing_inode = 216,
    BCH_FSCK_ERR_extent_in_non_reg_inode = 217,
    BCH_FSCK_ERR_extent_past_end_of_inode = 218,
    BCH_FSCK_ERR_dirent_empty_name = 219,
    BCH_FSCK_ERR_dirent_val_too_big = 220,
    BCH_FSCK_ERR_dirent_name_too_long = 221,
    BCH_FSCK_ERR_dirent_name_embedded_nul = 222,
    BCH_FSCK_ERR_dirent_name_dot_or_dotdot = 223,
    BCH_FSCK_ERR_dirent_name_has_slash = 224,
    BCH_FSCK_ERR_dirent_d_type_wrong = 225,
    BCH_FSCK_ERR_dirent_d_parent_subvol_wrong = 226,
    BCH_FSCK_ERR_dirent_in_missing_dir_inode = 227,
    BCH_FSCK_ERR_dirent_in_non_dir_inode = 228,
    BCH_FSCK_ERR_dirent_to_missing_inode = 229,
    BCH_FSCK_ERR_dirent_to_missing_subvol = 230,
    BCH_FSCK_ERR_dirent_to_itself = 231,
    BCH_FSCK_ERR_quota_type_invalid = 232,
    BCH_FSCK_ERR_xattr_val_size_too_small = 233,
    BCH_FSCK_ERR_xattr_val_size_too_big = 234,
    BCH_FSCK_ERR_xattr_invalid_type = 235,
    BCH_FSCK_ERR_xattr_name_invalid_chars = 236,
    BCH_FSCK_ERR_xattr_in_missing_inode = 237,
    BCH_FSCK_ERR_root_subvol_missing = 238,
    BCH_FSCK_ERR_root_dir_missing = 239,
    BCH_FSCK_ERR_root_inode_not_dir = 240,
    BCH_FSCK_ERR_dir_loop = 241,
    BCH_FSCK_ERR_hash_table_key_duplicate = 242,
    BCH_FSCK_ERR_hash_table_key_wrong_offset = 243,
    BCH_FSCK_ERR_unlinked_inode_not_on_deleted_list = 244,
    BCH_FSCK_ERR_reflink_p_front_pad_bad = 245,
    BCH_SB_ERR_MAX = 246,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_sb_error_entry_cpu {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub last_error_time: u64_,
}
impl bch_sb_error_entry_cpu {
    #[inline]
    pub fn id(&self) -> u64_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_id(&mut self, val: u64_) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn nr(&self) -> u64_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_nr(&mut self, val: u64_) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(id: u64_, nr: u64_) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let id: u64 = unsafe { ::core::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let nr: u64 = unsafe { ::core::mem::transmute(nr) };
            nr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct bch_sb_errors_cpu {
    pub nr: usize,
    pub size: usize,
    pub data: *mut bch_sb_error_entry_cpu,
    pub preallocated: __IncompleteArrayField<bch_sb_error_entry_cpu>,
}
impl Default for bch_sb_errors_cpu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seqmutex {
    pub lock: mutex,
    pub seq: u32_,
}
impl Default for seqmutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __bch2_print(c: *mut bch_fs, fmt: *const core::ffi::c_char, ...);
}
pub type io_timer_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_timer)>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct io_timer {
    pub fn_: io_timer_fn,
    pub expire: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_timer_heap {
    pub size: usize,
    pub used: usize,
    pub data: *mut *mut io_timer,
}
impl Default for io_timer_heap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_clock {
    pub now: atomic64_t,
    pub pcpu_buf: *mut u16_,
    pub max_slop: core::ffi::c_uint,
    pub timer_lock: spinlock_t,
    pub timers: io_timer_heap,
}
impl Default for io_clock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bch_watermark {
    BCH_WATERMARK_stripe = 0,
    BCH_WATERMARK_normal = 1,
    BCH_WATERMARK_copygc = 2,
    BCH_WATERMARK_btree = 3,
    BCH_WATERMARK_btree_copygc = 4,
    BCH_WATERMARK_reclaim = 5,
    BCH_WATERMARK_NR = 6,
}
pub type open_bucket_idx_t = u16_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct open_bucket {
    pub lock: spinlock_t,
    pub pin: atomic_t,
    pub freelist: open_bucket_idx_t,
    pub hash: open_bucket_idx_t,
    pub ec_idx: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub dev: u8_,
    pub gen: u8_,
    pub sectors_free: u32_,
    pub bucket: u64_,
    pub ec: *mut ec_stripe_new,
}
impl Default for open_bucket {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl open_bucket {
    #[inline]
    pub fn data_type(&self) -> bch_data_type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_data_type(&mut self, val: bch_data_type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn valid(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn on_partial_list(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_on_partial_list(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        data_type: bch_data_type,
        valid: core::ffi::c_uint,
        on_partial_list: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let data_type: u32 = unsafe { ::core::mem::transmute(data_type) };
            data_type as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let valid: u32 = unsafe { ::core::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let on_partial_list: u32 = unsafe { ::core::mem::transmute(on_partial_list) };
            on_partial_list as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct open_buckets {
    pub nr: open_bucket_idx_t,
    pub v: [open_bucket_idx_t; 15usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_stripe_state {
    pub next_alloc: [u64_; 64usize],
}
impl Default for dev_stripe_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum write_point_state {
    WRITE_POINT_stopped = 0,
    WRITE_POINT_waiting_io = 1,
    WRITE_POINT_waiting_work = 2,
    WRITE_POINT_running = 3,
    WRITE_POINT_STATE_NR = 4,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct write_point {
    pub __bindgen_anon_1: write_point__bindgen_ty_1,
    pub __bindgen_anon_2: write_point__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct write_point__bindgen_ty_1 {
    pub node: hlist_node,
    pub lock: mutex,
    pub last_used: u64_,
    pub write_point: core::ffi::c_ulong,
    pub data_type: bch_data_type,
    pub sectors_free: core::ffi::c_uint,
    pub ptrs: open_buckets,
    pub stripe: dev_stripe_state,
    pub sectors_allocated: u64_,
}
impl Default for write_point__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct write_point__bindgen_ty_2 {
    pub index_update_work: work_struct,
    pub writes: list_head,
    pub writes_lock: spinlock_t,
    pub state: write_point_state,
    pub last_state_change: u64_,
    pub time: [u64_; 4usize],
}
impl Default for write_point__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for write_point {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btree_key_cache_freelist {
    pub objs: [*mut bkey_cached; 16usize],
    pub nr: core::ffi::c_uint,
}
impl Default for btree_key_cache_freelist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btree_key_cache {
    pub lock: mutex,
    pub table: rhashtable,
    pub table_init_done: bool_,
    pub freed_pcpu: list_head,
    pub nr_freed_pcpu: usize,
    pub freed_nonpcpu: list_head,
    pub nr_freed_nonpcpu: usize,
    pub shrink: *mut shrinker,
    pub shrink_iter: core::ffi::c_uint,
    pub pcpu_freed: *mut btree_key_cache_freelist,
    pub nr_freed: atomic_long_t,
    pub nr_keys: atomic_long_t,
    pub nr_dirty: atomic_long_t,
}
impl Default for btree_key_cache {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
#[derive(Default, Copy, Clone)]
pub struct bkey_cached_key {
    pub btree_id: u32_,
    pub pos: bpos,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bucket {
    pub lock: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub gen: u8_,
    pub stripe_redundancy: u8_,
    pub stripe: u32_,
    pub dirty_sectors: u32_,
    pub cached_sectors: u32_,
}
impl bucket {
    #[inline]
    pub fn gen_valid(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gen_valid(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_type(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_data_type(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(gen_valid: u8_, data_type: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gen_valid: u8 = unsafe { ::core::mem::transmute(gen_valid) };
            gen_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let data_type: u8 = unsafe { ::core::mem::transmute(data_type) };
            data_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct bucket_array {
    pub rcu: callback_head,
    pub first_bucket: u16_,
    pub nbuckets: usize,
    pub b: __IncompleteArrayField<bucket>,
}
impl Default for bucket_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct bucket_gens {
    pub rcu: callback_head,
    pub first_bucket: u16_,
    pub nbuckets: usize,
    pub b: __IncompleteArrayField<u8_>,
}
impl Default for bucket_gens {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_dev_usage {
    pub d: [bch_dev_usage__bindgen_ty_1; 10usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_dev_usage__bindgen_ty_1 {
    pub buckets: u64_,
    pub sectors: u64_,
    pub fragmented: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_fs_usage_base {
    pub hidden: u64_,
    pub btree: u64_,
    pub data: u64_,
    pub cached: u64_,
    pub reserved: u64_,
    pub nr_inodes: u64_,
}
#[repr(C)]
#[derive(Default)]
pub struct bch_fs_usage {
    pub b: bch_fs_usage_base,
    pub persistent_reserved: [u64_; 4usize],
    pub replicas: __IncompleteArrayField<u64_>,
}
#[repr(C)]
#[derive(Default)]
pub struct bch_fs_usage_online {
    pub online_reserved: u64_,
    pub u: bch_fs_usage,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct disk_reservation {
    pub sectors: u64_,
    pub gen: u32_,
    pub nr_replicas: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bch_sb_handle {
    pub sb: *mut bch_sb,
    pub bdev_handle: *mut bdev_handle,
    pub bdev: *mut block_device,
    pub sb_name: *mut core::ffi::c_char,
    pub bio: *mut bio,
    pub holder: *mut core::ffi::c_void,
    pub buffer_size: usize,
    pub mode: blk_mode_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub seq: u64_,
}
impl Default for bch_sb_handle {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bch_sb_handle {
    #[inline]
    pub fn have_layout(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_have_layout(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn have_bio(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_have_bio(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fs_sb(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fs_sb(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        have_layout: core::ffi::c_uint,
        have_bio: core::ffi::c_uint,
        fs_sb: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let have_layout: u32 = unsafe { ::core::mem::transmute(have_layout) };
            have_layout as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let have_bio: u32 = unsafe { ::core::mem::transmute(have_bio) };
            have_bio as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fs_sb: u32 = unsafe { ::core::mem::transmute(fs_sb) };
            fs_sb as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_devs_mask {
    pub d: [core::ffi::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_devs_list {
    pub nr: u8_,
    pub data: [u8_; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_member_cpu {
    pub nbuckets: u64_,
    pub first_bucket: u16_,
    pub bucket_size: u16_,
    pub group: u16_,
    pub state: u8_,
    pub discard: u8_,
    pub data_allowed: u8_,
    pub durability: u8_,
    pub freespace_initialized: u8_,
    pub valid: u8_,
}
#[repr(C)]
pub struct journal_buf {
    pub data: *mut jset,
    pub key: bkey_i,
    pub key_pad: [__u64; 4usize],
    pub devs_written: bch_devs_list,
    pub wait: closure_waitlist,
    pub last_seq: u64_,
    pub expires: core::ffi::c_long,
    pub flush_time: u64_,
    pub buf_size: core::ffi::c_uint,
    pub sectors: core::ffi::c_uint,
    pub disk_sectors: core::ffi::c_uint,
    pub u64s_reserved: core::ffi::c_uint,
    pub noflush: bool_,
    pub must_flush: bool_,
    pub separate_flush: bool_,
    pub need_flush_to_write_buffer: bool_,
}
impl Default for journal_buf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct journal_entry_pin_list {
    pub list: [list_head; 3usize],
    pub flushed: list_head,
    pub count: atomic_t,
    pub devs: bch_devs_list,
}
impl Default for journal_entry_pin_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type journal_pin_flush_fn = ::core::option::Option<
    unsafe extern "C" fn(
        j: *mut journal,
        arg1: *mut journal_entry_pin,
        arg2: u64_,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct journal_entry_pin {
    pub list: list_head,
    pub flush: journal_pin_flush_fn,
    pub seq: u64_,
}
impl Default for journal_entry_pin {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct journal_res {
    pub ref_: bool_,
    pub idx: u8_,
    pub u64s: u16_,
    pub offset: u32_,
    pub seq: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union journal_res_state {
    pub __bindgen_anon_1: journal_res_state__bindgen_ty_1,
    pub __bindgen_anon_2: journal_res_state__bindgen_ty_2,
    pub __bindgen_anon_3: journal_res_state__bindgen_ty_3,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct journal_res_state__bindgen_ty_1 {
    pub counter: atomic64_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct journal_res_state__bindgen_ty_2 {
    pub v: u64_,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct journal_res_state__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl journal_res_state__bindgen_ty_3 {
    #[inline]
    pub fn cur_entry_offset(&self) -> u64_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u64) }
    }
    #[inline]
    pub fn set_cur_entry_offset(&mut self, val: u64_) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn idx(&self) -> u64_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_idx(&mut self, val: u64_) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn unwritten_idx(&self) -> u64_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_unwritten_idx(&mut self, val: u64_) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn buf0_count(&self) -> u64_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_buf0_count(&mut self, val: u64_) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn buf1_count(&self) -> u64_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_buf1_count(&mut self, val: u64_) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn buf2_count(&self) -> u64_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_buf2_count(&mut self, val: u64_) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn buf3_count(&self) -> u64_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_buf3_count(&mut self, val: u64_) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cur_entry_offset: u64_,
        idx: u64_,
        unwritten_idx: u64_,
        buf0_count: u64_,
        buf1_count: u64_,
        buf2_count: u64_,
        buf3_count: u64_,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let cur_entry_offset: u64 = unsafe { ::core::mem::transmute(cur_entry_offset) };
            cur_entry_offset as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let idx: u64 = unsafe { ::core::mem::transmute(idx) };
            idx as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let unwritten_idx: u64 = unsafe { ::core::mem::transmute(unwritten_idx) };
            unwritten_idx as u64
        });
        __bindgen_bitfield_unit.set(24usize, 10u8, {
            let buf0_count: u64 = unsafe { ::core::mem::transmute(buf0_count) };
            buf0_count as u64
        });
        __bindgen_bitfield_unit.set(34usize, 10u8, {
            let buf1_count: u64 = unsafe { ::core::mem::transmute(buf1_count) };
            buf1_count as u64
        });
        __bindgen_bitfield_unit.set(44usize, 10u8, {
            let buf2_count: u64 = unsafe { ::core::mem::transmute(buf2_count) };
            buf2_count as u64
        });
        __bindgen_bitfield_unit.set(54usize, 10u8, {
            let buf3_count: u64 = unsafe { ::core::mem::transmute(buf3_count) };
            buf3_count as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for journal_res_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct journal {
    pub _bindgen_opaque_blob: [u8; 2240usize],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct journal__bindgen_ty_1 {
    pub reservations: journal_res_state,
    pub watermark: bch_watermark,
}
impl Default for journal__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct journal__bindgen_ty_2 {
    pub front: u64_,
    pub back: u64_,
    pub size: u64_,
    pub mask: u64_,
    pub data: *mut journal_entry_pin_list,
}
impl Default for journal__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for journal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct journal_device {
    pub bucket_seq: *mut u64_,
    pub sectors_free: core::ffi::c_uint,
    pub discard_idx: core::ffi::c_uint,
    pub dirty_idx_ondisk: core::ffi::c_uint,
    pub dirty_idx: core::ffi::c_uint,
    pub cur_idx: core::ffi::c_uint,
    pub nr: core::ffi::c_uint,
    pub buckets: *mut u64_,
    pub bio: *mut bio,
    pub read: closure,
}
impl Default for journal_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct journal_entry_res {
    pub u64s: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bch_replicas_cpu {
    pub nr: core::ffi::c_uint,
    pub entry_size: core::ffi::c_uint,
    pub entries: *mut bch_replicas_entry_v1,
}
impl Default for bch_replicas_cpu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct replicas_delta {
    pub delta: s64,
    pub r: bch_replicas_entry_v1,
}
impl Default for replicas_delta {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct replicas_delta_list {
    pub size: core::ffi::c_uint,
    pub used: core::ffi::c_uint,
    pub memset_start: replicas_delta_list__bindgen_ty_1,
    pub nr_inodes: u64_,
    pub persistent_reserved: [u64_; 4usize],
    pub memset_end: replicas_delta_list__bindgen_ty_2,
    pub d: __IncompleteArrayField<replicas_delta>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct replicas_delta_list__bindgen_ty_1 {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct replicas_delta_list__bindgen_ty_2 {}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum six_lock_type {
    SIX_LOCK_read = 0,
    SIX_LOCK_intent = 1,
    SIX_LOCK_write = 2,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct six_lock {
    pub _bindgen_opaque_blob: [u64; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct six_lock_waiter {
    pub list: list_head,
    pub task: *mut task_struct,
    pub lock_want: six_lock_type,
    pub lock_acquired: bool_,
    pub start_time: u64_,
}
impl Default for six_lock_waiter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btree_nr_keys {
    pub live_u64s: u16_,
    pub bset_u64s: [u16_; 3usize],
    pub packed_keys: u16_,
    pub unpacked_keys: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bset_tree {
    pub size: u16_,
    pub extra: u16_,
    pub data_offset: u16_,
    pub aux_data_offset: u16_,
    pub end_offset: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btree_write {
    pub journal: journal_entry_pin,
}
impl Default for btree_write {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct btree_alloc {
    pub ob: open_buckets,
    pub k: bkey_i,
    pub k_pad: [__u64; 9usize],
}
impl Default for btree_alloc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btree_bkey_cached_common {
    pub lock: six_lock,
    pub level: u8_,
    pub btree_id: u8_,
    pub cached: bool_,
}
#[repr(C)]
pub struct btree {
    pub c: btree_bkey_cached_common,
    pub hash: rhash_head,
    pub hash_val: u64_,
    pub flags: core::ffi::c_ulong,
    pub written: u16_,
    pub nsets: u8_,
    pub nr_key_bits: u8_,
    pub version_ondisk: u16_,
    pub format: bkey_format,
    pub data: *mut btree_node,
    pub aux_data: *mut core::ffi::c_void,
    pub set: [bset_tree; 3usize],
    pub nr: btree_nr_keys,
    pub sib_u64s: [u16_; 2usize],
    pub whiteout_u64s: u16_,
    pub byte_order: u8_,
    pub unpack_fn_len: u8_,
    pub writes: [btree_write; 2usize],
    pub key: bkey_i,
    pub key_pad: [__u64; 9usize],
    pub write_blocked: list_head,
    pub will_make_reachable: core::ffi::c_ulong,
    pub ob: open_buckets,
    pub list: list_head,
}
impl Default for btree {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btree_cache {
    pub table: rhashtable,
    pub table_init_done: bool_,
    pub lock: mutex,
    pub live: list_head,
    pub freeable: list_head,
    pub freed_pcpu: list_head,
    pub freed_nonpcpu: list_head,
    pub used: core::ffi::c_uint,
    pub reserve: core::ffi::c_uint,
    pub dirty: atomic_t,
    pub shrink: *mut shrinker,
    pub alloc_lock: *mut task_struct,
    pub alloc_wait: closure_waitlist,
}
impl Default for btree_cache {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btree_node_iter {
    pub data: [btree_node_iter_btree_node_iter_set; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btree_node_iter_btree_node_iter_set {
    pub k: u16_,
    pub end: u16_,
}
pub const BTREE_ITER_SLOTS: u16_ = 1;
pub const BTREE_ITER_INTENT: u16_ = 2;
pub const BTREE_ITER_PREFETCH: u16_ = 4;
pub const BTREE_ITER_IS_EXTENTS: u16_ = 8;
pub const BTREE_ITER_NOT_EXTENTS: u16_ = 16;
pub const BTREE_ITER_CACHED: u16_ = 32;
pub const BTREE_ITER_WITH_KEY_CACHE: u16_ = 64;
pub const BTREE_ITER_WITH_UPDATES: u16_ = 128;
pub const BTREE_ITER_WITH_JOURNAL: u16_ = 256;
pub const BTREE_ITER_ALL_SNAPSHOTS: u16_ = 1024;
pub const BTREE_ITER_FILTER_SNAPSHOTS: u16_ = 2048;
pub const BTREE_ITER_NOPRESERVE: u16_ = 4096;
pub const BTREE_ITER_CACHED_NOFILL: u16_ = 8192;
pub const BTREE_ITER_KEY_CACHE_FILL: u16_ = 16384;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum btree_path_uptodate {
    BTREE_ITER_UPTODATE = 0,
    BTREE_ITER_NEED_RELOCK = 1,
    BTREE_ITER_NEED_TRAVERSE = 2,
}
pub type btree_path_idx_t = u16_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btree_path {
    pub sorted_idx: btree_path_idx_t,
    pub ref_: u8_,
    pub intent_ref: u8_,
    pub pos: bpos,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub nodes_locked: u8_,
    pub l: [btree_path_btree_path_level; 4usize],
    pub ip_allocated: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btree_path_btree_path_level {
    pub b: *mut btree,
    pub iter: btree_node_iter,
    pub lock_seq: u32_,
    pub lock_taken_time: u64_,
}
impl Default for btree_path_btree_path_level {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for btree_path {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl btree_path {
    #[inline]
    pub fn btree_id(&self) -> btree_id {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_btree_id(&mut self, val: btree_id) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn cached(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cached(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn preserve(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_preserve(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uptodate(&self) -> btree_path_uptodate {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_uptodate(&mut self, val: btree_path_uptodate) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn should_be_locked(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_should_be_locked(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn level(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_level(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn locks_want(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_locks_want(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        btree_id: btree_id,
        cached: bool_,
        preserve: bool_,
        uptodate: btree_path_uptodate,
        should_be_locked: bool_,
        level: core::ffi::c_uint,
        locks_want: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let btree_id: u32 = unsafe { ::core::mem::transmute(btree_id) };
            btree_id as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cached: u8 = unsafe { ::core::mem::transmute(cached) };
            cached as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let preserve: u8 = unsafe { ::core::mem::transmute(preserve) };
            preserve as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let uptodate: u32 = unsafe { ::core::mem::transmute(uptodate) };
            uptodate as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let should_be_locked: u8 = unsafe { ::core::mem::transmute(should_be_locked) };
            should_be_locked as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let level: u32 = unsafe { ::core::mem::transmute(level) };
            level as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let locks_want: u32 = unsafe { ::core::mem::transmute(locks_want) };
            locks_want as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct btree_iter {
    pub trans: *mut btree_trans,
    pub path: btree_path_idx_t,
    pub update_path: btree_path_idx_t,
    pub key_cache_path: btree_path_idx_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub min_depth: u8_,
    pub flags: u16_,
    pub snapshot: core::ffi::c_uint,
    pub pos: bpos,
    pub k: bkey,
    pub journal_idx: usize,
    pub ip_allocated: core::ffi::c_ulong,
}
impl Default for btree_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl btree_iter {
    #[inline]
    pub fn btree_id(&self) -> btree_id {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_btree_id(&mut self, val: btree_id) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(btree_id: btree_id) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let btree_id: u32 = unsafe { ::core::mem::transmute(btree_id) };
            btree_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bkey_cached {
    pub c: btree_bkey_cached_common,
    pub flags: core::ffi::c_ulong,
    pub u64s: u16_,
    pub valid: bool_,
    pub btree_trans_barrier_seq: u32_,
    pub key: bkey_cached_key,
    pub hash: rhash_head,
    pub list: list_head,
    pub journal: journal_entry_pin,
    pub seq: u64_,
    pub k: *mut bkey_i,
}
impl Default for bkey_cached {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct btree_insert_entry {
    pub flags: core::ffi::c_uint,
    pub bkey_type: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub old_btree_u64s: u8_,
    pub path: btree_path_idx_t,
    pub k: *mut bkey_i,
    pub old_k: bkey,
    pub old_v: *const bch_val,
    pub ip_allocated: core::ffi::c_ulong,
}
impl Default for btree_insert_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl btree_insert_entry {
    #[inline]
    pub fn btree_id(&self) -> btree_id {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_btree_id(&mut self, val: btree_id) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn level(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_level(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn cached(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cached(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn insert_trigger_run(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_insert_trigger_run(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overwrite_trigger_run(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_overwrite_trigger_run(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn key_cache_already_flushed(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_key_cache_already_flushed(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        btree_id: btree_id,
        level: u8_,
        cached: bool_,
        insert_trigger_run: bool_,
        overwrite_trigger_run: bool_,
        key_cache_already_flushed: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let btree_id: u32 = unsafe { ::core::mem::transmute(btree_id) };
            btree_id as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let level: u8 = unsafe { ::core::mem::transmute(level) };
            level as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let cached: u8 = unsafe { ::core::mem::transmute(cached) };
            cached as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let insert_trigger_run: u8 = unsafe { ::core::mem::transmute(insert_trigger_run) };
            insert_trigger_run as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let overwrite_trigger_run: u8 =
                unsafe { ::core::mem::transmute(overwrite_trigger_run) };
            overwrite_trigger_run as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let key_cache_already_flushed: u8 =
                unsafe { ::core::mem::transmute(key_cache_already_flushed) };
            key_cache_already_flushed as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type btree_trans_commit_hook_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut btree_trans,
        arg2: *mut btree_trans_commit_hook,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btree_trans_commit_hook {
    pub fn_: btree_trans_commit_hook_fn,
    pub next: *mut btree_trans_commit_hook,
}
impl Default for btree_trans_commit_hook {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct btree_trans_paths {
    pub nr_paths: core::ffi::c_ulong,
    pub paths: __IncompleteArrayField<btree_path>,
}
impl Default for btree_trans_paths {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct btree_trans {
    pub c: *mut bch_fs,
    pub paths_allocated: *mut core::ffi::c_ulong,
    pub paths: *mut btree_path,
    pub sorted: *mut btree_path_idx_t,
    pub updates: *mut btree_insert_entry,
    pub mem: *mut core::ffi::c_void,
    pub mem_top: core::ffi::c_uint,
    pub mem_bytes: core::ffi::c_uint,
    pub nr_sorted: btree_path_idx_t,
    pub nr_paths: btree_path_idx_t,
    pub nr_paths_max: btree_path_idx_t,
    pub fn_idx: u8_,
    pub nr_updates: u8_,
    pub lock_must_abort: u8_,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub restart_count: u32_,
    pub last_begin_time: u64_,
    pub last_begin_ip: core::ffi::c_ulong,
    pub last_restarted_ip: core::ffi::c_ulong,
    pub srcu_lock_time: core::ffi::c_ulong,
    pub fn_: *const core::ffi::c_char,
    pub locking: *mut btree_bkey_cached_common,
    pub locking_wait: six_lock_waiter,
    pub srcu_idx: core::ffi::c_int,
    pub journal_entries_u64s: u16_,
    pub journal_entries_size: u16_,
    pub journal_entries: *mut jset_entry,
    pub hooks: *mut btree_trans_commit_hook,
    pub journal_pin: *mut journal_entry_pin,
    pub journal_res: journal_res,
    pub journal_seq: *mut u64_,
    pub disk_res: *mut disk_reservation,
    pub fs_usage_delta: bch_fs_usage_base,
    pub journal_u64s: core::ffi::c_uint,
    pub extra_disk_res: core::ffi::c_uint,
    pub fs_usage_deltas: *mut replicas_delta_list,
    pub list: list_head,
    pub ref_: closure,
    pub _paths_allocated: [core::ffi::c_ulong; 1usize],
    pub trans_paths: btree_trans_paths,
    pub _paths: [btree_path; 64usize],
    pub _sorted: [btree_path_idx_t; 68usize],
    pub _updates: [btree_insert_entry; 64usize],
}
impl Default for btree_trans {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl btree_trans {
    #[inline]
    pub fn lock_may_not_fail(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lock_may_not_fail(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn srcu_held(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_srcu_held(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn used_mempool(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_used_mempool(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_traverse_all(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_traverse_all(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn paths_sorted(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_paths_sorted(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memory_allocation_failure(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_memory_allocation_failure(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn journal_transaction_names(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_journal_transaction_names(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn journal_replay_not_finished(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_journal_replay_not_finished(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn notrace_relock_fail(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_notrace_relock_fail(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_locked(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_locked(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restarted(&self) -> bch_errcode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_restarted(&mut self, val: bch_errcode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lock_may_not_fail: bool_,
        srcu_held: bool_,
        used_mempool: bool_,
        in_traverse_all: bool_,
        paths_sorted: bool_,
        memory_allocation_failure: bool_,
        journal_transaction_names: bool_,
        journal_replay_not_finished: bool_,
        notrace_relock_fail: bool_,
        write_locked: bool_,
        restarted: bch_errcode,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lock_may_not_fail: u8 = unsafe { ::core::mem::transmute(lock_may_not_fail) };
            lock_may_not_fail as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let srcu_held: u8 = unsafe { ::core::mem::transmute(srcu_held) };
            srcu_held as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let used_mempool: u8 = unsafe { ::core::mem::transmute(used_mempool) };
            used_mempool as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_traverse_all: u8 = unsafe { ::core::mem::transmute(in_traverse_all) };
            in_traverse_all as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let paths_sorted: u8 = unsafe { ::core::mem::transmute(paths_sorted) };
            paths_sorted as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let memory_allocation_failure: u8 =
                unsafe { ::core::mem::transmute(memory_allocation_failure) };
            memory_allocation_failure as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let journal_transaction_names: u8 =
                unsafe { ::core::mem::transmute(journal_transaction_names) };
            journal_transaction_names as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let journal_replay_not_finished: u8 =
                unsafe { ::core::mem::transmute(journal_replay_not_finished) };
            journal_replay_not_finished as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let notrace_relock_fail: u8 = unsafe { ::core::mem::transmute(notrace_relock_fail) };
            notrace_relock_fail as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let write_locked: u8 = unsafe { ::core::mem::transmute(write_locked) };
            write_locked as u64
        });
        __bindgen_bitfield_unit.set(10usize, 16u8, {
            let restarted: u32 = unsafe { ::core::mem::transmute(restarted) };
            restarted as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum btree_node_type {
    BKEY_TYPE_btree = 0,
    BKEY_TYPE_extents = 1,
    BKEY_TYPE_inodes = 2,
    BKEY_TYPE_dirents = 3,
    BKEY_TYPE_xattrs = 4,
    BKEY_TYPE_alloc = 5,
    BKEY_TYPE_quotas = 6,
    BKEY_TYPE_stripes = 7,
    BKEY_TYPE_reflink = 8,
    BKEY_TYPE_subvolumes = 9,
    BKEY_TYPE_snapshots = 10,
    BKEY_TYPE_lru = 11,
    BKEY_TYPE_freespace = 12,
    BKEY_TYPE_need_discard = 13,
    BKEY_TYPE_backpointers = 14,
    BKEY_TYPE_bucket_gens = 15,
    BKEY_TYPE_snapshot_trees = 16,
    BKEY_TYPE_deleted_inodes = 17,
    BKEY_TYPE_logged_ops = 18,
    BKEY_TYPE_rebalance_work = 19,
    BKEY_TYPE_NR = 20,
}
extern "C" {
    pub fn bch2_btree_node_type_str(arg1: btree_node_type) -> *const core::ffi::c_char;
}
#[repr(C)]
pub struct btree_root {
    pub b: *mut btree,
    pub key: bkey_i,
    pub key_pad: [__u64; 9usize],
    pub level: u8_,
    pub alive: u8_,
    pub error: s8,
}
impl Default for btree_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wb_key_ref {
    pub __bindgen_anon_1: wb_key_ref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wb_key_ref__bindgen_ty_1 {
    pub __bindgen_anon_1: wb_key_ref__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: wb_key_ref__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wb_key_ref__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub pos: [u8_; 20usize],
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for wb_key_ref__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl wb_key_ref__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn idx(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_idx(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(idx: core::ffi::c_uint) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let idx: u32 = unsafe { ::core::mem::transmute(idx) };
            idx as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn btree(&self) -> btree_id {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_btree(&mut self, val: btree_id) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(btree: btree_id) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let btree: u32 = unsafe { ::core::mem::transmute(btree) };
            btree as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct wb_key_ref__bindgen_ty_1__bindgen_ty_2 {
    pub lo: u64_,
    pub mi: u64_,
    pub hi: u64_,
}
impl Default for wb_key_ref__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for wb_key_ref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct btree_write_buffered_key {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub k: bkey_i,
    pub k_pad: [__u64; 4usize],
}
impl Default for btree_write_buffered_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl btree_write_buffered_key {
    #[inline]
    pub fn btree(&self) -> btree_id {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_btree(&mut self, val: btree_id) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn journal_seq(&self) -> u64_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_journal_seq(&mut self, val: u64_) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        btree: btree_id,
        journal_seq: u64_,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let btree: u32 = unsafe { ::core::mem::transmute(btree) };
            btree as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let journal_seq: u64 = unsafe { ::core::mem::transmute(journal_seq) };
            journal_seq as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct btree_write_buffer_keys {
    pub keys: btree_write_buffer_keys__bindgen_ty_1,
    pub pin: journal_entry_pin,
    pub lock: mutex,
}
#[repr(C)]
pub struct btree_write_buffer_keys__bindgen_ty_1 {
    pub nr: usize,
    pub size: usize,
    pub data: *mut btree_write_buffered_key,
    pub preallocated: __IncompleteArrayField<btree_write_buffered_key>,
}
impl Default for btree_write_buffer_keys__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for btree_write_buffer_keys {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct btree_write_buffer {
    pub sorted: btree_write_buffer__bindgen_ty_1,
    pub inc: btree_write_buffer_keys,
    pub flushing: btree_write_buffer_keys,
    pub flush_work: work_struct,
}
#[repr(C)]
pub struct btree_write_buffer__bindgen_ty_1 {
    pub nr: usize,
    pub size: usize,
    pub data: *mut wb_key_ref,
    pub preallocated: __IncompleteArrayField<wb_key_ref>,
}
impl Default for btree_write_buffer__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for btree_write_buffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bucket_hashed {
    pub dev_bucket: u64_,
    pub journal_seq: u64_,
}
#[repr(C)]
#[derive(Default)]
pub struct buckets_waiting_for_journal_table {
    pub bits: core::ffi::c_uint,
    pub hash_seeds: [u64_; 3usize],
    pub d: __IncompleteArrayField<bucket_hashed>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct buckets_waiting_for_journal {
    pub lock: mutex,
    pub t: *mut buckets_waiting_for_journal_table,
}
impl Default for buckets_waiting_for_journal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_disk_group_cpu {
    pub deleted: bool_,
    pub parent: u16_,
    pub label: [u8_; 32usize],
    pub devs: bch_devs_mask,
}
#[repr(C)]
pub struct bch_disk_groups_cpu {
    pub rcu: callback_head,
    pub nr: core::ffi::c_uint,
    pub entries: __IncompleteArrayField<bch_disk_group_cpu>,
}
impl Default for bch_disk_groups_cpu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct bch_replicas_padded {
    pub e: bch_replicas_entry_v1,
    pub pad: [u8_; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct stripe {
    pub heap_idx: usize,
    pub sectors: u16_,
    pub algorithm: u8_,
    pub nr_blocks: u8_,
    pub nr_redundant: u8_,
    pub blocks_nonempty: u8_,
}
#[repr(C)]
pub struct gc_stripe {
    pub sectors: u16_,
    pub nr_blocks: u8_,
    pub nr_redundant: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub block_sectors: [u16_; 16usize],
    pub ptrs: [bch_extent_ptr; 16usize],
    pub r: bch_replicas_padded,
}
impl Default for gc_stripe {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl gc_stripe {
    #[inline]
    pub fn alive(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alive(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(alive: core::ffi::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let alive: u32 = unsafe { ::core::mem::transmute(alive) };
            alive as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_stripe_heap_entry {
    pub idx: usize,
    pub blocks_nonempty: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_stripes_heap {
    pub size: usize,
    pub used: usize,
    pub data: *mut ec_stripe_heap_entry,
}
impl Default for ec_stripes_heap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct genradix_root {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __genradix {
    pub root: *mut genradix_root,
}
impl Default for __genradix {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_qid {
    pub q: [u32_; 3usize],
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum quota_acct_mode {
    KEY_TYPE_QUOTA_PREALLOC = 0,
    KEY_TYPE_QUOTA_WARN = 1,
    KEY_TYPE_QUOTA_NOCHECK = 2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct memquota_counter {
    pub v: u64_,
    pub hardlimit: u64_,
    pub softlimit: u64_,
    pub timer: s64,
    pub warns: core::ffi::c_int,
    pub warning_issued: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_memquota {
    pub c: [memquota_counter; 2usize],
}
#[repr(C)]
pub struct bch_memquota_table {
    pub tree: __genradix,
    pub type_: __IncompleteArrayField<bch_memquota>,
}
impl Default for bch_memquota_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct quota_limit {
    pub timelimit: u32_,
    pub warnlimit: u32_,
}
#[repr(C)]
pub struct bch_memquota_type {
    pub limits: [quota_limit; 2usize],
    pub table: bch_memquota_table,
    pub lock: mutex,
}
impl Default for bch_memquota_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bbpos {
    pub btree: btree_id,
    pub pos: bpos,
}
impl Default for bbpos {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bch_move_stats {
    pub data_type: bch_data_type,
    pub pos: bbpos,
    pub name: [core::ffi::c_char; 32usize],
    pub keys_moved: atomic64_t,
    pub keys_raced: atomic64_t,
    pub sectors_seen: atomic64_t,
    pub sectors_moved: atomic64_t,
    pub sectors_raced: atomic64_t,
}
impl Default for bch_move_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bch_rebalance_states {
    BCH_REBALANCE_waiting = 0,
    BCH_REBALANCE_working = 1,
    BCH_REBALANCE_scanning = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bch_fs_rebalance {
    pub thread: *mut task_struct,
    pub pd: bch_pd_controller,
    pub state: bch_rebalance_states,
    pub wait_iotime_start: u64_,
    pub wait_iotime_end: u64_,
    pub wait_wallclock_start: u64_,
    pub work_stats: bch_move_stats,
    pub scan_start: bbpos,
    pub scan_end: bbpos,
    pub scan_stats: bch_move_stats,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl Default for bch_fs_rebalance {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bch_fs_rebalance {
    #[inline]
    pub fn enabled(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(enabled: core::ffi::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::core::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct snapshot_id_list {
    pub nr: usize,
    pub size: usize,
    pub data: *mut u32_,
    pub preallocated: __IncompleteArrayField<u32_>,
}
impl Default for snapshot_id_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct snapshot_t {
    pub parent: u32_,
    pub skip: [u32_; 3usize],
    pub depth: u32_,
    pub children: [u32_; 2usize],
    pub subvol: u32_,
    pub tree: u32_,
    pub equiv: u32_,
    pub is_ancestor: [core::ffi::c_ulong; 2usize],
}
#[repr(C)]
#[derive(Default)]
pub struct snapshot_table {
    pub __bindgen_anon_1: snapshot_table__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default)]
pub struct snapshot_table__bindgen_ty_1 {
    pub __empty_s: snapshot_table__bindgen_ty_1__bindgen_ty_1,
    pub s: __IncompleteArrayField<snapshot_t>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct snapshot_table__bindgen_ty_1__bindgen_ty_1 {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct subvol_inum {
    pub subvol: u32_,
    pub inum: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct stdio_redirect {
    pub output_lock: spinlock_t,
    pub output_wait: wait_queue_head_t,
    pub output_buf: printbuf,
    pub input_lock: spinlock_t,
    pub input_wait: wait_queue_head_t,
    pub input_buf: printbuf,
    pub done: bool_,
}
impl Default for stdio_redirect {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum gc_phase {
    GC_PHASE_NOT_RUNNING = 0,
    GC_PHASE_START = 1,
    GC_PHASE_SB = 2,
    GC_PHASE_BTREE_stripes = 3,
    GC_PHASE_BTREE_extents = 4,
    GC_PHASE_BTREE_inodes = 5,
    GC_PHASE_BTREE_dirents = 6,
    GC_PHASE_BTREE_xattrs = 7,
    GC_PHASE_BTREE_alloc = 8,
    GC_PHASE_BTREE_quotas = 9,
    GC_PHASE_BTREE_reflink = 10,
    GC_PHASE_BTREE_subvolumes = 11,
    GC_PHASE_BTREE_snapshots = 12,
    GC_PHASE_BTREE_lru = 13,
    GC_PHASE_BTREE_freespace = 14,
    GC_PHASE_BTREE_need_discard = 15,
    GC_PHASE_BTREE_backpointers = 16,
    GC_PHASE_BTREE_bucket_gens = 17,
    GC_PHASE_BTREE_snapshot_trees = 18,
    GC_PHASE_BTREE_deleted_inodes = 19,
    GC_PHASE_BTREE_logged_ops = 20,
    GC_PHASE_BTREE_rebalance_work = 21,
    GC_PHASE_PENDING_DELETE = 22,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gc_pos {
    pub phase: gc_phase,
    pub pos: bpos,
    pub level: core::ffi::c_uint,
}
impl Default for gc_pos {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct reflink_gc {
    pub offset: u64_,
    pub size: u32_,
    pub refcount: u32_,
}
#[repr(C)]
pub struct reflink_gc_table {
    pub tree: __genradix,
    pub type_: __IncompleteArrayField<reflink_gc>,
}
impl Default for reflink_gc_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct io_count {
    pub sectors: [[u64_; 10usize]; 2usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct bch_dev {
    pub kobj: kobject,
    pub ref_: percpu_ref,
    pub ref_completion: completion,
    pub io_ref: percpu_ref,
    pub io_ref_completion: completion,
    pub fs: *mut bch_fs,
    pub dev_idx: u8_,
    pub mi: bch_member_cpu,
    pub errors: [atomic64_t; 3usize],
    pub uuid: __uuid_t,
    pub name: [core::ffi::c_char; 32usize],
    pub disk_sb: bch_sb_handle,
    pub sb_read_scratch: *mut bch_sb,
    pub sb_write_error: core::ffi::c_int,
    pub dev: dev_t,
    pub flush_seq: atomic_t,
    pub self_: bch_devs_mask,
    pub replica_set: bio_set,
    pub buckets_gc: *mut bucket_array,
    pub bucket_gens: *mut bucket_gens,
    pub oldest_gen: *mut u8_,
    pub buckets_nouse: *mut core::ffi::c_ulong,
    pub bucket_lock: rw_semaphore,
    pub usage_base: *mut bch_dev_usage,
    pub usage: [*mut bch_dev_usage; 4usize],
    pub usage_gc: *mut bch_dev_usage,
    pub new_fs_bucket_idx: u64_,
    pub alloc_cursor: u64_,
    pub nr_open_buckets: core::ffi::c_uint,
    pub nr_btree_reserve: core::ffi::c_uint,
    pub inc_gen_needs_gc: usize,
    pub inc_gen_really_needs_gc: usize,
    pub buckets_waiting_on_journal: usize,
    pub rebalance_work: atomic64_t,
    pub journal: journal_device,
    pub prev_journal_sector: u64_,
    pub io_error_work: work_struct,
    pub cur_latency: [atomic64_t; 2usize],
    pub io_latency: [bch2_time_stats; 2usize],
    pub congested: atomic_t,
    pub congested_last: u64_,
    pub io_done: *mut io_count,
}
impl Default for bch_dev {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btree_debug {
    pub id: btree_id,
}
impl Default for btree_debug {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct btree_transaction_stats {
    pub duration: bch2_time_stats,
    pub lock_hold_times: bch2_time_stats,
    pub lock: mutex,
    pub nr_max_paths: core::ffi::c_uint,
    pub journal_entries_size: core::ffi::c_uint,
    pub max_mem: core::ffi::c_uint,
    pub max_paths_text: *mut core::ffi::c_char,
}
impl Default for btree_transaction_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_fs_pcpu {
    pub sectors_available: u64_,
}
#[repr(C)]
#[derive(Default)]
pub struct journal_seq_blacklist_table {
    pub nr: usize,
    pub entries:
        __IncompleteArrayField<journal_seq_blacklist_table_journal_seq_blacklist_table_entry>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct journal_seq_blacklist_table_journal_seq_blacklist_table_entry {
    pub start: u64_,
    pub end: u64_,
    pub dirty: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct journal_keys {
    pub d: *mut journal_keys_journal_key,
    pub gap: usize,
    pub nr: usize,
    pub size: usize,
    pub ref_: atomic_t,
    pub initial_ref_held: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct journal_keys_journal_key {
    pub journal_seq: u64_,
    pub journal_offset: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub allocated: bool_,
    pub overwritten: bool_,
    pub k: *mut bkey_i,
}
impl Default for journal_keys_journal_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl journal_keys_journal_key {
    #[inline]
    pub fn btree_id(&self) -> btree_id {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_btree_id(&mut self, val: btree_id) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn level(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_level(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        btree_id: btree_id,
        level: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let btree_id: u32 = unsafe { ::core::mem::transmute(btree_id) };
            btree_id as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let level: u32 = unsafe { ::core::mem::transmute(level) };
            level as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for journal_keys {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btree_trans_buf {
    pub trans: *mut btree_trans,
}
impl Default for btree_trans_buf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct bch_fs {
    pub cl: closure,
    pub list: list_head,
    pub kobj: kobject,
    pub counters_kobj: kobject,
    pub internal: kobject,
    pub opts_dir: kobject,
    pub time_stats: kobject,
    pub flags: core::ffi::c_ulong,
    pub minor: core::ffi::c_int,
    pub chardev: *mut device,
    pub vfs_sb: *mut super_block,
    pub dev: dev_t,
    pub name: [core::ffi::c_char; 40usize],
    pub stdio: *mut stdio_redirect,
    pub stdio_filter: *mut task_struct,
    pub state_lock: rw_semaphore,
    pub writes: [atomic_long_t; 14usize],
    pub ro_ref: refcount_t,
    pub ro_ref_wait: wait_queue_head_t,
    pub read_only_work: work_struct,
    pub devs: [*mut bch_dev; 64usize],
    pub replicas: bch_replicas_cpu,
    pub replicas_gc: bch_replicas_cpu,
    pub replicas_gc_lock: mutex,
    pub replicas_delta_pool: mempool_t,
    pub btree_root_journal_res: journal_entry_res,
    pub replicas_journal_res: journal_entry_res,
    pub clock_journal_res: journal_entry_res,
    pub dev_usage_journal_res: journal_entry_res,
    pub disk_groups: *mut bch_disk_groups_cpu,
    pub opts: bch_opts,
    pub sb: bch_fs__bindgen_ty_1,
    pub disk_sb: bch_sb_handle,
    pub block_bits: core::ffi::c_ushort,
    pub btree_foreground_merge_threshold: u16_,
    pub sb_write: closure,
    pub sb_lock: mutex,
    pub snapshots: *mut snapshot_table,
    pub snapshot_table_size: usize,
    pub snapshot_table_lock: mutex,
    pub snapshot_create_lock: rw_semaphore,
    pub snapshot_delete_work: work_struct,
    pub snapshot_wait_for_pagecache_and_delete_work: work_struct,
    pub snapshots_unlinked: snapshot_id_list,
    pub snapshots_unlinked_lock: mutex,
    pub btree_bio: bio_set,
    pub io_complete_wq: *mut workqueue_struct,
    pub btree_roots_known: [btree_root; 19usize],
    pub btree_roots_extra: bch_fs__bindgen_ty_2,
    pub btree_root_lock: mutex,
    pub btree_cache: btree_cache,
    pub btree_reserve_cache: [btree_alloc; 56usize],
    pub btree_reserve_cache_nr: core::ffi::c_uint,
    pub btree_reserve_cache_lock: mutex,
    pub btree_interior_update_pool: mempool_t,
    pub btree_interior_update_list: list_head,
    pub btree_interior_updates_unwritten: list_head,
    pub btree_interior_update_lock: mutex,
    pub btree_interior_update_wait: closure_waitlist,
    pub btree_interior_update_worker: *mut workqueue_struct,
    pub btree_interior_update_work: work_struct,
    pub pending_node_rewrites: list_head,
    pub pending_node_rewrites_lock: mutex,
    pub btree_write_error_lock: spinlock_t,
    pub btree_write_stats: [bch_fs_btree_write_stats; 5usize],
    pub btree_trans_lock: seqmutex,
    pub btree_trans_list: list_head,
    pub btree_trans_pool: mempool_t,
    pub btree_trans_mem_pool: mempool_t,
    pub btree_trans_bufs: *mut btree_trans_buf,
    pub btree_trans_barrier: srcu_struct,
    pub btree_trans_barrier_initialized: bool_,
    pub btree_key_cache: btree_key_cache,
    pub btree_key_cache_btrees: core::ffi::c_uint,
    pub btree_write_buffer: btree_write_buffer,
    pub btree_update_wq: *mut workqueue_struct,
    pub btree_io_complete_wq: *mut workqueue_struct,
    pub copygc_wq: *mut workqueue_struct,
    pub write_ref_wq: *mut workqueue_struct,
    pub rw_devs: [bch_devs_mask; 10usize],
    pub capacity: u64_,
    pub capacity_gen: u32_,
    pub bucket_size_max: core::ffi::c_uint,
    pub sectors_available: atomic64_t,
    pub sectors_available_lock: mutex,
    pub pcpu: *mut bch_fs_pcpu,
    pub mark_lock: percpu_rw_semaphore,
    pub usage_lock: seqcount_t,
    pub usage_base: *mut bch_fs_usage,
    pub usage: [*mut bch_fs_usage; 4usize],
    pub usage_gc: *mut bch_fs_usage,
    pub online_reserved: *mut u64_,
    pub usage_scratch_lock: mutex,
    pub usage_scratch: *mut bch_fs_usage_online,
    pub io_clock: [io_clock; 2usize],
    pub journal_seq_blacklist_table: *mut journal_seq_blacklist_table,
    pub journal_seq_blacklist_gc_work: work_struct,
    pub freelist_lock: spinlock_t,
    pub freelist_wait: closure_waitlist,
    pub blocked_allocate: u64_,
    pub blocked_allocate_open_bucket: u64_,
    pub open_buckets_freelist: open_bucket_idx_t,
    pub open_buckets_nr_free: open_bucket_idx_t,
    pub open_buckets_wait: closure_waitlist,
    pub open_buckets: [open_bucket; 1024usize],
    pub open_buckets_hash: [open_bucket_idx_t; 1024usize],
    pub open_buckets_partial: [open_bucket_idx_t; 1024usize],
    pub open_buckets_partial_nr: open_bucket_idx_t,
    pub __bindgen_padding_0: [u64; 4usize],
    pub btree_write_point: write_point,
    pub rebalance_write_point: write_point,
    pub write_points: [write_point; 32usize],
    pub write_points_hash: [hlist_head; 32usize],
    pub write_points_hash_lock: mutex,
    pub write_points_nr: core::ffi::c_uint,
    pub buckets_waiting_for_journal: buckets_waiting_for_journal,
    pub discard_work: work_struct,
    pub invalidate_work: work_struct,
    pub gc_thread: *mut task_struct,
    pub kick_gc: atomic_t,
    pub gc_count: core::ffi::c_ulong,
    pub gc_gens_btree: btree_id,
    pub gc_gens_pos: bpos,
    pub gc_pos_lock: seqcount_t,
    pub gc_pos: gc_pos,
    pub gc_lock: rw_semaphore,
    pub gc_gens_lock: mutex,
    pub io_in_flight: semaphore,
    pub bio_read: bio_set,
    pub bio_read_split: bio_set,
    pub bio_write: bio_set,
    pub bio_bounce_pages_lock: mutex,
    pub bio_bounce_pages: mempool_t,
    pub nocow_locks: bucket_nocow_lock_table,
    pub promote_table: rhashtable,
    pub compression_bounce: [mempool_t; 2usize],
    pub compress_workspace: [mempool_t; 6usize],
    pub decompress_workspace: mempool_t,
    pub zstd_workspace_size: usize,
    pub sha256: *mut crypto_shash,
    pub chacha20: *mut crypto_sync_skcipher,
    pub poly1305: *mut crypto_shash,
    pub key_version: atomic64_t,
    pub large_bkey_pool: mempool_t,
    pub moving_context_list: list_head,
    pub moving_context_lock: mutex,
    pub rebalance: bch_fs_rebalance,
    pub copygc_thread: *mut task_struct,
    pub __bindgen_padding_1: [u64; 7usize],
    pub copygc_write_point: write_point,
    pub copygc_wait_at: s64,
    pub copygc_wait: s64,
    pub copygc_running: bool_,
    pub copygc_running_wq: wait_queue_head_t,
    pub stripes: bch_fs__bindgen_ty_3,
    pub gc_stripes: bch_fs__bindgen_ty_4,
    pub ec_stripes_new: [hlist_head; 32usize],
    pub ec_stripes_new_lock: spinlock_t,
    pub ec_stripes_heap: ec_stripes_heap,
    pub ec_stripes_heap_lock: mutex,
    pub ec_stripe_head_list: list_head,
    pub ec_stripe_head_lock: mutex,
    pub ec_stripe_new_list: list_head,
    pub ec_stripe_new_lock: mutex,
    pub ec_stripe_new_wait: wait_queue_head_t,
    pub ec_stripe_create_work: work_struct,
    pub ec_stripe_hint: u64_,
    pub ec_stripe_delete_work: work_struct,
    pub ec_bioset: bio_set,
    pub reflink_gc_table: reflink_gc_table,
    pub reflink_gc_nr: usize,
    pub vfs_inodes_list: list_head,
    pub vfs_inodes_lock: mutex,
    pub writepage_bioset: bio_set,
    pub dio_write_bioset: bio_set,
    pub dio_read_bioset: bio_set,
    pub nocow_flush_bioset: bio_set,
    pub quotas: [bch_memquota_type; 3usize],
    pub journal_replay_seq_start: u64_,
    pub journal_replay_seq_end: u64_,
    pub curr_recovery_pass: bch_recovery_pass,
    pub recovery_passes_explicit: u64_,
    pub recovery_passes_complete: u64_,
    pub recovery_pass_done: bch_recovery_pass,
    pub online_fsck_mutex: semaphore,
    pub fs_debug_dir: *mut dentry,
    pub btree_debug_dir: *mut dentry,
    pub btree_debug: [btree_debug; 19usize],
    pub btree_debug_array: *mut core::ffi::c_void,
    pub verify_data: *mut btree,
    pub verify_ondisk: *mut btree_node,
    pub verify_lock: mutex,
    pub unused_inode_hints: *mut u64_,
    pub inode_shard_bits: core::ffi::c_uint,
    pub fill_iter: mempool_t,
    pub btree_bounce_pool: mempool_t,
    pub __bindgen_padding_2: [u64; 6usize],
    pub journal: journal,
    pub journal_entries: bch_fs__bindgen_ty_5,
    pub journal_entries_base_seq: u64_,
    pub journal_keys: journal_keys,
    pub journal_iters: list_head,
    pub last_bucket_seq_cleanup: u64_,
    pub counters_on_mount: [u64_; 79usize],
    pub counters: *mut u64_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub promote_whole_extents: bool_,
    pub __bindgen_padding_3: u64,
    pub times: [bch2_time_stats; 23usize],
    pub btree_transaction_stats: [btree_transaction_stats; 128usize],
    pub fsck_error_msgs: list_head,
    pub fsck_error_msgs_lock: mutex,
    pub fsck_alloc_msgs_err: bool_,
    pub fsck_error_counts: bch_sb_errors_cpu,
    pub fsck_error_counts_lock: mutex,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_fs__bindgen_ty_1 {
    pub uuid: __uuid_t,
    pub user_uuid: __uuid_t,
    pub version: u16_,
    pub version_min: u16_,
    pub version_upgrade_complete: u16_,
    pub nr_devices: u8_,
    pub clean: u8_,
    pub encryption_type: u8_,
    pub time_base_lo: u64_,
    pub time_base_hi: u32_,
    pub time_units_per_sec: core::ffi::c_uint,
    pub nsec_per_time_unit: core::ffi::c_uint,
    pub features: u64_,
    pub compat: u64_,
    pub errors_silent: [core::ffi::c_ulong; 4usize],
}
#[repr(C)]
pub struct bch_fs__bindgen_ty_2 {
    pub nr: usize,
    pub size: usize,
    pub data: *mut btree_root,
    pub preallocated: __IncompleteArrayField<btree_root>,
}
impl Default for bch_fs__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_fs_btree_write_stats {
    pub nr: atomic64_t,
    pub bytes: atomic64_t,
}
#[repr(C)]
pub struct bch_fs__bindgen_ty_3 {
    pub tree: __genradix,
    pub type_: __IncompleteArrayField<stripe>,
}
impl Default for bch_fs__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct bch_fs__bindgen_ty_4 {
    pub tree: __genradix,
    pub type_: __IncompleteArrayField<gc_stripe>,
}
impl Default for bch_fs__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct bch_fs__bindgen_ty_5 {
    pub tree: __genradix,
    pub type_: __IncompleteArrayField<*mut journal_replay>,
}
impl Default for bch_fs__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bch_fs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl bch_fs {
    #[inline]
    pub fn btree_gc_periodic(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_btree_gc_periodic(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn copy_gc_enabled(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_copy_gc_enabled(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        btree_gc_periodic: core::ffi::c_uint,
        copy_gc_enabled: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let btree_gc_periodic: u32 = unsafe { ::core::mem::transmute(btree_gc_periodic) };
            btree_gc_periodic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let copy_gc_enabled: u32 = unsafe { ::core::mem::transmute(copy_gc_enabled) };
            copy_gc_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bkey_invalid_flags {
    BKEY_INVALID_WRITE = 1,
    BKEY_INVALID_COMMIT = 2,
    BKEY_INVALID_JOURNAL = 4,
}
extern "C" {
    pub fn bch2_bkey_packed_to_binary_text(
        arg1: *mut printbuf,
        arg2: *const bkey_format,
        arg3: *const bkey_packed,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bkey_s_c {
    pub k: *const bkey,
    pub v: *const bch_val,
}
impl Default for bkey_s_c {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bkey_s {
    pub __bindgen_anon_1: bkey_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bkey_s__bindgen_ty_1 {
    pub __bindgen_anon_1: bkey_s__bindgen_ty_1__bindgen_ty_1,
    pub s_c: bkey_s_c,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bkey_s__bindgen_ty_1__bindgen_ty_1 {
    pub k: *mut bkey,
    pub v: *mut bch_val,
}
impl Default for bkey_s__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bkey_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bkey_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn bch2_bkey_greatest_differing_bit(
        arg1: *const btree,
        arg2: *const bkey_packed,
        arg3: *const bkey_packed,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn bch2_bkey_ffs(arg1: *const btree, arg2: *const bkey_packed) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __bch2_bkey_cmp_packed_format_checked(
        arg1: *const bkey_packed,
        arg2: *const bkey_packed,
        arg3: *const btree,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __bch2_bkey_cmp_left_packed_format_checked(
        arg1: *const btree,
        arg2: *const bkey_packed,
        arg3: *const bpos,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_bkey_cmp_packed(
        arg1: *const btree,
        arg2: *const bkey_packed,
        arg3: *const bkey_packed,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __bch2_bkey_cmp_left_packed(
        arg1: *const btree,
        arg2: *const bkey_packed,
        arg3: *const bpos,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_bpos_swab(arg1: *mut bpos);
}
extern "C" {
    pub fn bch2_bkey_swab_key(arg1: *const bkey_format, arg2: *mut bkey_packed);
}
extern "C" {
    pub fn bch2_bkey_transform(
        arg1: *const bkey_format,
        arg2: *mut bkey_packed,
        arg3: *const bkey_format,
        arg4: *const bkey_packed,
    ) -> bool_;
}
extern "C" {
    pub fn __bch2_bkey_unpack_key(arg1: *const bkey_format, arg2: *const bkey_packed) -> bkey;
}
extern "C" {
    pub fn bch2_bkey_pack_key(
        arg1: *mut bkey_packed,
        arg2: *const bkey,
        arg3: *const bkey_format,
    ) -> bool_;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bkey_pack_pos_ret {
    BKEY_PACK_POS_EXACT = 0,
    BKEY_PACK_POS_SMALLER = 1,
    BKEY_PACK_POS_FAIL = 2,
}
extern "C" {
    pub fn bch2_bkey_pack_pos_lossy(
        arg1: *mut bkey_packed,
        arg2: bpos,
        arg3: *const btree,
    ) -> bkey_pack_pos_ret;
}
extern "C" {
    pub fn bch2_bkey_unpack(arg1: *const btree, arg2: *mut bkey_i, arg3: *const bkey_packed);
}
extern "C" {
    pub fn bch2_bkey_pack(
        arg1: *mut bkey_packed,
        arg2: *const bkey_i,
        arg3: *const bkey_format,
    ) -> bool_;
}
#[repr(C)]
pub struct bkey_i_inode_v3 {
    pub __bindgen_anon_1: bkey_i_inode_v3__bindgen_ty_1,
    pub v: bch_inode_v3,
}
#[repr(C)]
pub struct bkey_i_inode_v3__bindgen_ty_1 {
    pub k: __BindgenUnionField<bkey>,
    pub k_i: __BindgenUnionField<bkey_i>,
    pub bindgen_union_field: [u64; 5usize],
}
impl Default for bkey_i_inode_v3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bkey_i_inode_v3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn bch2_bkey_pack_test();
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bkey_format_state {
    pub field_min: [u64_; 6usize],
    pub field_max: [u64_; 6usize],
}
extern "C" {
    pub fn bch2_bkey_format_init(arg1: *mut bkey_format_state);
}
extern "C" {
    pub fn bch2_bkey_format_add_pos(arg1: *mut bkey_format_state, arg2: bpos);
}
extern "C" {
    pub fn bch2_bkey_format_done(arg1: *mut bkey_format_state) -> bkey_format;
}
extern "C" {
    pub fn bch2_bkey_format_invalid(
        arg1: *mut bch_fs,
        arg2: *mut bkey_format,
        arg3: bkey_invalid_flags,
        arg4: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_bkey_format_to_text(arg1: *mut printbuf, arg2: *const bkey_format);
}
extern "C" {
    pub fn bch2_bkey_val_invalid(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: bkey_invalid_flags,
        arg4: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __bch2_bkey_invalid(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: btree_node_type,
        arg4: bkey_invalid_flags,
        arg5: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_bkey_invalid(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: btree_node_type,
        arg4: bkey_invalid_flags,
        arg5: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_bkey_in_btree_node(
        arg1: *mut bch_fs,
        arg2: *mut btree,
        arg3: bkey_s_c,
        arg4: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_bpos_to_text(arg1: *mut printbuf, arg2: bpos);
}
extern "C" {
    pub fn bch2_bkey_to_text(arg1: *mut printbuf, arg2: *const bkey);
}
extern "C" {
    pub fn bch2_val_to_text(arg1: *mut printbuf, arg2: *mut bch_fs, arg3: bkey_s_c);
}
extern "C" {
    pub fn bch2_bkey_val_to_text(arg1: *mut printbuf, arg2: *mut bch_fs, arg3: bkey_s_c);
}
extern "C" {
    pub fn bch2_bkey_swab_val(arg1: bkey_s);
}
extern "C" {
    pub fn bch2_bkey_normalize(arg1: *mut bch_fs, arg2: bkey_s) -> bool_;
}
extern "C" {
    pub fn bch2_bkey_merge(arg1: *mut bch_fs, arg2: bkey_s, arg3: bkey_s_c) -> bool_;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum btree_update_flags {
    __BTREE_UPDATE_INTERNAL_SNAPSHOT_NODE = 15,
    __BTREE_UPDATE_NOJOURNAL = 16,
    __BTREE_UPDATE_KEY_CACHE_RECLAIM = 17,
    __BTREE_TRIGGER_NORUN = 18,
    __BTREE_TRIGGER_TRANSACTIONAL = 19,
    __BTREE_TRIGGER_ATOMIC = 20,
    __BTREE_TRIGGER_GC = 21,
    __BTREE_TRIGGER_INSERT = 22,
    __BTREE_TRIGGER_OVERWRITE = 23,
    __BTREE_TRIGGER_BUCKET_INVALIDATE = 24,
}
extern "C" {
    pub fn bch2_bkey_renumber(
        arg1: btree_node_type,
        arg2: *mut bkey_packed,
        arg3: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __bch2_bkey_compat(
        arg1: core::ffi::c_uint,
        arg2: btree_id,
        arg3: core::ffi::c_uint,
        arg4: core::ffi::c_uint,
        arg5: core::ffi::c_int,
        arg6: *mut bkey_format,
        arg7: *mut bkey_packed,
    );
}
extern "C" {
    pub fn bch2_btree_keys_init(arg1: *mut btree);
}
extern "C" {
    pub fn bch2_bset_init_first(arg1: *mut btree, arg2: *mut bset);
}
extern "C" {
    pub fn bch2_bset_init_next(arg1: *mut btree, arg2: *mut btree_node_entry);
}
extern "C" {
    pub fn bch2_bset_build_aux_tree(arg1: *mut btree, arg2: *mut bset_tree, arg3: bool_);
}
extern "C" {
    pub fn bch2_bset_insert(
        arg1: *mut btree,
        arg2: *mut btree_node_iter,
        arg3: *mut bkey_packed,
        arg4: *mut bkey_i,
        arg5: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bch2_bset_delete(arg1: *mut btree, arg2: *mut bkey_packed, arg3: core::ffi::c_uint);
}
extern "C" {
    pub fn bch2_bkey_to_bset(arg1: *mut btree, arg2: *mut bkey_packed) -> *mut bset_tree;
}
extern "C" {
    pub fn bch2_bkey_prev_filter(
        arg1: *mut btree,
        arg2: *mut bset_tree,
        arg3: *mut bkey_packed,
        arg4: core::ffi::c_uint,
    ) -> *mut bkey_packed;
}
extern "C" {
    pub fn bch2_btree_node_iter_push(
        arg1: *mut btree_node_iter,
        arg2: *mut btree,
        arg3: *const bkey_packed,
        arg4: *const bkey_packed,
    );
}
extern "C" {
    pub fn bch2_btree_node_iter_init(arg1: *mut btree_node_iter, arg2: *mut btree, arg3: *mut bpos);
}
extern "C" {
    pub fn bch2_btree_node_iter_init_from_start(arg1: *mut btree_node_iter, arg2: *mut btree);
}
extern "C" {
    pub fn bch2_btree_node_iter_bset_pos(
        arg1: *mut btree_node_iter,
        arg2: *mut btree,
        arg3: *mut bset_tree,
    ) -> *mut bkey_packed;
}
extern "C" {
    pub fn bch2_btree_node_iter_sort(arg1: *mut btree_node_iter, arg2: *mut btree);
}
extern "C" {
    pub fn bch2_btree_node_iter_set_drop(
        arg1: *mut btree_node_iter,
        arg2: *mut btree_node_iter_btree_node_iter_set,
    );
}
extern "C" {
    pub fn bch2_btree_node_iter_advance(arg1: *mut btree_node_iter, arg2: *mut btree);
}
extern "C" {
    pub fn bch2_btree_node_iter_prev_all(
        arg1: *mut btree_node_iter,
        arg2: *mut btree,
    ) -> *mut bkey_packed;
}
extern "C" {
    pub fn bch2_btree_node_iter_prev(
        arg1: *mut btree_node_iter,
        arg2: *mut btree,
    ) -> *mut bkey_packed;
}
extern "C" {
    pub fn bch2_btree_node_iter_peek_unpack(
        arg1: *mut btree_node_iter,
        arg2: *mut btree,
        arg3: *mut bkey,
    ) -> bkey_s_c;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bset_stats {
    pub sets: [bset_stats__bindgen_ty_1; 3usize],
    pub floats: usize,
    pub failed: usize,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bset_stats__bindgen_ty_1 {
    pub nr: usize,
    pub bytes: usize,
}
extern "C" {
    pub fn bch2_btree_keys_stats(arg1: *const btree, arg2: *mut bset_stats);
}
extern "C" {
    pub fn bch2_bfloat_to_text(arg1: *mut printbuf, arg2: *mut btree, arg3: *mut bkey_packed);
}
extern "C" {
    pub fn bch2_dump_bset(
        arg1: *mut bch_fs,
        arg2: *mut btree,
        arg3: *mut bset,
        arg4: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bch2_dump_btree_node(arg1: *mut bch_fs, arg2: *mut btree);
}
extern "C" {
    pub fn bch2_dump_btree_node_iter(arg1: *mut btree, arg2: *mut btree_node_iter);
}
extern "C" {
    pub fn __bch2_verify_btree_nr_keys(arg1: *mut btree);
}
extern "C" {
    pub fn bch2_btree_node_iter_verify(arg1: *mut btree_node_iter, arg2: *mut btree);
}
extern "C" {
    pub fn bch2_verify_insert_pos(
        arg1: *mut btree,
        arg2: *mut bkey_packed,
        arg3: *mut bkey_packed,
        arg4: core::ffi::c_uint,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_call_mod {
    pub next: *mut static_call_mod,
    pub mod_: *mut module,
    pub sites: *mut static_call_site,
}
impl Default for static_call_mod {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_eval_map {
    pub system: *const core::ffi::c_char,
    pub eval_string: *const core::ffi::c_char,
    pub eval_value: core::ffi::c_ulong,
}
impl Default for trace_eval_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __bch2_btree_trans_sort_paths(arg1: *mut btree_trans);
}
extern "C" {
    pub fn __bch2_btree_path_make_mut(
        arg1: *mut btree_trans,
        arg2: btree_path_idx_t,
        arg3: bool_,
        arg4: core::ffi::c_ulong,
    ) -> btree_path_idx_t;
}
extern "C" {
    pub fn __bch2_btree_path_set_pos(
        arg1: *mut btree_trans,
        arg2: btree_path_idx_t,
        arg3: bpos,
        arg4: bool_,
        arg5: core::ffi::c_ulong,
    ) -> btree_path_idx_t;
}
extern "C" {
    pub fn bch2_btree_path_traverse_one(
        arg1: *mut btree_trans,
        arg2: btree_path_idx_t,
        arg3: core::ffi::c_uint,
        arg4: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_path_get(
        arg1: *mut btree_trans,
        arg2: btree_id,
        arg3: bpos,
        arg4: core::ffi::c_uint,
        arg5: core::ffi::c_uint,
        arg6: core::ffi::c_uint,
        arg7: core::ffi::c_ulong,
    ) -> btree_path_idx_t;
}
extern "C" {
    pub fn bch2_btree_path_peek_slot(arg1: *mut btree_path, arg2: *mut bkey) -> bkey_s_c;
}
extern "C" {
    pub fn bch2_btree_journal_peek_slot(
        arg1: *mut btree_trans,
        arg2: *mut btree_iter,
        arg3: bpos,
    ) -> *mut bkey_i;
}
extern "C" {
    pub fn bch2_btree_path_level_init(
        arg1: *mut btree_trans,
        arg2: *mut btree_path,
        arg3: *mut btree,
    );
}
extern "C" {
    pub fn __bch2_trans_mutex_lock(arg1: *mut btree_trans, arg2: *mut mutex) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_trans_verify_paths(arg1: *mut btree_trans);
}
extern "C" {
    pub fn bch2_assert_pos_locked(arg1: *mut btree_trans, arg2: btree_id, arg3: bpos, arg4: bool_);
}
extern "C" {
    pub fn bch2_btree_path_fix_key_modified(
        trans: *mut btree_trans,
        arg1: *mut btree,
        arg2: *mut bkey_packed,
    );
}
extern "C" {
    pub fn bch2_btree_node_iter_fix(
        trans: *mut btree_trans,
        arg1: *mut btree_path,
        arg2: *mut btree,
        arg3: *mut btree_node_iter,
        arg4: *mut bkey_packed,
        arg5: core::ffi::c_uint,
        arg6: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bch2_btree_path_relock_intent(
        arg1: *mut btree_trans,
        arg2: *mut btree_path,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_path_put(arg1: *mut btree_trans, arg2: btree_path_idx_t, arg3: bool_);
}
extern "C" {
    pub fn bch2_trans_relock(arg1: *mut btree_trans) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_trans_relock_notrace(arg1: *mut btree_trans) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_trans_unlock(arg1: *mut btree_trans);
}
extern "C" {
    pub fn bch2_trans_unlock_long(arg1: *mut btree_trans);
}
extern "C" {
    pub fn bch2_trans_locked(arg1: *mut btree_trans) -> bool_;
}
extern "C" {
    pub fn bch2_trans_restart_error(arg1: *mut btree_trans, arg2: u32_) -> !;
}
extern "C" {
    pub fn bch2_trans_in_restart_error(arg1: *mut btree_trans) -> !;
}
extern "C" {
    pub fn bch2_btree_node_upgrade(
        arg1: *mut btree_trans,
        arg2: *mut btree_path,
        arg3: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bch2_btree_path_downgrade(
        arg1: *mut btree_trans,
        arg2: *mut btree_path,
        arg3: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bch2_trans_downgrade(arg1: *mut btree_trans);
}
extern "C" {
    pub fn bch2_trans_node_add(trans: *mut btree_trans, arg1: *mut btree_path, arg2: *mut btree);
}
extern "C" {
    pub fn bch2_trans_node_reinit_iter(arg1: *mut btree_trans, arg2: *mut btree);
}
extern "C" {
    pub fn __bch2_btree_iter_traverse(iter: *mut btree_iter) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_iter_traverse(arg1: *mut btree_iter) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_iter_peek_node(arg1: *mut btree_iter) -> *mut btree;
}
extern "C" {
    pub fn bch2_btree_iter_peek_node_and_restart(arg1: *mut btree_iter) -> *mut btree;
}
extern "C" {
    pub fn bch2_btree_iter_next_node(arg1: *mut btree_iter) -> *mut btree;
}
extern "C" {
    pub fn bch2_btree_iter_peek_upto(arg1: *mut btree_iter, arg2: bpos) -> bkey_s_c;
}
extern "C" {
    pub fn bch2_btree_iter_next(arg1: *mut btree_iter) -> bkey_s_c;
}
extern "C" {
    pub fn bch2_btree_iter_peek_prev(arg1: *mut btree_iter) -> bkey_s_c;
}
extern "C" {
    pub fn bch2_btree_iter_prev(arg1: *mut btree_iter) -> bkey_s_c;
}
extern "C" {
    pub fn bch2_btree_iter_peek_slot(arg1: *mut btree_iter) -> bkey_s_c;
}
extern "C" {
    pub fn bch2_btree_iter_next_slot(arg1: *mut btree_iter) -> bkey_s_c;
}
extern "C" {
    pub fn bch2_btree_iter_prev_slot(arg1: *mut btree_iter) -> bkey_s_c;
}
extern "C" {
    pub fn bch2_btree_iter_advance(arg1: *mut btree_iter) -> bool_;
}
extern "C" {
    pub fn bch2_btree_iter_rewind(arg1: *mut btree_iter) -> bool_;
}
extern "C" {
    pub fn bch2_trans_iter_exit(arg1: *mut btree_trans, arg2: *mut btree_iter);
}
extern "C" {
    pub fn bch2_trans_iter_init_outlined(
        arg1: *mut btree_trans,
        arg2: *mut btree_iter,
        arg3: btree_id,
        arg4: bpos,
        flags: core::ffi::c_ushort,
    );
}
extern "C" {
    pub fn bch2_trans_node_iter_init(
        arg1: *mut btree_trans,
        arg2: *mut btree_iter,
        arg3: btree_id,
        arg4: bpos,
        arg5: core::ffi::c_uint,
        arg6: core::ffi::c_uint,
        arg7: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bch2_trans_copy_iter(arg1: *mut btree_iter, arg2: *mut btree_iter);
}
extern "C" {
    pub fn __bch2_trans_kmalloc(arg1: *mut btree_trans, arg2: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn bch2_trans_srcu_unlock(arg1: *mut btree_trans);
}
extern "C" {
    pub fn bch2_trans_begin(arg1: *mut btree_trans) -> u32_;
}
extern "C" {
    pub fn __bch2_btree_trans_too_many_iters(arg1: *mut btree_trans) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_iter_peek_and_restart_outlined(arg1: *mut btree_iter) -> bkey_s_c;
}
extern "C" {
    pub fn bch2_trans_updates_to_text(arg1: *mut printbuf, arg2: *mut btree_trans);
}
extern "C" {
    pub fn bch2_trans_paths_to_text(arg1: *mut printbuf, arg2: *mut btree_trans);
}
extern "C" {
    pub fn bch2_dump_trans_updates(arg1: *mut btree_trans);
}
extern "C" {
    pub fn bch2_dump_trans_paths_updates(arg1: *mut btree_trans);
}
extern "C" {
    pub fn __bch2_trans_get(arg1: *mut bch_fs, arg2: core::ffi::c_uint) -> *mut btree_trans;
}
extern "C" {
    pub fn bch2_trans_put(arg1: *mut btree_trans);
}
extern "C" {
    pub fn bch2_trans_get_fn_idx(arg1: *const core::ffi::c_char) -> core::ffi::c_uint;
}
extern "C" {
    pub fn bch2_btree_trans_to_text(arg1: *mut printbuf, arg2: *mut btree_trans);
}
extern "C" {
    pub fn bch2_fs_btree_iter_exit(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fs_btree_iter_init_early(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fs_btree_iter_init(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_key_cache_journal_flush(
        arg1: *mut journal,
        arg2: *mut journal_entry_pin,
        arg3: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_key_cache_find(
        arg1: *mut bch_fs,
        arg2: btree_id,
        arg3: bpos,
    ) -> *mut bkey_cached;
}
extern "C" {
    pub fn bch2_btree_path_traverse_cached(
        arg1: *mut btree_trans,
        arg2: *mut btree_path,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_insert_key_cached(
        arg1: *mut btree_trans,
        arg2: core::ffi::c_uint,
        arg3: *mut btree_insert_entry,
    ) -> bool_;
}
extern "C" {
    pub fn bch2_btree_key_cache_drop(arg1: *mut btree_trans, arg2: *mut btree_path);
}
extern "C" {
    pub fn bch2_fs_btree_key_cache_exit(arg1: *mut btree_key_cache);
}
extern "C" {
    pub fn bch2_fs_btree_key_cache_init_early(arg1: *mut btree_key_cache);
}
extern "C" {
    pub fn bch2_fs_btree_key_cache_init(arg1: *mut btree_key_cache) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_key_cache_to_text(arg1: *mut printbuf, arg2: *mut btree_key_cache);
}
extern "C" {
    pub fn bch2_btree_key_cache_exit();
}
extern "C" {
    pub fn bch2_btree_key_cache_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_fs_ioctl(
        arg1: *mut bch_fs,
        arg2: core::ffi::c_uint,
        arg3: *mut core::ffi::c_void,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn bch2_fs_chardev_exit(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fs_chardev_init(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_chardev_exit();
}
extern "C" {
    pub fn bch2_chardev_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_invalid(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: bkey_invalid_flags,
        arg4: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_v2_invalid(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: bkey_invalid_flags,
        arg4: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_v3_invalid(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: bkey_invalid_flags,
        arg4: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_to_text(arg1: *mut printbuf, arg2: *mut bch_fs, arg3: bkey_s_c);
}
extern "C" {
    pub fn bch2_trigger_inode(
        arg1: *mut btree_trans,
        arg2: btree_id,
        arg3: core::ffi::c_uint,
        arg4: bkey_s_c,
        arg5: bkey_s,
        arg6: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_generation_invalid(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: bkey_invalid_flags,
        arg4: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_generation_to_text(arg1: *mut printbuf, arg2: *mut bch_fs, arg3: bkey_s_c);
}
pub type u96 = u64_;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_inode_unpacked {
    pub bi_inum: u64_,
    pub bi_journal_seq: u64_,
    pub bi_hash_seed: __le64,
    pub bi_size: u64_,
    pub bi_sectors: u64_,
    pub bi_version: u64_,
    pub bi_flags: u32_,
    pub bi_mode: u16_,
    pub bi_atime: u96,
    pub bi_ctime: u96,
    pub bi_mtime: u96,
    pub bi_otime: u96,
    pub bi_uid: u32_,
    pub bi_gid: u32_,
    pub bi_nlink: u32_,
    pub bi_generation: u32_,
    pub bi_dev: u32_,
    pub bi_data_checksum: u8_,
    pub bi_compression: u8_,
    pub bi_project: u32_,
    pub bi_background_compression: u8_,
    pub bi_data_replicas: u8_,
    pub bi_promote_target: u16_,
    pub bi_foreground_target: u16_,
    pub bi_background_target: u16_,
    pub bi_erasure_code: u16_,
    pub bi_fields_set: u16_,
    pub bi_dir: u64_,
    pub bi_dir_offset: u64_,
    pub bi_subvol: u32_,
    pub bi_parent_subvol: u32_,
    pub bi_nocow: u8_,
}
#[repr(C, packed(8))]
pub struct bkey_inode_buf {
    pub inode: bkey_i_inode_v3,
    pub _pad: [u8_; 303usize],
}
impl Default for bkey_inode_buf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn bch2_inode_pack(arg1: *mut bkey_inode_buf, arg2: *const bch_inode_unpacked);
}
extern "C" {
    pub fn bch2_inode_unpack(arg1: bkey_s_c, arg2: *mut bch_inode_unpacked) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_to_v3(arg1: *mut btree_trans, arg2: *mut bkey_i) -> *mut bkey_i;
}
extern "C" {
    pub fn bch2_inode_unpacked_to_text(arg1: *mut printbuf, arg2: *mut bch_inode_unpacked);
}
extern "C" {
    pub fn bch2_inode_peek(
        arg1: *mut btree_trans,
        arg2: *mut btree_iter,
        arg3: *mut bch_inode_unpacked,
        arg4: subvol_inum,
        arg5: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_write_flags(
        arg1: *mut btree_trans,
        arg2: *mut btree_iter,
        arg3: *mut bch_inode_unpacked,
        arg4: btree_update_flags,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_init_early(arg1: *mut bch_fs, arg2: *mut bch_inode_unpacked);
}
extern "C" {
    pub fn bch2_inode_init_late(
        arg1: *mut bch_inode_unpacked,
        arg2: u64_,
        arg3: uid_t,
        arg4: gid_t,
        arg5: umode_t,
        arg6: dev_t,
        arg7: *mut bch_inode_unpacked,
    );
}
extern "C" {
    pub fn bch2_inode_init(
        arg1: *mut bch_fs,
        arg2: *mut bch_inode_unpacked,
        arg3: uid_t,
        arg4: gid_t,
        arg5: umode_t,
        arg6: dev_t,
        arg7: *mut bch_inode_unpacked,
    );
}
extern "C" {
    pub fn bch2_inode_create(
        arg1: *mut btree_trans,
        arg2: *mut btree_iter,
        arg3: *mut bch_inode_unpacked,
        arg4: u32_,
        arg5: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_rm(arg1: *mut bch_fs, arg2: subvol_inum) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_find_by_inum_nowarn_trans(
        arg1: *mut btree_trans,
        arg2: subvol_inum,
        arg3: *mut bch_inode_unpacked,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_find_by_inum_trans(
        arg1: *mut btree_trans,
        arg2: subvol_inum,
        arg3: *mut bch_inode_unpacked,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_find_by_inum(
        arg1: *mut bch_fs,
        arg2: subvol_inum,
        arg3: *mut bch_inode_unpacked,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_nlink_inc(arg1: *mut bch_inode_unpacked) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_nlink_dec(arg1: *mut btree_trans, arg2: *mut bch_inode_unpacked);
}
extern "C" {
    pub fn bch2_inode_opts_to_opts(arg1: *mut bch_inode_unpacked) -> bch_opts;
}
extern "C" {
    pub fn bch2_inode_opts_get(
        arg1: *mut bch_io_opts,
        arg2: *mut bch_fs,
        arg3: *mut bch_inode_unpacked,
    );
}
extern "C" {
    pub fn bch2_inum_opts_get(
        arg1: *mut btree_trans,
        arg2: subvol_inum,
        arg3: *mut bch_io_opts,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inode_rm_snapshot(
        arg1: *mut btree_trans,
        arg2: u64_,
        arg3: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_delete_dead_inodes(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_journal_entry_close(arg1: *mut journal) -> bool_;
}
extern "C" {
    pub fn bch2_journal_buf_put_final(arg1: *mut journal, arg2: u64_, arg3: bool_);
}
extern "C" {
    pub fn bch2_journal_res_get_slowpath(
        arg1: *mut journal,
        arg2: *mut journal_res,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_journal_entry_res_resize(
        arg1: *mut journal,
        arg2: *mut journal_entry_res,
        arg3: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bch2_journal_flush_seq_async(
        arg1: *mut journal,
        arg2: u64_,
        arg3: *mut closure,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_journal_flush_async(arg1: *mut journal, arg2: *mut closure);
}
extern "C" {
    pub fn bch2_journal_flush_seq(arg1: *mut journal, arg2: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_journal_flush(arg1: *mut journal) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_journal_noflush_seq(arg1: *mut journal, arg2: u64_) -> bool_;
}
extern "C" {
    pub fn bch2_journal_meta(arg1: *mut journal) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_journal_halt(arg1: *mut journal);
}
extern "C" {
    pub fn bch2_journal_unblock(arg1: *mut journal);
}
extern "C" {
    pub fn bch2_journal_block(arg1: *mut journal);
}
extern "C" {
    pub fn bch2_next_write_buffer_flush_journal_buf(
        j: *mut journal,
        max_seq: u64_,
    ) -> *mut journal_buf;
}
extern "C" {
    pub fn __bch2_journal_debug_to_text(arg1: *mut printbuf, arg2: *mut journal);
}
extern "C" {
    pub fn bch2_journal_debug_to_text(arg1: *mut printbuf, arg2: *mut journal);
}
extern "C" {
    pub fn bch2_journal_pins_to_text(arg1: *mut printbuf, arg2: *mut journal);
}
extern "C" {
    pub fn bch2_journal_seq_pins_to_text(
        arg1: *mut printbuf,
        arg2: *mut journal,
        arg3: *mut u64_,
    ) -> bool_;
}
extern "C" {
    pub fn bch2_set_nr_journal_buckets(
        arg1: *mut bch_fs,
        arg2: *mut bch_dev,
        nr: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_dev_journal_alloc(arg1: *mut bch_dev) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_fs_journal_alloc(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_dev_journal_stop(arg1: *mut journal, arg2: *mut bch_dev);
}
extern "C" {
    pub fn bch2_fs_journal_stop(arg1: *mut journal);
}
extern "C" {
    pub fn bch2_fs_journal_start(arg1: *mut journal, arg2: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_dev_journal_exit(arg1: *mut bch_dev);
}
extern "C" {
    pub fn bch2_dev_journal_init(arg1: *mut bch_dev, arg2: *mut bch_sb) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_fs_journal_exit(arg1: *mut journal);
}
extern "C" {
    pub fn bch2_fs_journal_init(arg1: *mut journal) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_node_prep_for_write(
        arg1: *mut btree_trans,
        arg2: *mut btree_path,
        arg3: *mut btree,
    );
}
extern "C" {
    pub fn bch2_btree_bset_insert_key(
        arg1: *mut btree_trans,
        arg2: *mut btree_path,
        arg3: *mut btree,
        arg4: *mut btree_node_iter,
        arg5: *mut bkey_i,
    ) -> bool_;
}
extern "C" {
    pub fn bch2_btree_node_flush0(
        arg1: *mut journal,
        arg2: *mut journal_entry_pin,
        arg3: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_node_flush1(
        arg1: *mut journal,
        arg2: *mut journal_entry_pin,
        arg3: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_add_journal_pin(arg1: *mut bch_fs, arg2: *mut btree, arg3: u64_);
}
extern "C" {
    pub fn bch2_btree_insert_key_leaf(
        arg1: *mut btree_trans,
        arg2: *mut btree_path,
        arg3: *mut bkey_i,
        arg4: u64_,
    );
}
extern "C" {
    pub fn bch2_btree_delete_extent_at(
        arg1: *mut btree_trans,
        arg2: *mut btree_iter,
        arg3: core::ffi::c_uint,
        arg4: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_delete_at(
        arg1: *mut btree_trans,
        arg2: *mut btree_iter,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_delete(
        arg1: *mut btree_trans,
        arg2: btree_id,
        arg3: bpos,
        arg4: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_insert_nonextent(
        arg1: *mut btree_trans,
        arg2: btree_id,
        arg3: *mut bkey_i,
        arg4: btree_update_flags,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_insert_trans(
        arg1: *mut btree_trans,
        arg2: btree_id,
        arg3: *mut bkey_i,
        arg4: btree_update_flags,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_insert(
        arg1: *mut bch_fs,
        arg2: btree_id,
        arg3: *mut bkey_i,
        arg4: *mut disk_reservation,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_delete_range_trans(
        arg1: *mut btree_trans,
        arg2: btree_id,
        arg3: bpos,
        arg4: bpos,
        arg5: core::ffi::c_uint,
        arg6: *mut u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_delete_range(
        arg1: *mut bch_fs,
        arg2: btree_id,
        arg3: bpos,
        arg4: bpos,
        arg5: core::ffi::c_uint,
        arg6: *mut u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_bit_mod(
        arg1: *mut btree_trans,
        arg2: btree_id,
        arg3: bpos,
        arg4: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __bch2_insert_snapshot_whiteouts(
        arg1: *mut btree_trans,
        arg2: btree_id,
        arg3: bpos,
        arg4: bpos,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_trans_update_extent_overwrite(
        arg1: *mut btree_trans,
        arg2: *mut btree_iter,
        arg3: btree_update_flags,
        arg4: bkey_s_c,
        arg5: bkey_s_c,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_bkey_get_empty_slot(
        arg1: *mut btree_trans,
        arg2: *mut btree_iter,
        arg3: btree_id,
        arg4: bpos,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_trans_update(
        arg1: *mut btree_trans,
        arg2: *mut btree_iter,
        arg3: *mut bkey_i,
        arg4: btree_update_flags,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __bch2_trans_jset_entry_alloc(
        arg1: *mut btree_trans,
        arg2: core::ffi::c_uint,
    ) -> *mut jset_entry;
}
extern "C" {
    pub fn bch2_btree_insert_clone_trans(
        arg1: *mut btree_trans,
        arg2: btree_id,
        arg3: *mut bkey_i,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_trans_commit_hook(arg1: *mut btree_trans, arg2: *mut btree_trans_commit_hook);
}
extern "C" {
    pub fn __bch2_trans_commit(arg1: *mut btree_trans, arg2: core::ffi::c_uint)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_fs_log_msg(
        arg1: *mut bch_fs,
        arg2: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_journal_log_msg(
        arg1: *mut bch_fs,
        arg2: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_extent_crc_unpacked {
    pub compressed_size: u32_,
    pub uncompressed_size: u32_,
    pub live_size: u32_,
    pub csum_type: u8_,
    pub compression_type: u8_,
    pub offset: u16_,
    pub nonce: u16_,
    pub csum: bch_csum,
}
#[repr(C)]
pub struct extent_ptr_decoded {
    pub idx: core::ffi::c_uint,
    pub has_ec: bool_,
    pub crc: bch_extent_crc_unpacked,
    pub ptr: bch_extent_ptr,
    pub ec: bch_extent_stripe_ptr,
}
impl Default for extent_ptr_decoded {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_io_failures {
    pub nr: u8_,
    pub devs: [bch_io_failures_bch_dev_io_failures; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bch_io_failures_bch_dev_io_failures {
    pub dev: u8_,
    pub idx: u8_,
    pub nr_failed: u8_,
    pub nr_retries: u8_,
}
extern "C" {
    pub fn bch2_mark_io_failure(arg1: *mut bch_io_failures, arg2: *mut extent_ptr_decoded);
}
extern "C" {
    pub fn bch2_bkey_pick_read_device(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: *mut bch_io_failures,
        arg4: *mut extent_ptr_decoded,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_ptr_invalid(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: bkey_invalid_flags,
        arg4: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_ptr_to_text(arg1: *mut printbuf, arg2: *mut bch_fs, arg3: bkey_s_c);
}
extern "C" {
    pub fn bch2_btree_ptr_v2_invalid(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: bkey_invalid_flags,
        arg4: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_btree_ptr_v2_to_text(arg1: *mut printbuf, arg2: *mut bch_fs, arg3: bkey_s_c);
}
extern "C" {
    pub fn bch2_btree_ptr_v2_compat(
        arg1: btree_id,
        arg2: core::ffi::c_uint,
        arg3: core::ffi::c_uint,
        arg4: core::ffi::c_int,
        arg5: bkey_s,
    );
}
extern "C" {
    pub fn bch2_extent_merge(arg1: *mut bch_fs, arg2: bkey_s, arg3: bkey_s_c) -> bool_;
}
extern "C" {
    pub fn bch2_reservation_invalid(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: bkey_invalid_flags,
        arg4: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_reservation_to_text(arg1: *mut printbuf, arg2: *mut bch_fs, arg3: bkey_s_c);
}
extern "C" {
    pub fn bch2_reservation_merge(arg1: *mut bch_fs, arg2: bkey_s, arg3: bkey_s_c) -> bool_;
}
extern "C" {
    pub fn bch2_can_narrow_extent_crcs(arg1: bkey_s_c, arg2: bch_extent_crc_unpacked) -> bool_;
}
extern "C" {
    pub fn bch2_bkey_narrow_crcs(arg1: *mut bkey_i, arg2: bch_extent_crc_unpacked) -> bool_;
}
extern "C" {
    pub fn bch2_extent_crc_append(arg1: *mut bkey_i, arg2: bch_extent_crc_unpacked);
}
extern "C" {
    pub fn bch2_bkey_nr_ptrs(arg1: bkey_s_c) -> core::ffi::c_uint;
}
extern "C" {
    pub fn bch2_bkey_nr_ptrs_allocated(arg1: bkey_s_c) -> core::ffi::c_uint;
}
extern "C" {
    pub fn bch2_bkey_nr_ptrs_fully_allocated(arg1: bkey_s_c) -> core::ffi::c_uint;
}
extern "C" {
    pub fn bch2_bkey_is_incompressible(arg1: bkey_s_c) -> bool_;
}
extern "C" {
    pub fn bch2_bkey_sectors_compressed(arg1: bkey_s_c) -> core::ffi::c_uint;
}
extern "C" {
    pub fn bch2_bkey_replicas(arg1: *mut bch_fs, arg2: bkey_s_c) -> core::ffi::c_uint;
}
extern "C" {
    pub fn bch2_extent_ptr_desired_durability(
        arg1: *mut bch_fs,
        arg2: *mut extent_ptr_decoded,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn bch2_extent_ptr_durability(
        arg1: *mut bch_fs,
        arg2: *mut extent_ptr_decoded,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn bch2_bkey_durability(arg1: *mut bch_fs, arg2: bkey_s_c) -> core::ffi::c_uint;
}
extern "C" {
    pub fn bch2_bkey_drop_device(arg1: bkey_s, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn bch2_bkey_drop_device_noerror(arg1: bkey_s, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn bch2_bkey_has_device_c(arg1: bkey_s_c, arg2: core::ffi::c_uint)
        -> *const bch_extent_ptr;
}
extern "C" {
    pub fn bch2_bkey_has_target(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn bch2_bkey_extent_entry_drop(arg1: *mut bkey_i, arg2: *mut bch_extent_entry);
}
extern "C" {
    pub fn bch2_extent_ptr_decoded_append(arg1: *mut bkey_i, arg2: *mut extent_ptr_decoded);
}
extern "C" {
    pub fn bch2_bkey_drop_ptr_noerror(
        arg1: bkey_s,
        arg2: *mut bch_extent_ptr,
    ) -> *mut bch_extent_entry;
}
extern "C" {
    pub fn bch2_bkey_drop_ptr(arg1: bkey_s, arg2: *mut bch_extent_ptr) -> *mut bch_extent_entry;
}
extern "C" {
    pub fn bch2_bkey_matches_ptr(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: bch_extent_ptr,
        arg4: u64_,
    ) -> bool_;
}
extern "C" {
    pub fn bch2_extents_match(arg1: bkey_s_c, arg2: bkey_s_c) -> bool_;
}
extern "C" {
    pub fn bch2_extent_has_ptr(
        arg1: bkey_s_c,
        arg2: extent_ptr_decoded,
        arg3: bkey_s,
    ) -> *mut bch_extent_ptr;
}
extern "C" {
    pub fn bch2_extent_ptr_set_cached(arg1: bkey_s, arg2: *mut bch_extent_ptr);
}
extern "C" {
    pub fn bch2_extent_normalize(arg1: *mut bch_fs, arg2: bkey_s) -> bool_;
}
extern "C" {
    pub fn bch2_bkey_ptrs_to_text(arg1: *mut printbuf, arg2: *mut bch_fs, arg3: bkey_s_c);
}
extern "C" {
    pub fn bch2_bkey_ptrs_invalid(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: bkey_invalid_flags,
        arg4: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_ptr_swab(arg1: bkey_s);
}
extern "C" {
    pub fn bch2_bkey_rebalance_opts(arg1: bkey_s_c) -> *const bch_extent_rebalance;
}
extern "C" {
    pub fn bch2_bkey_ptrs_need_rebalance(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: core::ffi::c_uint,
        arg4: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn bch2_bkey_needs_rebalance(arg1: *mut bch_fs, arg2: bkey_s_c) -> bool_;
}
extern "C" {
    pub fn bch2_bkey_set_needs_rebalance(
        arg1: *mut bch_fs,
        arg2: *mut bkey_i,
        arg3: *mut bch_io_opts,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_cut_front_s(arg1: bpos, arg2: bkey_s) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_cut_back_s(arg1: bpos, arg2: bkey_s) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_dev_to_fs(arg1: dev_t) -> *mut bch_fs;
}
extern "C" {
    pub fn bch2_uuid_to_fs(arg1: __uuid_t) -> *mut bch_fs;
}
extern "C" {
    pub fn bch2_dev_state_allowed(
        arg1: *mut bch_fs,
        arg2: *mut bch_dev,
        arg3: bch_member_state,
        arg4: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn __bch2_dev_set_state(
        arg1: *mut bch_fs,
        arg2: *mut bch_dev,
        arg3: bch_member_state,
        arg4: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_dev_set_state(
        arg1: *mut bch_fs,
        arg2: *mut bch_dev,
        arg3: bch_member_state,
        arg4: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_dev_fail(arg1: *mut bch_dev, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_dev_remove(
        arg1: *mut bch_fs,
        arg2: *mut bch_dev,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_dev_add(arg1: *mut bch_fs, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_dev_online(arg1: *mut bch_fs, arg2: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_dev_offline(
        arg1: *mut bch_fs,
        arg2: *mut bch_dev,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_dev_resize(arg1: *mut bch_fs, arg2: *mut bch_dev, arg3: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_dev_lookup(arg1: *mut bch_fs, arg2: *const core::ffi::c_char) -> *mut bch_dev;
}
extern "C" {
    pub fn bch2_fs_emergency_read_only(arg1: *mut bch_fs) -> bool_;
}
extern "C" {
    pub fn bch2_fs_read_only(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fs_read_write(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_fs_read_write_early(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn __bch2_fs_stop(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fs_free(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fs_stop(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fs_start(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_fs_open(
        arg1: *const *mut core::ffi::c_char,
        arg2: core::ffi::c_uint,
        arg3: bch_opts,
    ) -> *mut bch_fs;
}
extern "C" {
    pub fn bch2_sb_members_v2_init(c: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_sb_members_cpy_v2_v1(disk_sb: *mut bch_sb_handle) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_members_v2_get_mut(sb: *mut bch_sb, i: core::ffi::c_int) -> *mut bch_member;
}
extern "C" {
    pub fn bch2_sb_member_get(sb: *mut bch_sb, i: core::ffi::c_int) -> bch_member;
}
extern "C" {
    pub fn bch2_sb_members_from_cpu(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_dev_io_errors_to_text(arg1: *mut printbuf, arg2: *mut bch_dev);
}
extern "C" {
    pub fn bch2_dev_errors_reset(arg1: *mut bch_dev);
}
extern "C" {
    pub fn bch2_version_to_text(arg1: *mut printbuf, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn bch2_latest_compatible_version(arg1: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
    pub fn bch2_sb_field_get_id(arg1: *mut bch_sb, arg2: bch_sb_field_type) -> *mut bch_sb_field;
}
extern "C" {
    pub fn bch2_sb_field_resize_id(
        arg1: *mut bch_sb_handle,
        arg2: bch_sb_field_type,
        arg3: core::ffi::c_uint,
    ) -> *mut bch_sb_field;
}
extern "C" {
    pub fn bch2_sb_field_get_minsize_id(
        arg1: *mut bch_sb_handle,
        arg2: bch_sb_field_type,
        arg3: core::ffi::c_uint,
    ) -> *mut bch_sb_field;
}
extern "C" {
    pub fn bch2_sb_field_delete(arg1: *mut bch_sb_handle, arg2: bch_sb_field_type);
}
extern "C" {
    pub fn bch2_sb_to_fs(arg1: *mut bch_fs, arg2: *mut bch_sb) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_sb_from_fs(arg1: *mut bch_fs, arg2: *mut bch_dev) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_free_super(arg1: *mut bch_sb_handle);
}
extern "C" {
    pub fn bch2_sb_realloc(arg1: *mut bch_sb_handle, arg2: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_read_super(
        arg1: *const core::ffi::c_char,
        arg2: *mut bch_opts,
        arg3: *mut bch_sb_handle,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_read_super_silent(
        arg1: *const core::ffi::c_char,
        arg2: *mut bch_opts,
        arg3: *mut bch_sb_handle,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_write_super(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn __bch2_check_set_feature(arg1: *mut bch_fs, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn bch2_check_version_downgrade(arg1: *mut bch_fs) -> bool_;
}
extern "C" {
    pub fn bch2_sb_upgrade(arg1: *mut bch_fs, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn __bch2_sb_field_to_text(arg1: *mut printbuf, arg2: *mut bch_sb, arg3: *mut bch_sb_field);
}
extern "C" {
    pub fn bch2_sb_field_to_text(arg1: *mut printbuf, arg2: *mut bch_sb, arg3: *mut bch_sb_field);
}
extern "C" {
    pub fn bch2_sb_layout_to_text(arg1: *mut printbuf, arg2: *mut bch_sb_layout);
}
extern "C" {
    pub fn bch2_sb_to_text(
        arg1: *mut printbuf,
        arg2: *mut bch_sb,
        arg3: bool_,
        arg4: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bch2_checksum_merge(
        arg1: core::ffi::c_uint,
        arg2: bch_csum,
        arg3: bch_csum,
        arg4: usize,
    ) -> bch_csum;
}
extern "C" {
    pub fn bch2_checksum(
        arg1: *mut bch_fs,
        arg2: core::ffi::c_uint,
        arg3: nonce,
        arg4: *const core::ffi::c_void,
        arg5: usize,
    ) -> bch_csum;
}
extern "C" {
    pub fn bch2_chacha_encrypt_key(
        arg1: *mut bch_key,
        arg2: nonce,
        arg3: *mut core::ffi::c_void,
        arg4: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_request_key(arg1: *mut bch_sb, arg2: *mut bch_key) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_encrypt(
        arg1: *mut bch_fs,
        arg2: core::ffi::c_uint,
        arg3: nonce,
        data: *mut core::ffi::c_void,
        arg4: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_checksum_bio(
        arg1: *mut bch_fs,
        arg2: core::ffi::c_uint,
        arg3: nonce,
        arg4: *mut bio,
    ) -> bch_csum;
}
extern "C" {
    pub fn bch2_rechecksum_bio(
        arg1: *mut bch_fs,
        arg2: *mut bio,
        arg3: bversion,
        arg4: bch_extent_crc_unpacked,
        arg5: *mut bch_extent_crc_unpacked,
        arg6: *mut bch_extent_crc_unpacked,
        arg7: core::ffi::c_uint,
        arg8: core::ffi::c_uint,
        arg9: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __bch2_encrypt_bio(
        arg1: *mut bch_fs,
        arg2: core::ffi::c_uint,
        arg3: nonce,
        arg4: *mut bio,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_decrypt_sb_key(
        arg1: *mut bch_fs,
        arg2: *mut bch_sb_field_crypt,
        arg3: *mut bch_key,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_disable_encryption(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_enable_encryption(arg1: *mut bch_fs, arg2: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_fs_encryption_exit(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fs_encryption_init(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_sb_error_count(arg1: *mut bch_fs, arg2: bch_sb_error_id);
}
extern "C" {
    pub fn bch2_sb_errors_from_cpu(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fs_sb_errors_exit(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fs_sb_errors_init_early(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fs_sb_errors_init(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_inconsistent_error(arg1: *mut bch_fs) -> bool_;
}
extern "C" {
    pub fn bch2_topology_error(arg1: *mut bch_fs);
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum bch_fsck_flags {
    FSCK_CAN_FIX = 1,
    FSCK_CAN_IGNORE = 2,
    FSCK_NEED_FSCK = 4,
    FSCK_NO_RATELIMIT = 8,
}
extern "C" {
    pub fn bch2_fsck_err(
        arg1: *mut bch_fs,
        arg2: bch_fsck_flags,
        arg3: bch_sb_error_id,
        arg4: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_flush_fsck_errs(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fatal_error(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_io_error_work(arg1: *mut work_struct);
}
extern "C" {
    pub fn bch2_io_error(arg1: *mut bch_dev, arg2: bch_member_error_type);
}
extern "C" {
    pub fn bch2_check_subvols(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_subvolume_invalid(
        arg1: *mut bch_fs,
        arg2: bkey_s_c,
        arg3: bkey_invalid_flags,
        arg4: *mut printbuf,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_subvolume_to_text(arg1: *mut printbuf, arg2: *mut bch_fs, arg3: bkey_s_c);
}
extern "C" {
    pub fn bch2_subvolume_get(
        arg1: *mut btree_trans,
        arg2: core::ffi::c_uint,
        arg3: bool_,
        arg4: core::ffi::c_int,
        arg5: *mut bch_subvolume,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_subvolume_get_snapshot(
        arg1: *mut btree_trans,
        arg2: u32_,
        arg3: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_subvol_is_ro_trans(arg1: *mut btree_trans, arg2: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_subvol_is_ro(arg1: *mut bch_fs, arg2: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_delete_dead_snapshots(arg1: *mut bch_fs) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_delete_dead_snapshots_async(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_subvolume_unlink(arg1: *mut btree_trans, arg2: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_subvolume_create(
        arg1: *mut btree_trans,
        arg2: u64_,
        arg3: u32_,
        arg4: *mut u32_,
        arg5: *mut u32_,
        arg6: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_fs_subvolumes_init(arg1: *mut bch_fs) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_type {
    _unused: [u8; 0],
}
#[doc = " struct cipher_alg - single-block symmetric ciphers definition\n @cia_min_keysize: Minimum key size supported by the transformation. This is\n\t\t     the smallest key length supported by this transformation\n\t\t     algorithm. This must be set to one of the pre-defined\n\t\t     values as this is not hardware specific. Possible values\n\t\t     for this field can be found via git grep \"_MIN_KEY_SIZE\"\n\t\t     include/crypto/\n @cia_max_keysize: Maximum key size supported by the transformation. This is\n\t\t    the largest key length supported by this transformation\n\t\t    algorithm. This must be set to one of the pre-defined values\n\t\t    as this is not hardware specific. Possible values for this\n\t\t    field can be found via git grep \"_MAX_KEY_SIZE\"\n\t\t    include/crypto/\n @cia_setkey: Set key for the transformation. This function is used to either\n\t        program a supplied key into the hardware or store the key in the\n\t        transformation context for programming it later. Note that this\n\t        function does modify the transformation context. This function\n\t        can be called multiple times during the existence of the\n\t        transformation object, so one must make sure the key is properly\n\t        reprogrammed into the hardware. This function is also\n\t        responsible for checking the key length for validity.\n @cia_encrypt: Encrypt a single block. This function is used to encrypt a\n\t\t single block of data, which must be @cra_blocksize big. This\n\t\t always operates on a full @cra_blocksize and it is not possible\n\t\t to encrypt a block of smaller size. The supplied buffers must\n\t\t therefore also be at least of @cra_blocksize size. Both the\n\t\t input and output buffers are always aligned to @cra_alignmask.\n\t\t In case either of the input or output buffer supplied by user\n\t\t of the crypto API is not aligned to @cra_alignmask, the crypto\n\t\t API will re-align the buffers. The re-alignment means that a\n\t\t new buffer will be allocated, the data will be copied into the\n\t\t new buffer, then the processing will happen on the new buffer,\n\t\t then the data will be copied back into the original buffer and\n\t\t finally the new buffer will be freed. In case a software\n\t\t fallback was put in place in the @cra_init call, this function\n\t\t might need to use the fallback if the algorithm doesn't support\n\t\t all of the key sizes. In case the key was stored in\n\t\t transformation context, the key might need to be re-programmed\n\t\t into the hardware in this function. This function shall not\n\t\t modify the transformation context, as this function may be\n\t\t called in parallel with the same transformation object.\n @cia_decrypt: Decrypt a single block. This is a reverse counterpart to\n\t\t @cia_encrypt, and the conditions are exactly the same.\n\n All fields are mandatory and must be filled."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cipher_alg {
    pub cia_min_keysize: core::ffi::c_uint,
    pub cia_max_keysize: core::ffi::c_uint,
    pub cia_setkey: ::core::option::Option<
        unsafe extern "C" fn(
            tfm: *mut crypto_tfm,
            key: *const u8_,
            keylen: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub cia_encrypt: ::core::option::Option<
        unsafe extern "C" fn(tfm: *mut crypto_tfm, dst: *mut u8_, src: *const u8_),
    >,
    pub cia_decrypt: ::core::option::Option<
        unsafe extern "C" fn(tfm: *mut crypto_tfm, dst: *mut u8_, src: *const u8_),
    >,
}
#[doc = " struct compress_alg - compression/decompression algorithm\n @coa_compress: Compress a buffer of specified length, storing the resulting\n\t\t  data in the specified buffer. Return the length of the\n\t\t  compressed data in dlen.\n @coa_decompress: Decompress the source buffer, storing the uncompressed\n\t\t    data in the specified buffer. The length of the data is\n\t\t    returned in dlen.\n\n All fields are mandatory."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compress_alg {
    pub coa_compress: ::core::option::Option<
        unsafe extern "C" fn(
            tfm: *mut crypto_tfm,
            src: *const u8_,
            slen: core::ffi::c_uint,
            dst: *mut u8_,
            dlen: *mut core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub coa_decompress: ::core::option::Option<
        unsafe extern "C" fn(
            tfm: *mut crypto_tfm,
            src: *const u8_,
            slen: core::ffi::c_uint,
            dst: *mut u8_,
            dlen: *mut core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
}
#[doc = " struct crypto_alg - definition of a cryptograpic cipher algorithm\n @cra_flags: Flags describing this transformation. See include/linux/crypto.h\n\t       CRYPTO_ALG_* flags for the flags which go in here. Those are\n\t       used for fine-tuning the description of the transformation\n\t       algorithm.\n @cra_blocksize: Minimum block size of this transformation. The size in bytes\n\t\t   of the smallest possible unit which can be transformed with\n\t\t   this algorithm. The users must respect this value.\n\t\t   In case of HASH transformation, it is possible for a smaller\n\t\t   block than @cra_blocksize to be passed to the crypto API for\n\t\t   transformation, in case of any other transformation type, an\n \t\t   error will be returned upon any attempt to transform smaller\n\t\t   than @cra_blocksize chunks.\n @cra_ctxsize: Size of the operational context of the transformation. This\n\t\t value informs the kernel crypto API about the memory size\n\t\t needed to be allocated for the transformation context.\n @cra_alignmask: For cipher, skcipher, lskcipher, and aead algorithms this is\n\t\t   1 less than the alignment, in bytes, that the algorithm\n\t\t   implementation requires for input and output buffers.  When\n\t\t   the crypto API is invoked with buffers that are not aligned\n\t\t   to this alignment, the crypto API automatically utilizes\n\t\t   appropriately aligned temporary buffers to comply with what\n\t\t   the algorithm needs.  (For scatterlists this happens only if\n\t\t   the algorithm uses the skcipher_walk helper functions.)  This\n\t\t   misalignment handling carries a performance penalty, so it is\n\t\t   preferred that algorithms do not set a nonzero alignmask.\n\t\t   Also, crypto API users may wish to allocate buffers aligned\n\t\t   to the alignmask of the algorithm being used, in order to\n\t\t   avoid the API having to realign them.  Note: the alignmask is\n\t\t   not supported for hash algorithms and is always 0 for them.\n @cra_priority: Priority of this transformation implementation. In case\n\t\t  multiple transformations with same @cra_name are available to\n\t\t  the Crypto API, the kernel will use the one with highest\n\t\t  @cra_priority.\n @cra_name: Generic name (usable by multiple implementations) of the\n\t      transformation algorithm. This is the name of the transformation\n\t      itself. This field is used by the kernel when looking up the\n\t      providers of particular transformation.\n @cra_driver_name: Unique name of the transformation provider. This is the\n\t\t     name of the provider of the transformation. This can be any\n\t\t     arbitrary value, but in the usual case, this contains the\n\t\t     name of the chip or provider and the name of the\n\t\t     transformation algorithm.\n @cra_type: Type of the cryptographic transformation. This is a pointer to\n\t      struct crypto_type, which implements callbacks common for all\n\t      transformation types. There are multiple options, such as\n\t      &crypto_skcipher_type, &crypto_ahash_type, &crypto_rng_type.\n\t      This field might be empty. In that case, there are no common\n\t      callbacks. This is the case for: cipher, compress, shash.\n @cra_u: Callbacks implementing the transformation. This is a union of\n\t   multiple structures. Depending on the type of transformation selected\n\t   by @cra_type and @cra_flags above, the associated structure must be\n\t   filled with callbacks. This field might be empty. This is the case\n\t   for ahash, shash.\n @cra_init: Initialize the cryptographic transformation object. This function\n\t      is used to initialize the cryptographic transformation object.\n\t      This function is called only once at the instantiation time, right\n\t      after the transformation context was allocated. In case the\n\t      cryptographic hardware has some special requirements which need to\n\t      be handled by software, this function shall check for the precise\n\t      requirement of the transformation and put any software fallbacks\n\t      in place.\n @cra_exit: Deinitialize the cryptographic transformation object. This is a\n\t      counterpart to @cra_init, used to remove various changes set in\n\t      @cra_init.\n @cra_u.cipher: Union member which contains a single-block symmetric cipher\n\t\t  definition. See @struct @cipher_alg.\n @cra_u.compress: Union member which contains a (de)compression algorithm.\n\t\t    See @struct @compress_alg.\n @cra_module: Owner of this transformation implementation. Set to THIS_MODULE\n @cra_list: internally used\n @cra_users: internally used\n @cra_refcnt: internally used\n @cra_destroy: internally used\n\n The struct crypto_alg describes a generic Crypto API algorithm and is common\n for all of the transformations. Any variable not documented here shall not\n be used by a cipher implementation as it is internal to the Crypto API."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_alg {
    pub cra_list: list_head,
    pub cra_users: list_head,
    pub cra_flags: u32_,
    pub cra_blocksize: core::ffi::c_uint,
    pub cra_ctxsize: core::ffi::c_uint,
    pub cra_alignmask: core::ffi::c_uint,
    pub cra_priority: core::ffi::c_int,
    pub cra_refcnt: refcount_t,
    pub cra_name: [core::ffi::c_char; 128usize],
    pub cra_driver_name: [core::ffi::c_char; 128usize],
    pub cra_type: *const crypto_type,
    pub cra_u: crypto_alg__bindgen_ty_1,
    pub cra_init:
        ::core::option::Option<unsafe extern "C" fn(tfm: *mut crypto_tfm) -> core::ffi::c_int>,
    pub cra_exit: ::core::option::Option<unsafe extern "C" fn(tfm: *mut crypto_tfm)>,
    pub cra_destroy: ::core::option::Option<unsafe extern "C" fn(alg: *mut crypto_alg)>,
    pub cra_module: *mut module,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union crypto_alg__bindgen_ty_1 {
    pub cipher: cipher_alg,
    pub compress: compress_alg,
}
impl Default for crypto_alg__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for crypto_alg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct crypto_tfm {
    pub refcnt: refcount_t,
    pub crt_flags: u32_,
    pub node: core::ffi::c_int,
    pub exit: ::core::option::Option<unsafe extern "C" fn(tfm: *mut crypto_tfm)>,
    pub __crt_alg: *mut crypto_alg,
    pub __crt_ctx: __IncompleteArrayField<*mut core::ffi::c_void>,
}
impl Default for crypto_tfm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct crypto_shash {
    pub descsize: core::ffi::c_uint,
    pub base: crypto_tfm,
}
impl Default for crypto_shash {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct two_state_lock_t {
    pub v: atomic_long_t,
    pub wait: wait_queue_head_t,
}
impl Default for two_state_lock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __bch2_two_state_lock(arg1: *mut two_state_lock_t, arg2: core::ffi::c_int);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bch_inode_info {
    pub v: inode,
    pub ei_vfs_inode_list: list_head,
    pub ei_flags: core::ffi::c_ulong,
    pub ei_update_lock: mutex,
    pub ei_quota_reserved: u64_,
    pub ei_last_dirtied: core::ffi::c_ulong,
    pub ei_pagecache_lock: two_state_lock_t,
    pub ei_quota_lock: mutex,
    pub ei_qid: bch_qid,
    pub ei_subvol: u32_,
    pub ei_devs_need_flush: bch_devs_mask,
    pub ei_inode: bch_inode_unpacked,
}
impl Default for bch_inode_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __bch2_create(
        arg1: *mut mnt_idmap,
        arg2: *mut bch_inode_info,
        arg3: *mut dentry,
        arg4: umode_t,
        arg5: dev_t,
        arg6: subvol_inum,
        arg7: core::ffi::c_uint,
    ) -> *mut bch_inode_info;
}
extern "C" {
    pub fn bch2_fs_quota_transfer(
        arg1: *mut bch_fs,
        arg2: *mut bch_inode_info,
        arg3: bch_qid,
        arg4: core::ffi::c_uint,
        arg5: quota_acct_mode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_vfs_inode_get(arg1: *mut bch_fs, arg2: subvol_inum) -> *mut inode;
}
pub type inode_set_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut btree_trans,
        arg2: *mut bch_inode_info,
        arg3: *mut bch_inode_unpacked,
        arg4: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn bch2_inode_update_after_write(
        arg1: *mut btree_trans,
        arg2: *mut bch_inode_info,
        arg3: *mut bch_inode_unpacked,
        arg4: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bch2_write_inode(
        arg1: *mut bch_fs,
        arg2: *mut bch_inode_info,
        arg3: inode_set_fn,
        arg4: *mut core::ffi::c_void,
        arg5: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_setattr_nonsize(
        arg1: *mut mnt_idmap,
        arg2: *mut bch_inode_info,
        arg3: *mut iattr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __bch2_unlink(arg1: *mut inode, arg2: *mut dentry, arg3: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn bch2_evict_subvolume_inodes(arg1: *mut bch_fs, arg2: *mut snapshot_id_list);
}
extern "C" {
    pub fn bch2_vfs_exit();
}
extern "C" {
    pub fn bch2_vfs_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn __bch2_btree_verify(arg1: *mut bch_fs, arg2: *mut btree);
}
extern "C" {
    pub fn bch2_btree_node_ondisk_to_text(
        arg1: *mut printbuf,
        arg2: *mut bch_fs,
        arg3: *const btree,
    );
}
extern "C" {
    pub fn bch2_fs_debug_exit(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_fs_debug_init(arg1: *mut bch_fs);
}
extern "C" {
    pub fn bch2_debug_exit();
}
extern "C" {
    pub fn bch2_debug_init() -> core::ffi::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: core::ffi::c_uint,
    pub fp_offset: core::ffi::c_uint,
    pub overflow_arg_area: *mut core::ffi::c_void,
    pub reg_save_area: *mut core::ffi::c_void,
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_symbol {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct module_sect_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct module_notes_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct trace_event_call {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct static_key_mod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ldt_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct page_pool {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct userfaultfd_ctx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct linux_binfmt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct assoc_array_ptr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct watch_list {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct key_user {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct wait_page_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_lock_context {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cdev {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xattr_handler {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fscrypt_keyring {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct unicode_map {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mtd_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernfs_root {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_qos {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct module_param_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct of_device_id {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_id {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dma_map_ops {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bus_dma_region {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cma {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct io_tlb_mem {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct disk_stats {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bio_alloc_cache {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_integrity_profile {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timer_rand_state {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cdrom_device_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_mq_ops {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_mq_ctx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_mq_tags {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct throtl_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_mq_tag_set {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_stripe_new {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct crypto_sync_skcipher {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct journal_replay {
    pub _address: u8,
}
